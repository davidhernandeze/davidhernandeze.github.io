function Tw(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(t,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();/**
* @vue/shared v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function qh(t){const e=Object.create(null);for(const n of t.split(","))e[n]=1;return n=>n in e}const bt={},Pi=[],ps=()=>{},Nw=()=>!1,Nc=t=>t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&(t.charCodeAt(2)>122||t.charCodeAt(2)<97),Xh=t=>t.startsWith("onUpdate:"),cn=Object.assign,Yh=(t,e)=>{const n=t.indexOf(e);n>-1&&t.splice(n,1)},Ew=Object.prototype.hasOwnProperty,ut=(t,e)=>Ew.call(t,e),Ge=Array.isArray,Da=t=>Ec(t)==="[object Map]",_w=t=>Ec(t)==="[object Set]",Ue=t=>typeof t=="function",ln=t=>typeof t=="string",ea=t=>typeof t=="symbol",qt=t=>t!==null&&typeof t=="object",Cm=t=>(qt(t)||Ue(t))&&Ue(t.then)&&Ue(t.catch),Iw=Object.prototype.toString,Ec=t=>Iw.call(t),kw=t=>Ec(t).slice(8,-1),Rw=t=>Ec(t)==="[object Object]",Qh=t=>ln(t)&&t!=="NaN"&&t[0]!=="-"&&""+parseInt(t,10)===t,Pa=qh(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),_c=t=>{const e=Object.create(null);return n=>e[n]||(e[n]=t(n))},Aw=/-(\w)/g,Ar=_c(t=>t.replace(Aw,(e,n)=>n?n.toUpperCase():"")),Ow=/\B([A-Z])/g,ii=_c(t=>t.replace(Ow,"-$1").toLowerCase()),Ic=_c(t=>t.charAt(0).toUpperCase()+t.slice(1)),ll=_c(t=>t?`on${Ic(t)}`:""),ao=(t,e)=>!Object.is(t,e),hl=(t,...e)=>{for(let n=0;n<t.length;n++)t[n](...e)},$m=(t,e,n,r=!1)=>{Object.defineProperty(t,e,{configurable:!0,enumerable:!1,writable:r,value:n})},Dw=t=>{const e=parseFloat(t);return isNaN(e)?t:e};let gd;const kc=()=>gd||(gd=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Zh(t){if(Ge(t)){const e={};for(let n=0;n<t.length;n++){const r=t[n],s=ln(r)?Bw(r):Zh(r);if(s)for(const o in s)e[o]=s[o]}return e}else if(ln(t)||qt(t))return t}const Pw=/;(?![^(]*\))/g,Fw=/:([^]+)/,Lw=/\/\*[^]*?\*\//g;function Bw(t){const e={};return t.replace(Lw,"").split(Pw).forEach(n=>{if(n){const r=n.split(Fw);r.length>1&&(e[r[0].trim()]=r[1].trim())}}),e}function Jh(t){let e="";if(ln(t))e=t;else if(Ge(t))for(let n=0;n<t.length;n++){const r=Jh(t[n]);r&&(e+=r+" ")}else if(qt(t))for(const n in t)t[n]&&(e+=n+" ");return e.trim()}const Mw="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Vw=qh(Mw);function Tm(t){return!!t||t===""}/**
* @vue/reactivity v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let hr;class Uw{constructor(e=!1){this.detached=e,this._active=!0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=hr,!e&&hr&&(this.index=(hr.scopes||(hr.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let e,n;if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].pause();for(e=0,n=this.effects.length;e<n;e++)this.effects[e].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let e,n;if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].resume();for(e=0,n=this.effects.length;e<n;e++)this.effects[e].resume()}}run(e){if(this._active){const n=hr;try{return hr=this,e()}finally{hr=n}}}on(){hr=this}off(){hr=this.parent}stop(e){if(this._active){let n,r;for(n=0,r=this.effects.length;n<r;n++)this.effects[n].stop();for(n=0,r=this.cleanups.length;n<r;n++)this.cleanups[n]();if(this.scopes)for(n=0,r=this.scopes.length;n<r;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!e){const s=this.parent.scopes.pop();s&&s!==this&&(this.parent.scopes[this.index]=s,s.index=this.index)}this.parent=void 0,this._active=!1}}}function Ww(){return hr}let St;const fl=new WeakSet;class Nm{constructor(e){this.fn=e,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,hr&&hr.active&&hr.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,fl.has(this)&&(fl.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||_m(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,yd(this),Im(this);const e=St,n=qr;St=this,qr=!0;try{return this.fn()}finally{km(this),St=e,qr=n,this.flags&=-3}}stop(){if(this.flags&1){for(let e=this.deps;e;e=e.nextDep)nf(e);this.deps=this.depsTail=void 0,yd(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?fl.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Wl(this)&&this.run()}get dirty(){return Wl(this)}}let Em=0,Fa,La;function _m(t,e=!1){if(t.flags|=8,e){t.next=La,La=t;return}t.next=Fa,Fa=t}function ef(){Em++}function tf(){if(--Em>0)return;if(La){let e=La;for(La=void 0;e;){const n=e.next;e.next=void 0,e.flags&=-9,e=n}}let t;for(;Fa;){let e=Fa;for(Fa=void 0;e;){const n=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(r){t||(t=r)}e=n}}if(t)throw t}function Im(t){for(let e=t.deps;e;e=e.nextDep)e.version=-1,e.prevActiveLink=e.dep.activeLink,e.dep.activeLink=e}function km(t){let e,n=t.depsTail,r=n;for(;r;){const s=r.prevDep;r.version===-1?(r===n&&(n=s),nf(r),zw(r)):e=r,r.dep.activeLink=r.prevActiveLink,r.prevActiveLink=void 0,r=s}t.deps=e,t.depsTail=n}function Wl(t){for(let e=t.deps;e;e=e.nextDep)if(e.dep.version!==e.version||e.dep.computed&&(Rm(e.dep.computed)||e.dep.version!==e.version))return!0;return!!t._dirty}function Rm(t){if(t.flags&4&&!(t.flags&16)||(t.flags&=-17,t.globalVersion===Ha))return;t.globalVersion=Ha;const e=t.dep;if(t.flags|=2,e.version>0&&!t.isSSR&&t.deps&&!Wl(t)){t.flags&=-3;return}const n=St,r=qr;St=t,qr=!0;try{Im(t);const s=t.fn(t._value);(e.version===0||ao(s,t._value))&&(t._value=s,e.version++)}catch(s){throw e.version++,s}finally{St=n,qr=r,km(t),t.flags&=-3}}function nf(t,e=!1){const{dep:n,prevSub:r,nextSub:s}=t;if(r&&(r.nextSub=s,t.prevSub=void 0),s&&(s.prevSub=r,t.nextSub=void 0),n.subs===t&&(n.subs=r,!r&&n.computed)){n.computed.flags&=-5;for(let o=n.computed.deps;o;o=o.nextDep)nf(o,!0)}!e&&!--n.sc&&n.map&&n.map.delete(n.key)}function zw(t){const{prevDep:e,nextDep:n}=t;e&&(e.nextDep=n,t.prevDep=void 0),n&&(n.prevDep=e,t.nextDep=void 0)}let qr=!0;const Am=[];function go(){Am.push(qr),qr=!1}function yo(){const t=Am.pop();qr=t===void 0?!0:t}function yd(t){const{cleanup:e}=t;if(t.cleanup=void 0,e){const n=St;St=void 0;try{e()}finally{St=n}}}let Ha=0;class Gw{constructor(e,n){this.sub=e,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class rf{constructor(e){this.computed=e,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0}track(e){if(!St||!qr||St===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==St)n=this.activeLink=new Gw(St,this),St.deps?(n.prevDep=St.depsTail,St.depsTail.nextDep=n,St.depsTail=n):St.deps=St.depsTail=n,Om(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const r=n.nextDep;r.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=r),n.prevDep=St.depsTail,n.nextDep=void 0,St.depsTail.nextDep=n,St.depsTail=n,St.deps===n&&(St.deps=r)}return n}trigger(e){this.version++,Ha++,this.notify(e)}notify(e){ef();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{tf()}}}function Om(t){if(t.dep.sc++,t.sub.flags&4){const e=t.dep.computed;if(e&&!t.dep.subs){e.flags|=20;for(let r=e.deps;r;r=r.nextDep)Om(r)}const n=t.dep.subs;n!==t&&(t.prevSub=n,n&&(n.nextSub=t)),t.dep.subs=t}}const zl=new WeakMap,Wo=Symbol(""),Gl=Symbol(""),Ka=Symbol("");function Nn(t,e,n){if(qr&&St){let r=zl.get(t);r||zl.set(t,r=new Map);let s=r.get(n);s||(r.set(n,s=new rf),s.map=r,s.key=n),s.track()}}function Rs(t,e,n,r,s,o){const i=zl.get(t);if(!i){Ha++;return}const a=u=>{u&&u.trigger()};if(ef(),e==="clear")i.forEach(a);else{const u=Ge(t),c=u&&Qh(n);if(u&&n==="length"){const l=Number(r);i.forEach((h,f)=>{(f==="length"||f===Ka||!ea(f)&&f>=l)&&a(h)})}else switch((n!==void 0||i.has(void 0))&&a(i.get(n)),c&&a(i.get(Ka)),e){case"add":u?c&&a(i.get("length")):(a(i.get(Wo)),Da(t)&&a(i.get(Gl)));break;case"delete":u||(a(i.get(Wo)),Da(t)&&a(i.get(Gl)));break;case"set":Da(t)&&a(i.get(Wo));break}}tf()}function Ei(t){const e=at(t);return e===t?e:(Nn(e,"iterate",Ka),Xr(t)?e:e.map(Wn))}function sf(t){return Nn(t=at(t),"iterate",Ka),t}const jw={__proto__:null,[Symbol.iterator](){return dl(this,Symbol.iterator,Wn)},concat(...t){return Ei(this).concat(...t.map(e=>Ge(e)?Ei(e):e))},entries(){return dl(this,"entries",t=>(t[1]=Wn(t[1]),t))},every(t,e){return Ts(this,"every",t,e,void 0,arguments)},filter(t,e){return Ts(this,"filter",t,e,n=>n.map(Wn),arguments)},find(t,e){return Ts(this,"find",t,e,Wn,arguments)},findIndex(t,e){return Ts(this,"findIndex",t,e,void 0,arguments)},findLast(t,e){return Ts(this,"findLast",t,e,Wn,arguments)},findLastIndex(t,e){return Ts(this,"findLastIndex",t,e,void 0,arguments)},forEach(t,e){return Ts(this,"forEach",t,e,void 0,arguments)},includes(...t){return pl(this,"includes",t)},indexOf(...t){return pl(this,"indexOf",t)},join(t){return Ei(this).join(t)},lastIndexOf(...t){return pl(this,"lastIndexOf",t)},map(t,e){return Ts(this,"map",t,e,void 0,arguments)},pop(){return Sa(this,"pop")},push(...t){return Sa(this,"push",t)},reduce(t,...e){return xd(this,"reduce",t,e)},reduceRight(t,...e){return xd(this,"reduceRight",t,e)},shift(){return Sa(this,"shift")},some(t,e){return Ts(this,"some",t,e,void 0,arguments)},splice(...t){return Sa(this,"splice",t)},toReversed(){return Ei(this).toReversed()},toSorted(t){return Ei(this).toSorted(t)},toSpliced(...t){return Ei(this).toSpliced(...t)},unshift(...t){return Sa(this,"unshift",t)},values(){return dl(this,"values",Wn)}};function dl(t,e,n){const r=sf(t),s=r[e]();return r!==t&&!Xr(t)&&(s._next=s.next,s.next=()=>{const o=s._next();return o.value&&(o.value=n(o.value)),o}),s}const Hw=Array.prototype;function Ts(t,e,n,r,s,o){const i=sf(t),a=i!==t&&!Xr(t),u=i[e];if(u!==Hw[e]){const h=u.apply(t,o);return a?Wn(h):h}let c=n;i!==t&&(a?c=function(h,f){return n.call(this,Wn(h),f,t)}:n.length>2&&(c=function(h,f){return n.call(this,h,f,t)}));const l=u.call(i,c,r);return a&&s?s(l):l}function xd(t,e,n,r){const s=sf(t);let o=n;return s!==t&&(Xr(t)?n.length>3&&(o=function(i,a,u){return n.call(this,i,a,u,t)}):o=function(i,a,u){return n.call(this,i,Wn(a),u,t)}),s[e](o,...r)}function pl(t,e,n){const r=at(t);Nn(r,"iterate",Ka);const s=r[e](...n);return(s===-1||s===!1)&&uf(n[0])?(n[0]=at(n[0]),r[e](...n)):s}function Sa(t,e,n=[]){go(),ef();const r=at(t)[e].apply(t,n);return tf(),yo(),r}const Kw=qh("__proto__,__v_isRef,__isVue"),Dm=new Set(Object.getOwnPropertyNames(Symbol).filter(t=>t!=="arguments"&&t!=="caller").map(t=>Symbol[t]).filter(ea));function qw(t){ea(t)||(t=String(t));const e=at(this);return Nn(e,"has",t),e.hasOwnProperty(t)}class Pm{constructor(e=!1,n=!1){this._isReadonly=e,this._isShallow=n}get(e,n,r){const s=this._isReadonly,o=this._isShallow;if(n==="__v_isReactive")return!s;if(n==="__v_isReadonly")return s;if(n==="__v_isShallow")return o;if(n==="__v_raw")return r===(s?o?sS:Mm:o?Bm:Lm).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(r)?e:void 0;const i=Ge(e);if(!s){let u;if(i&&(u=jw[n]))return u;if(n==="hasOwnProperty")return qw}const a=Reflect.get(e,n,Rn(e)?e:r);return(ea(n)?Dm.has(n):Kw(n))||(s||Nn(e,"get",n),o)?a:Rn(a)?i&&Qh(n)?a:a.value:qt(a)?s?Um(a):Rc(a):a}}class Fm extends Pm{constructor(e=!1){super(!1,e)}set(e,n,r,s){let o=e[n];if(!this._isShallow){const u=Ko(o);if(!Xr(r)&&!Ko(r)&&(o=at(o),r=at(r)),!Ge(e)&&Rn(o)&&!Rn(r))return u?!1:(o.value=r,!0)}const i=Ge(e)&&Qh(n)?Number(n)<e.length:ut(e,n),a=Reflect.set(e,n,r,Rn(e)?e:s);return e===at(s)&&(i?ao(r,o)&&Rs(e,"set",n,r):Rs(e,"add",n,r)),a}deleteProperty(e,n){const r=ut(e,n);e[n];const s=Reflect.deleteProperty(e,n);return s&&r&&Rs(e,"delete",n,void 0),s}has(e,n){const r=Reflect.has(e,n);return(!ea(n)||!Dm.has(n))&&Nn(e,"has",n),r}ownKeys(e){return Nn(e,"iterate",Ge(e)?"length":Wo),Reflect.ownKeys(e)}}class Xw extends Pm{constructor(e=!1){super(!0,e)}set(e,n){return!0}deleteProperty(e,n){return!0}}const Yw=new Fm,Qw=new Xw,Zw=new Fm(!0);const jl=t=>t,Iu=t=>Reflect.getPrototypeOf(t);function Jw(t,e,n){return function(...r){const s=this.__v_raw,o=at(s),i=Da(o),a=t==="entries"||t===Symbol.iterator&&i,u=t==="keys"&&i,c=s[t](...r),l=n?jl:e?Hl:Wn;return!e&&Nn(o,"iterate",u?Gl:Wo),{next(){const{value:h,done:f}=c.next();return f?{value:h,done:f}:{value:a?[l(h[0]),l(h[1])]:l(h),done:f}},[Symbol.iterator](){return this}}}}function ku(t){return function(...e){return t==="delete"?!1:t==="clear"?void 0:this}}function eS(t,e){const n={get(s){const o=this.__v_raw,i=at(o),a=at(s);t||(ao(s,a)&&Nn(i,"get",s),Nn(i,"get",a));const{has:u}=Iu(i),c=e?jl:t?Hl:Wn;if(u.call(i,s))return c(o.get(s));if(u.call(i,a))return c(o.get(a));o!==i&&o.get(s)},get size(){const s=this.__v_raw;return!t&&Nn(at(s),"iterate",Wo),Reflect.get(s,"size",s)},has(s){const o=this.__v_raw,i=at(o),a=at(s);return t||(ao(s,a)&&Nn(i,"has",s),Nn(i,"has",a)),s===a?o.has(s):o.has(s)||o.has(a)},forEach(s,o){const i=this,a=i.__v_raw,u=at(a),c=e?jl:t?Hl:Wn;return!t&&Nn(u,"iterate",Wo),a.forEach((l,h)=>s.call(o,c(l),c(h),i))}};return cn(n,t?{add:ku("add"),set:ku("set"),delete:ku("delete"),clear:ku("clear")}:{add(s){!e&&!Xr(s)&&!Ko(s)&&(s=at(s));const o=at(this);return Iu(o).has.call(o,s)||(o.add(s),Rs(o,"add",s,s)),this},set(s,o){!e&&!Xr(o)&&!Ko(o)&&(o=at(o));const i=at(this),{has:a,get:u}=Iu(i);let c=a.call(i,s);c||(s=at(s),c=a.call(i,s));const l=u.call(i,s);return i.set(s,o),c?ao(o,l)&&Rs(i,"set",s,o):Rs(i,"add",s,o),this},delete(s){const o=at(this),{has:i,get:a}=Iu(o);let u=i.call(o,s);u||(s=at(s),u=i.call(o,s)),a&&a.call(o,s);const c=o.delete(s);return u&&Rs(o,"delete",s,void 0),c},clear(){const s=at(this),o=s.size!==0,i=s.clear();return o&&Rs(s,"clear",void 0,void 0),i}}),["keys","values","entries",Symbol.iterator].forEach(s=>{n[s]=Jw(s,t,e)}),n}function of(t,e){const n=eS(t,e);return(r,s,o)=>s==="__v_isReactive"?!t:s==="__v_isReadonly"?t:s==="__v_raw"?r:Reflect.get(ut(n,s)&&s in r?n:r,s,o)}const tS={get:of(!1,!1)},nS={get:of(!1,!0)},rS={get:of(!0,!1)};const Lm=new WeakMap,Bm=new WeakMap,Mm=new WeakMap,sS=new WeakMap;function oS(t){switch(t){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function iS(t){return t.__v_skip||!Object.isExtensible(t)?0:oS(kw(t))}function Rc(t){return Ko(t)?t:af(t,!1,Yw,tS,Lm)}function Vm(t){return af(t,!1,Zw,nS,Bm)}function Um(t){return af(t,!0,Qw,rS,Mm)}function af(t,e,n,r,s){if(!qt(t)||t.__v_raw&&!(e&&t.__v_isReactive))return t;const o=s.get(t);if(o)return o;const i=iS(t);if(i===0)return t;const a=new Proxy(t,i===2?r:n);return s.set(t,a),a}function Ba(t){return Ko(t)?Ba(t.__v_raw):!!(t&&t.__v_isReactive)}function Ko(t){return!!(t&&t.__v_isReadonly)}function Xr(t){return!!(t&&t.__v_isShallow)}function uf(t){return t?!!t.__v_raw:!1}function at(t){const e=t&&t.__v_raw;return e?at(e):t}function aS(t){return!ut(t,"__v_skip")&&Object.isExtensible(t)&&$m(t,"__v_skip",!0),t}const Wn=t=>qt(t)?Rc(t):t,Hl=t=>qt(t)?Um(t):t;function Rn(t){return t?t.__v_isRef===!0:!1}function Kl(t){return Wm(t,!1)}function uS(t){return Wm(t,!0)}function Wm(t,e){return Rn(t)?t:new cS(t,e)}class cS{constructor(e,n){this.dep=new rf,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?e:at(e),this._value=n?e:Wn(e),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(e){const n=this._rawValue,r=this.__v_isShallow||Xr(e)||Ko(e);e=r?e:at(e),ao(e,n)&&(this._rawValue=e,this._value=r?e:Wn(e),this.dep.trigger())}}function zo(t){return Rn(t)?t.value:t}const lS={get:(t,e,n)=>e==="__v_raw"?t:zo(Reflect.get(t,e,n)),set:(t,e,n,r)=>{const s=t[e];return Rn(s)&&!Rn(n)?(s.value=n,!0):Reflect.set(t,e,n,r)}};function zm(t){return Ba(t)?t:new Proxy(t,lS)}class hS{constructor(e,n,r){this.fn=e,this.setter=n,this._value=void 0,this.dep=new rf(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Ha-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=r}notify(){if(this.flags|=16,!(this.flags&8)&&St!==this)return _m(this,!0),!0}get value(){const e=this.dep.track();return Rm(this),e&&(e.version=this.dep.version),this._value}set value(e){this.setter&&this.setter(e)}}function fS(t,e,n=!1){let r,s;return Ue(t)?r=t:(r=t.get,s=t.set),new hS(r,s,n)}const Ru={},Zu=new WeakMap;let Oo;function dS(t,e=!1,n=Oo){if(n){let r=Zu.get(n);r||Zu.set(n,r=[]),r.push(t)}}function pS(t,e,n=bt){const{immediate:r,deep:s,once:o,scheduler:i,augmentJob:a,call:u}=n,c=C=>s?C:Xr(C)||s===!1||s===0?As(C,1):As(C);let l,h,f,d,m=!1,x=!1;if(Rn(t)?(h=()=>t.value,m=Xr(t)):Ba(t)?(h=()=>c(t),m=!0):Ge(t)?(x=!0,m=t.some(C=>Ba(C)||Xr(C)),h=()=>t.map(C=>{if(Rn(C))return C.value;if(Ba(C))return c(C);if(Ue(C))return u?u(C,2):C()})):Ue(t)?e?h=u?()=>u(t,2):t:h=()=>{if(f){go();try{f()}finally{yo()}}const C=Oo;Oo=l;try{return u?u(t,3,[d]):t(d)}finally{Oo=C}}:h=ps,e&&s){const C=h,_=s===!0?1/0:s;h=()=>As(C(),_)}const g=Ww(),y=()=>{l.stop(),g&&Yh(g.effects,l)};if(o&&e){const C=e;e=(..._)=>{C(..._),y()}}let S=x?new Array(t.length).fill(Ru):Ru;const $=C=>{if(!(!(l.flags&1)||!l.dirty&&!C))if(e){const _=l.run();if(s||m||(x?_.some((L,V)=>ao(L,S[V])):ao(_,S))){f&&f();const L=Oo;Oo=l;try{const V=[_,S===Ru?void 0:x&&S[0]===Ru?[]:S,d];u?u(e,3,V):e(...V),S=_}finally{Oo=L}}}else l.run()};return a&&a($),l=new Nm(h),l.scheduler=i?()=>i($,!1):$,d=C=>dS(C,!1,l),f=l.onStop=()=>{const C=Zu.get(l);if(C){if(u)u(C,4);else for(const _ of C)_();Zu.delete(l)}},e?r?$(!0):S=l.run():i?i($.bind(null,!0),!0):l.run(),y.pause=l.pause.bind(l),y.resume=l.resume.bind(l),y.stop=y,y}function As(t,e=1/0,n){if(e<=0||!qt(t)||t.__v_skip||(n=n||new Set,n.has(t)))return t;if(n.add(t),e--,Rn(t))As(t.value,e,n);else if(Ge(t))for(let r=0;r<t.length;r++)As(t[r],e,n);else if(_w(t)||Da(t))t.forEach(r=>{As(r,e,n)});else if(Rw(t)){for(const r in t)As(t[r],e,n);for(const r of Object.getOwnPropertySymbols(t))Object.prototype.propertyIsEnumerable.call(t,r)&&As(t[r],e,n)}return t}/**
* @vue/runtime-core v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function fu(t,e,n,r){try{return r?t(...r):t()}catch(s){Ac(s,e,n)}}function ys(t,e,n,r){if(Ue(t)){const s=fu(t,e,n,r);return s&&Cm(s)&&s.catch(o=>{Ac(o,e,n)}),s}if(Ge(t)){const s=[];for(let o=0;o<t.length;o++)s.push(ys(t[o],e,n,r));return s}}function Ac(t,e,n,r=!0){const s=e?e.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:i}=e&&e.appContext.config||bt;if(e){let a=e.parent;const u=e.proxy,c=`https://vuejs.org/error-reference/#runtime-${n}`;for(;a;){const l=a.ec;if(l){for(let h=0;h<l.length;h++)if(l[h](t,u,c)===!1)return}a=a.parent}if(o){go(),fu(o,null,10,[t,u,c]),yo();return}}mS(t,n,s,r,i)}function mS(t,e,n,r=!0,s=!1){if(s)throw t;console.error(t)}const zn=[];let cs=-1;const Fi=[];let to=null,Ii=0;const Gm=Promise.resolve();let Ju=null;function jm(t){const e=Ju||Gm;return t?e.then(this?t.bind(this):t):e}function gS(t){let e=cs+1,n=zn.length;for(;e<n;){const r=e+n>>>1,s=zn[r],o=qa(s);o<t||o===t&&s.flags&2?e=r+1:n=r}return e}function cf(t){if(!(t.flags&1)){const e=qa(t),n=zn[zn.length-1];!n||!(t.flags&2)&&e>=qa(n)?zn.push(t):zn.splice(gS(e),0,t),t.flags|=1,Hm()}}function Hm(){Ju||(Ju=Gm.then(qm))}function yS(t){Ge(t)?Fi.push(...t):to&&t.id===-1?to.splice(Ii+1,0,t):t.flags&1||(Fi.push(t),t.flags|=1),Hm()}function bd(t,e,n=cs+1){for(;n<zn.length;n++){const r=zn[n];if(r&&r.flags&2){if(t&&r.id!==t.uid)continue;zn.splice(n,1),n--,r.flags&4&&(r.flags&=-2),r(),r.flags&4||(r.flags&=-2)}}}function Km(t){if(Fi.length){const e=[...new Set(Fi)].sort((n,r)=>qa(n)-qa(r));if(Fi.length=0,to){to.push(...e);return}for(to=e,Ii=0;Ii<to.length;Ii++){const n=to[Ii];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}to=null,Ii=0}}const qa=t=>t.id==null?t.flags&2?-1:1/0:t.id;function qm(t){try{for(cs=0;cs<zn.length;cs++){const e=zn[cs];e&&!(e.flags&8)&&(e.flags&4&&(e.flags&=-2),fu(e,e.i,e.i?15:14),e.flags&4||(e.flags&=-2))}}finally{for(;cs<zn.length;cs++){const e=zn[cs];e&&(e.flags&=-2)}cs=-1,zn.length=0,Km(),Ju=null,(zn.length||Fi.length)&&qm()}}let dr=null,Xm=null;function ec(t){const e=dr;return dr=t,Xm=t&&t.type.__scopeId||null,e}function xS(t,e=dr,n){if(!e||t._n)return t;const r=(...s)=>{r._d&&_d(-1);const o=ec(e);let i;try{i=t(...s)}finally{ec(o),r._d&&_d(1)}return i};return r._n=!0,r._c=!0,r._d=!0,r}function Ym(t,e){if(dr===null)return t;const n=Bc(dr),r=t.dirs||(t.dirs=[]);for(let s=0;s<e.length;s++){let[o,i,a,u=bt]=e[s];o&&(Ue(o)&&(o={mounted:o,updated:o}),o.deep&&As(i),r.push({dir:o,instance:n,value:i,oldValue:void 0,arg:a,modifiers:u}))}return t}function Io(t,e,n,r){const s=t.dirs,o=e&&e.dirs;for(let i=0;i<s.length;i++){const a=s[i];o&&(a.oldValue=o[i].value);let u=a.dir[r];u&&(go(),ys(u,n,8,[t.el,a,t,e]),yo())}}const bS=Symbol("_vte"),vS=t=>t.__isTeleport;function lf(t,e){t.shapeFlag&6&&t.component?(t.transition=e,lf(t.component.subTree,e)):t.shapeFlag&128?(t.ssContent.transition=e.clone(t.ssContent),t.ssFallback.transition=e.clone(t.ssFallback)):t.transition=e}/*! #__NO_SIDE_EFFECTS__ */function Qm(t,e){return Ue(t)?cn({name:t.name},e,{setup:t}):t}function Zm(t){t.ids=[t.ids[0]+t.ids[2]+++"-",0,0]}function ql(t,e,n,r,s=!1){if(Ge(t)){t.forEach((m,x)=>ql(m,e&&(Ge(e)?e[x]:e),n,r,s));return}if(Ma(r)&&!s)return;const o=r.shapeFlag&4?Bc(r.component):r.el,i=s?null:o,{i:a,r:u}=t,c=e&&e.r,l=a.refs===bt?a.refs={}:a.refs,h=a.setupState,f=at(h),d=h===bt?()=>!1:m=>ut(f,m);if(c!=null&&c!==u&&(ln(c)?(l[c]=null,d(c)&&(h[c]=null)):Rn(c)&&(c.value=null)),Ue(u))fu(u,a,12,[i,l]);else{const m=ln(u),x=Rn(u);if(m||x){const g=()=>{if(t.f){const y=m?d(u)?h[u]:l[u]:u.value;s?Ge(y)&&Yh(y,o):Ge(y)?y.includes(o)||y.push(o):m?(l[u]=[o],d(u)&&(h[u]=l[u])):(u.value=[o],t.k&&(l[t.k]=u.value))}else m?(l[u]=i,d(u)&&(h[u]=i)):x&&(u.value=i,t.k&&(l[t.k]=i))};i?(g.id=-1,lr(g,n)):g()}}}kc().requestIdleCallback;kc().cancelIdleCallback;const Ma=t=>!!t.type.__asyncLoader,Jm=t=>t.type.__isKeepAlive;function wS(t,e){eg(t,"a",e)}function SS(t,e){eg(t,"da",e)}function eg(t,e,n=In){const r=t.__wdc||(t.__wdc=()=>{let s=n;for(;s;){if(s.isDeactivated)return;s=s.parent}return t()});if(Oc(e,r,n),n){let s=n.parent;for(;s&&s.parent;)Jm(s.parent.vnode)&&CS(r,e,n,s),s=s.parent}}function CS(t,e,n,r){const s=Oc(e,t,r,!0);tg(()=>{Yh(r[e],s)},n)}function Oc(t,e,n=In,r=!1){if(n){const s=n[t]||(n[t]=[]),o=e.__weh||(e.__weh=(...i)=>{go();const a=pu(n),u=ys(e,n,t,i);return a(),yo(),u});return r?s.unshift(o):s.push(o),o}}const Ms=t=>(e,n=In)=>{(!Qa||t==="sp")&&Oc(t,(...r)=>e(...r),n)},$S=Ms("bm"),Dc=Ms("m"),TS=Ms("bu"),NS=Ms("u"),ES=Ms("bum"),tg=Ms("um"),_S=Ms("sp"),IS=Ms("rtg"),kS=Ms("rtc");function RS(t,e=In){Oc("ec",t,e)}const AS="components";function OS(t,e){return PS(AS,t,!0,e)||t}const DS=Symbol.for("v-ndc");function PS(t,e,n=!0,r=!1){const s=dr||In;if(s){const o=s.type;{const a=CC(o,!1);if(a&&(a===e||a===Ar(e)||a===Ic(Ar(e))))return o}const i=vd(s[t]||o[t],e)||vd(s.appContext[t],e);return!i&&r?o:i}}function vd(t,e){return t&&(t[e]||t[Ar(e)]||t[Ic(Ar(e))])}const Xl=t=>t?wg(t)?Bc(t):Xl(t.parent):null,Va=cn(Object.create(null),{$:t=>t,$el:t=>t.vnode.el,$data:t=>t.data,$props:t=>t.props,$attrs:t=>t.attrs,$slots:t=>t.slots,$refs:t=>t.refs,$parent:t=>Xl(t.parent),$root:t=>Xl(t.root),$host:t=>t.ce,$emit:t=>t.emit,$options:t=>hf(t),$forceUpdate:t=>t.f||(t.f=()=>{cf(t.update)}),$nextTick:t=>t.n||(t.n=jm.bind(t.proxy)),$watch:t=>nC.bind(t)}),ml=(t,e)=>t!==bt&&!t.__isScriptSetup&&ut(t,e),FS={get({_:t},e){if(e==="__v_skip")return!0;const{ctx:n,setupState:r,data:s,props:o,accessCache:i,type:a,appContext:u}=t;let c;if(e[0]!=="$"){const d=i[e];if(d!==void 0)switch(d){case 1:return r[e];case 2:return s[e];case 4:return n[e];case 3:return o[e]}else{if(ml(r,e))return i[e]=1,r[e];if(s!==bt&&ut(s,e))return i[e]=2,s[e];if((c=t.propsOptions[0])&&ut(c,e))return i[e]=3,o[e];if(n!==bt&&ut(n,e))return i[e]=4,n[e];Yl&&(i[e]=0)}}const l=Va[e];let h,f;if(l)return e==="$attrs"&&Nn(t.attrs,"get",""),l(t);if((h=a.__cssModules)&&(h=h[e]))return h;if(n!==bt&&ut(n,e))return i[e]=4,n[e];if(f=u.config.globalProperties,ut(f,e))return f[e]},set({_:t},e,n){const{data:r,setupState:s,ctx:o}=t;return ml(s,e)?(s[e]=n,!0):r!==bt&&ut(r,e)?(r[e]=n,!0):ut(t.props,e)||e[0]==="$"&&e.slice(1)in t?!1:(o[e]=n,!0)},has({_:{data:t,setupState:e,accessCache:n,ctx:r,appContext:s,propsOptions:o}},i){let a;return!!n[i]||t!==bt&&ut(t,i)||ml(e,i)||(a=o[0])&&ut(a,i)||ut(r,i)||ut(Va,i)||ut(s.config.globalProperties,i)},defineProperty(t,e,n){return n.get!=null?t._.accessCache[e]=0:ut(n,"value")&&this.set(t,e,n.value,null),Reflect.defineProperty(t,e,n)}};function wd(t){return Ge(t)?t.reduce((e,n)=>(e[n]=null,e),{}):t}let Yl=!0;function LS(t){const e=hf(t),n=t.proxy,r=t.ctx;Yl=!1,e.beforeCreate&&Sd(e.beforeCreate,t,"bc");const{data:s,computed:o,methods:i,watch:a,provide:u,inject:c,created:l,beforeMount:h,mounted:f,beforeUpdate:d,updated:m,activated:x,deactivated:g,beforeDestroy:y,beforeUnmount:S,destroyed:$,unmounted:C,render:_,renderTracked:L,renderTriggered:V,errorCaptured:z,serverPrefetch:K,expose:q,inheritAttrs:Z,components:fe,directives:xe,filters:$e}=e;if(c&&BS(c,r,null),i)for(const Ee in i){const Ie=i[Ee];Ue(Ie)&&(r[Ee]=Ie.bind(n))}if(s){const Ee=s.call(n,n);qt(Ee)&&(t.data=Rc(Ee))}if(Yl=!0,o)for(const Ee in o){const Ie=o[Ee],Je=Ue(Ie)?Ie.bind(n,n):Ue(Ie.get)?Ie.get.bind(n,n):ps,Lt=!Ue(Ie)&&Ue(Ie.set)?Ie.set.bind(n):ps,Bt=jr({get:Je,set:Lt});Object.defineProperty(r,Ee,{enumerable:!0,configurable:!0,get:()=>Bt.value,set:vt=>Bt.value=vt})}if(a)for(const Ee in a)ng(a[Ee],r,n,Ee);if(u){const Ee=Ue(u)?u.call(n):u;Reflect.ownKeys(Ee).forEach(Ie=>{Gu(Ie,Ee[Ie])})}l&&Sd(l,t,"c");function ke(Ee,Ie){Ge(Ie)?Ie.forEach(Je=>Ee(Je.bind(n))):Ie&&Ee(Ie.bind(n))}if(ke($S,h),ke(Dc,f),ke(TS,d),ke(NS,m),ke(wS,x),ke(SS,g),ke(RS,z),ke(kS,L),ke(IS,V),ke(ES,S),ke(tg,C),ke(_S,K),Ge(q))if(q.length){const Ee=t.exposed||(t.exposed={});q.forEach(Ie=>{Object.defineProperty(Ee,Ie,{get:()=>n[Ie],set:Je=>n[Ie]=Je})})}else t.exposed||(t.exposed={});_&&t.render===ps&&(t.render=_),Z!=null&&(t.inheritAttrs=Z),fe&&(t.components=fe),xe&&(t.directives=xe),K&&Zm(t)}function BS(t,e,n=ps){Ge(t)&&(t=Ql(t));for(const r in t){const s=t[r];let o;qt(s)?"default"in s?o=Ds(s.from||r,s.default,!0):o=Ds(s.from||r):o=Ds(s),Rn(o)?Object.defineProperty(e,r,{enumerable:!0,configurable:!0,get:()=>o.value,set:i=>o.value=i}):e[r]=o}}function Sd(t,e,n){ys(Ge(t)?t.map(r=>r.bind(e.proxy)):t.bind(e.proxy),e,n)}function ng(t,e,n,r){let s=r.includes(".")?gg(n,r):()=>n[r];if(ln(t)){const o=e[t];Ue(o)&&Bi(s,o)}else if(Ue(t))Bi(s,t.bind(n));else if(qt(t))if(Ge(t))t.forEach(o=>ng(o,e,n,r));else{const o=Ue(t.handler)?t.handler.bind(n):e[t.handler];Ue(o)&&Bi(s,o,t)}}function hf(t){const e=t.type,{mixins:n,extends:r}=e,{mixins:s,optionsCache:o,config:{optionMergeStrategies:i}}=t.appContext,a=o.get(e);let u;return a?u=a:!s.length&&!n&&!r?u=e:(u={},s.length&&s.forEach(c=>tc(u,c,i,!0)),tc(u,e,i)),qt(e)&&o.set(e,u),u}function tc(t,e,n,r=!1){const{mixins:s,extends:o}=e;o&&tc(t,o,n,!0),s&&s.forEach(i=>tc(t,i,n,!0));for(const i in e)if(!(r&&i==="expose")){const a=MS[i]||n&&n[i];t[i]=a?a(t[i],e[i]):e[i]}return t}const MS={data:Cd,props:$d,emits:$d,methods:Ia,computed:Ia,beforeCreate:Un,created:Un,beforeMount:Un,mounted:Un,beforeUpdate:Un,updated:Un,beforeDestroy:Un,beforeUnmount:Un,destroyed:Un,unmounted:Un,activated:Un,deactivated:Un,errorCaptured:Un,serverPrefetch:Un,components:Ia,directives:Ia,watch:US,provide:Cd,inject:VS};function Cd(t,e){return e?t?function(){return cn(Ue(t)?t.call(this,this):t,Ue(e)?e.call(this,this):e)}:e:t}function VS(t,e){return Ia(Ql(t),Ql(e))}function Ql(t){if(Ge(t)){const e={};for(let n=0;n<t.length;n++)e[t[n]]=t[n];return e}return t}function Un(t,e){return t?[...new Set([].concat(t,e))]:e}function Ia(t,e){return t?cn(Object.create(null),t,e):e}function $d(t,e){return t?Ge(t)&&Ge(e)?[...new Set([...t,...e])]:cn(Object.create(null),wd(t),wd(e??{})):e}function US(t,e){if(!t)return e;if(!e)return t;const n=cn(Object.create(null),t);for(const r in e)n[r]=Un(t[r],e[r]);return n}function rg(){return{app:null,config:{isNativeTag:Nw,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let WS=0;function zS(t,e){return function(r,s=null){Ue(r)||(r=cn({},r)),s!=null&&!qt(s)&&(s=null);const o=rg(),i=new WeakSet,a=[];let u=!1;const c=o.app={_uid:WS++,_component:r,_props:s,_container:null,_context:o,_instance:null,version:TC,get config(){return o.config},set config(l){},use(l,...h){return i.has(l)||(l&&Ue(l.install)?(i.add(l),l.install(c,...h)):Ue(l)&&(i.add(l),l(c,...h))),c},mixin(l){return o.mixins.includes(l)||o.mixins.push(l),c},component(l,h){return h?(o.components[l]=h,c):o.components[l]},directive(l,h){return h?(o.directives[l]=h,c):o.directives[l]},mount(l,h,f){if(!u){const d=c._ceVNode||jn(r,s);return d.appContext=o,f===!0?f="svg":f===!1&&(f=void 0),h&&e?e(d,l):t(d,l,f),u=!0,c._container=l,l.__vue_app__=c,Bc(d.component)}},onUnmount(l){a.push(l)},unmount(){u&&(ys(a,c._instance,16),t(null,c._container),delete c._container.__vue_app__)},provide(l,h){return o.provides[l]=h,c},runWithContext(l){const h=Li;Li=c;try{return l()}finally{Li=h}}};return c}}let Li=null;function Gu(t,e){if(In){let n=In.provides;const r=In.parent&&In.parent.provides;r===n&&(n=In.provides=Object.create(r)),n[t]=e}}function Ds(t,e,n=!1){const r=In||dr;if(r||Li){const s=Li?Li._context.provides:r?r.parent==null?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides:void 0;if(s&&t in s)return s[t];if(arguments.length>1)return n&&Ue(e)?e.call(r&&r.proxy):e}}const sg={},og=()=>Object.create(sg),ig=t=>Object.getPrototypeOf(t)===sg;function GS(t,e,n,r=!1){const s={},o=og();t.propsDefaults=Object.create(null),ag(t,e,s,o);for(const i in t.propsOptions[0])i in s||(s[i]=void 0);n?t.props=r?s:Vm(s):t.type.props?t.props=s:t.props=o,t.attrs=o}function jS(t,e,n,r){const{props:s,attrs:o,vnode:{patchFlag:i}}=t,a=at(s),[u]=t.propsOptions;let c=!1;if((r||i>0)&&!(i&16)){if(i&8){const l=t.vnode.dynamicProps;for(let h=0;h<l.length;h++){let f=l[h];if(Pc(t.emitsOptions,f))continue;const d=e[f];if(u)if(ut(o,f))d!==o[f]&&(o[f]=d,c=!0);else{const m=Ar(f);s[m]=Zl(u,a,m,d,t,!1)}else d!==o[f]&&(o[f]=d,c=!0)}}}else{ag(t,e,s,o)&&(c=!0);let l;for(const h in a)(!e||!ut(e,h)&&((l=ii(h))===h||!ut(e,l)))&&(u?n&&(n[h]!==void 0||n[l]!==void 0)&&(s[h]=Zl(u,a,h,void 0,t,!0)):delete s[h]);if(o!==a)for(const h in o)(!e||!ut(e,h))&&(delete o[h],c=!0)}c&&Rs(t.attrs,"set","")}function ag(t,e,n,r){const[s,o]=t.propsOptions;let i=!1,a;if(e)for(let u in e){if(Pa(u))continue;const c=e[u];let l;s&&ut(s,l=Ar(u))?!o||!o.includes(l)?n[l]=c:(a||(a={}))[l]=c:Pc(t.emitsOptions,u)||(!(u in r)||c!==r[u])&&(r[u]=c,i=!0)}if(o){const u=at(n),c=a||bt;for(let l=0;l<o.length;l++){const h=o[l];n[h]=Zl(s,u,h,c[h],t,!ut(c,h))}}return i}function Zl(t,e,n,r,s,o){const i=t[n];if(i!=null){const a=ut(i,"default");if(a&&r===void 0){const u=i.default;if(i.type!==Function&&!i.skipFactory&&Ue(u)){const{propsDefaults:c}=s;if(n in c)r=c[n];else{const l=pu(s);r=c[n]=u.call(null,e),l()}}else r=u;s.ce&&s.ce._setProp(n,r)}i[0]&&(o&&!a?r=!1:i[1]&&(r===""||r===ii(n))&&(r=!0))}return r}const HS=new WeakMap;function ug(t,e,n=!1){const r=n?HS:e.propsCache,s=r.get(t);if(s)return s;const o=t.props,i={},a=[];let u=!1;if(!Ue(t)){const l=h=>{u=!0;const[f,d]=ug(h,e,!0);cn(i,f),d&&a.push(...d)};!n&&e.mixins.length&&e.mixins.forEach(l),t.extends&&l(t.extends),t.mixins&&t.mixins.forEach(l)}if(!o&&!u)return qt(t)&&r.set(t,Pi),Pi;if(Ge(o))for(let l=0;l<o.length;l++){const h=Ar(o[l]);Td(h)&&(i[h]=bt)}else if(o)for(const l in o){const h=Ar(l);if(Td(h)){const f=o[l],d=i[h]=Ge(f)||Ue(f)?{type:f}:cn({},f),m=d.type;let x=!1,g=!0;if(Ge(m))for(let y=0;y<m.length;++y){const S=m[y],$=Ue(S)&&S.name;if($==="Boolean"){x=!0;break}else $==="String"&&(g=!1)}else x=Ue(m)&&m.name==="Boolean";d[0]=x,d[1]=g,(x||ut(d,"default"))&&a.push(h)}}const c=[i,a];return qt(t)&&r.set(t,c),c}function Td(t){return t[0]!=="$"&&!Pa(t)}const cg=t=>t[0]==="_"||t==="$stable",ff=t=>Ge(t)?t.map(ls):[ls(t)],KS=(t,e,n)=>{if(e._n)return e;const r=xS((...s)=>ff(e(...s)),n);return r._c=!1,r},lg=(t,e,n)=>{const r=t._ctx;for(const s in t){if(cg(s))continue;const o=t[s];if(Ue(o))e[s]=KS(s,o,r);else if(o!=null){const i=ff(o);e[s]=()=>i}}},hg=(t,e)=>{const n=ff(e);t.slots.default=()=>n},fg=(t,e,n)=>{for(const r in e)(n||r!=="_")&&(t[r]=e[r])},qS=(t,e,n)=>{const r=t.slots=og();if(t.vnode.shapeFlag&32){const s=e._;s?(fg(r,e,n),n&&$m(r,"_",s,!0)):lg(e,r)}else e&&hg(t,e)},XS=(t,e,n)=>{const{vnode:r,slots:s}=t;let o=!0,i=bt;if(r.shapeFlag&32){const a=e._;a?n&&a===1?o=!1:fg(s,e,n):(o=!e.$stable,lg(e,s)),i=e}else e&&(hg(t,e),i={default:1});if(o)for(const a in s)!cg(a)&&i[a]==null&&delete s[a]},lr=cC;function YS(t){return QS(t)}function QS(t,e){const n=kc();n.__VUE__=!0;const{insert:r,remove:s,patchProp:o,createElement:i,createText:a,createComment:u,setText:c,setElementText:l,parentNode:h,nextSibling:f,setScopeId:d=ps,insertStaticContent:m}=t,x=(k,D,H,ne=null,J=null,re=null,de=void 0,le=null,ue=!!D.dynamicChildren)=>{if(k===D)return;k&&!Ca(k,D)&&(ne=Q(k),vt(k,J,re,!0),k=null),D.patchFlag===-2&&(ue=!1,D.dynamicChildren=null);const{type:se,ref:Oe,shapeFlag:ce}=D;switch(se){case Fc:g(k,D,H,ne);break;case Xa:y(k,D,H,ne);break;case xl:k==null&&S(D,H,ne,de);break;case _s:fe(k,D,H,ne,J,re,de,le,ue);break;default:ce&1?_(k,D,H,ne,J,re,de,le,ue):ce&6?xe(k,D,H,ne,J,re,de,le,ue):(ce&64||ce&128)&&se.process(k,D,H,ne,J,re,de,le,ue,Se)}Oe!=null&&J&&ql(Oe,k&&k.ref,re,D||k,!D)},g=(k,D,H,ne)=>{if(k==null)r(D.el=a(D.children),H,ne);else{const J=D.el=k.el;D.children!==k.children&&c(J,D.children)}},y=(k,D,H,ne)=>{k==null?r(D.el=u(D.children||""),H,ne):D.el=k.el},S=(k,D,H,ne)=>{[k.el,k.anchor]=m(k.children,D,H,ne,k.el,k.anchor)},$=({el:k,anchor:D},H,ne)=>{let J;for(;k&&k!==D;)J=f(k),r(k,H,ne),k=J;r(D,H,ne)},C=({el:k,anchor:D})=>{let H;for(;k&&k!==D;)H=f(k),s(k),k=H;s(D)},_=(k,D,H,ne,J,re,de,le,ue)=>{D.type==="svg"?de="svg":D.type==="math"&&(de="mathml"),k==null?L(D,H,ne,J,re,de,le,ue):K(k,D,J,re,de,le,ue)},L=(k,D,H,ne,J,re,de,le)=>{let ue,se;const{props:Oe,shapeFlag:ce,transition:Ce,dirs:Re}=k;if(ue=k.el=i(k.type,re,Oe&&Oe.is,Oe),ce&8?l(ue,k.children):ce&16&&z(k.children,ue,null,ne,J,gl(k,re),de,le),Re&&Io(k,null,ne,"created"),V(ue,k,k.scopeId,de,ne),Oe){for(const tt in Oe)tt!=="value"&&!Pa(tt)&&o(ue,tt,null,Oe[tt],re,ne);"value"in Oe&&o(ue,"value",null,Oe.value,re),(se=Oe.onVnodeBeforeMount)&&us(se,ne,k)}Re&&Io(k,null,ne,"beforeMount");const Le=ZS(J,Ce);Le&&Ce.beforeEnter(ue),r(ue,D,H),((se=Oe&&Oe.onVnodeMounted)||Le||Re)&&lr(()=>{se&&us(se,ne,k),Le&&Ce.enter(ue),Re&&Io(k,null,ne,"mounted")},J)},V=(k,D,H,ne,J)=>{if(H&&d(k,H),ne)for(let re=0;re<ne.length;re++)d(k,ne[re]);if(J){let re=J.subTree;if(D===re||xg(re.type)&&(re.ssContent===D||re.ssFallback===D)){const de=J.vnode;V(k,de,de.scopeId,de.slotScopeIds,J.parent)}}},z=(k,D,H,ne,J,re,de,le,ue=0)=>{for(let se=ue;se<k.length;se++){const Oe=k[se]=le?no(k[se]):ls(k[se]);x(null,Oe,D,H,ne,J,re,de,le)}},K=(k,D,H,ne,J,re,de)=>{const le=D.el=k.el;let{patchFlag:ue,dynamicChildren:se,dirs:Oe}=D;ue|=k.patchFlag&16;const ce=k.props||bt,Ce=D.props||bt;let Re;if(H&&ko(H,!1),(Re=Ce.onVnodeBeforeUpdate)&&us(Re,H,D,k),Oe&&Io(D,k,H,"beforeUpdate"),H&&ko(H,!0),(ce.innerHTML&&Ce.innerHTML==null||ce.textContent&&Ce.textContent==null)&&l(le,""),se?q(k.dynamicChildren,se,le,H,ne,gl(D,J),re):de||Ie(k,D,le,null,H,ne,gl(D,J),re,!1),ue>0){if(ue&16)Z(le,ce,Ce,H,J);else if(ue&2&&ce.class!==Ce.class&&o(le,"class",null,Ce.class,J),ue&4&&o(le,"style",ce.style,Ce.style,J),ue&8){const Le=D.dynamicProps;for(let tt=0;tt<Le.length;tt++){const Ve=Le[tt],Xt=ce[Ve],Mt=Ce[Ve];(Mt!==Xt||Ve==="value")&&o(le,Ve,Xt,Mt,J,H)}}ue&1&&k.children!==D.children&&l(le,D.children)}else!de&&se==null&&Z(le,ce,Ce,H,J);((Re=Ce.onVnodeUpdated)||Oe)&&lr(()=>{Re&&us(Re,H,D,k),Oe&&Io(D,k,H,"updated")},ne)},q=(k,D,H,ne,J,re,de)=>{for(let le=0;le<D.length;le++){const ue=k[le],se=D[le],Oe=ue.el&&(ue.type===_s||!Ca(ue,se)||ue.shapeFlag&70)?h(ue.el):H;x(ue,se,Oe,null,ne,J,re,de,!0)}},Z=(k,D,H,ne,J)=>{if(D!==H){if(D!==bt)for(const re in D)!Pa(re)&&!(re in H)&&o(k,re,D[re],null,J,ne);for(const re in H){if(Pa(re))continue;const de=H[re],le=D[re];de!==le&&re!=="value"&&o(k,re,le,de,J,ne)}"value"in H&&o(k,"value",D.value,H.value,J)}},fe=(k,D,H,ne,J,re,de,le,ue)=>{const se=D.el=k?k.el:a(""),Oe=D.anchor=k?k.anchor:a("");let{patchFlag:ce,dynamicChildren:Ce,slotScopeIds:Re}=D;Re&&(le=le?le.concat(Re):Re),k==null?(r(se,H,ne),r(Oe,H,ne),z(D.children||[],H,Oe,J,re,de,le,ue)):ce>0&&ce&64&&Ce&&k.dynamicChildren?(q(k.dynamicChildren,Ce,H,J,re,de,le),(D.key!=null||J&&D===J.subTree)&&dg(k,D,!0)):Ie(k,D,H,Oe,J,re,de,le,ue)},xe=(k,D,H,ne,J,re,de,le,ue)=>{D.slotScopeIds=le,k==null?D.shapeFlag&512?J.ctx.activate(D,H,ne,de,ue):$e(D,H,ne,J,re,de,ue):Te(k,D,ue)},$e=(k,D,H,ne,J,re,de)=>{const le=k.component=xC(k,ne,J);if(Jm(k)&&(le.ctx.renderer=Se),bC(le,!1,de),le.asyncDep){if(J&&J.registerDep(le,ke,de),!k.el){const ue=le.subTree=jn(Xa);y(null,ue,D,H)}}else ke(le,k,D,H,J,re,de)},Te=(k,D,H)=>{const ne=D.component=k.component;if(aC(k,D,H))if(ne.asyncDep&&!ne.asyncResolved){Ee(ne,D,H);return}else ne.next=D,ne.update();else D.el=k.el,ne.vnode=D},ke=(k,D,H,ne,J,re,de)=>{const le=()=>{if(k.isMounted){let{next:ce,bu:Ce,u:Re,parent:Le,vnode:tt}=k;{const kt=pg(k);if(kt){ce&&(ce.el=tt.el,Ee(k,ce,de)),kt.asyncDep.then(()=>{k.isUnmounted||le()});return}}let Ve=ce,Xt;ko(k,!1),ce?(ce.el=tt.el,Ee(k,ce,de)):ce=tt,Ce&&hl(Ce),(Xt=ce.props&&ce.props.onVnodeBeforeUpdate)&&us(Xt,Le,ce,tt),ko(k,!0);const Mt=yl(k),zt=k.subTree;k.subTree=Mt,x(zt,Mt,h(zt.el),Q(zt),k,J,re),ce.el=Mt.el,Ve===null&&uC(k,Mt.el),Re&&lr(Re,J),(Xt=ce.props&&ce.props.onVnodeUpdated)&&lr(()=>us(Xt,Le,ce,tt),J)}else{let ce;const{el:Ce,props:Re}=D,{bm:Le,m:tt,parent:Ve,root:Xt,type:Mt}=k,zt=Ma(D);if(ko(k,!1),Le&&hl(Le),!zt&&(ce=Re&&Re.onVnodeBeforeMount)&&us(ce,Ve,D),ko(k,!0),Ce&&rt){const kt=()=>{k.subTree=yl(k),rt(Ce,k.subTree,k,J,null)};zt&&Mt.__asyncHydrate?Mt.__asyncHydrate(Ce,k,kt):kt()}else{Xt.ce&&Xt.ce._injectChildStyle(Mt);const kt=k.subTree=yl(k);x(null,kt,H,ne,k,J,re),D.el=kt.el}if(tt&&lr(tt,J),!zt&&(ce=Re&&Re.onVnodeMounted)){const kt=D;lr(()=>us(ce,Ve,kt),J)}(D.shapeFlag&256||Ve&&Ma(Ve.vnode)&&Ve.vnode.shapeFlag&256)&&k.a&&lr(k.a,J),k.isMounted=!0,D=H=ne=null}};k.scope.on();const ue=k.effect=new Nm(le);k.scope.off();const se=k.update=ue.run.bind(ue),Oe=k.job=ue.runIfDirty.bind(ue);Oe.i=k,Oe.id=k.uid,ue.scheduler=()=>cf(Oe),ko(k,!0),se()},Ee=(k,D,H)=>{D.component=k;const ne=k.vnode.props;k.vnode=D,k.next=null,jS(k,D.props,ne,H),XS(k,D.children,H),go(),bd(k),yo()},Ie=(k,D,H,ne,J,re,de,le,ue=!1)=>{const se=k&&k.children,Oe=k?k.shapeFlag:0,ce=D.children,{patchFlag:Ce,shapeFlag:Re}=D;if(Ce>0){if(Ce&128){Lt(se,ce,H,ne,J,re,de,le,ue);return}else if(Ce&256){Je(se,ce,H,ne,J,re,de,le,ue);return}}Re&8?(Oe&16&&Wt(se,J,re),ce!==se&&l(H,ce)):Oe&16?Re&16?Lt(se,ce,H,ne,J,re,de,le,ue):Wt(se,J,re,!0):(Oe&8&&l(H,""),Re&16&&z(ce,H,ne,J,re,de,le,ue))},Je=(k,D,H,ne,J,re,de,le,ue)=>{k=k||Pi,D=D||Pi;const se=k.length,Oe=D.length,ce=Math.min(se,Oe);let Ce;for(Ce=0;Ce<ce;Ce++){const Re=D[Ce]=ue?no(D[Ce]):ls(D[Ce]);x(k[Ce],Re,H,null,J,re,de,le,ue)}se>Oe?Wt(k,J,re,!0,!1,ce):z(D,H,ne,J,re,de,le,ue,ce)},Lt=(k,D,H,ne,J,re,de,le,ue)=>{let se=0;const Oe=D.length;let ce=k.length-1,Ce=Oe-1;for(;se<=ce&&se<=Ce;){const Re=k[se],Le=D[se]=ue?no(D[se]):ls(D[se]);if(Ca(Re,Le))x(Re,Le,H,null,J,re,de,le,ue);else break;se++}for(;se<=ce&&se<=Ce;){const Re=k[ce],Le=D[Ce]=ue?no(D[Ce]):ls(D[Ce]);if(Ca(Re,Le))x(Re,Le,H,null,J,re,de,le,ue);else break;ce--,Ce--}if(se>ce){if(se<=Ce){const Re=Ce+1,Le=Re<Oe?D[Re].el:ne;for(;se<=Ce;)x(null,D[se]=ue?no(D[se]):ls(D[se]),H,Le,J,re,de,le,ue),se++}}else if(se>Ce)for(;se<=ce;)vt(k[se],J,re,!0),se++;else{const Re=se,Le=se,tt=new Map;for(se=Le;se<=Ce;se++){const Gt=D[se]=ue?no(D[se]):ls(D[se]);Gt.key!=null&&tt.set(Gt.key,se)}let Ve,Xt=0;const Mt=Ce-Le+1;let zt=!1,kt=0;const qn=new Array(Mt);for(se=0;se<Mt;se++)qn[se]=0;for(se=Re;se<=ce;se++){const Gt=k[se];if(Xt>=Mt){vt(Gt,J,re,!0);continue}let jt;if(Gt.key!=null)jt=tt.get(Gt.key);else for(Ve=Le;Ve<=Ce;Ve++)if(qn[Ve-Le]===0&&Ca(Gt,D[Ve])){jt=Ve;break}jt===void 0?vt(Gt,J,re,!0):(qn[jt-Le]=se+1,jt>=kt?kt=jt:zt=!0,x(Gt,D[jt],H,null,J,re,de,le,ue),Xt++)}const Br=zt?JS(qn):Pi;for(Ve=Br.length-1,se=Mt-1;se>=0;se--){const Gt=Le+se,jt=D[Gt],xn=Gt+1<Oe?D[Gt+1].el:ne;qn[se]===0?x(null,jt,H,xn,J,re,de,le,ue):zt&&(Ve<0||se!==Br[Ve]?Bt(jt,H,xn,2):Ve--)}}},Bt=(k,D,H,ne,J=null)=>{const{el:re,type:de,transition:le,children:ue,shapeFlag:se}=k;if(se&6){Bt(k.component.subTree,D,H,ne);return}if(se&128){k.suspense.move(D,H,ne);return}if(se&64){de.move(k,D,H,Se);return}if(de===_s){r(re,D,H);for(let ce=0;ce<ue.length;ce++)Bt(ue[ce],D,H,ne);r(k.anchor,D,H);return}if(de===xl){$(k,D,H);return}if(ne!==2&&se&1&&le)if(ne===0)le.beforeEnter(re),r(re,D,H),lr(()=>le.enter(re),J);else{const{leave:ce,delayLeave:Ce,afterLeave:Re}=le,Le=()=>r(re,D,H),tt=()=>{ce(re,()=>{Le(),Re&&Re()})};Ce?Ce(re,Le,tt):tt()}else r(re,D,H)},vt=(k,D,H,ne=!1,J=!1)=>{const{type:re,props:de,ref:le,children:ue,dynamicChildren:se,shapeFlag:Oe,patchFlag:ce,dirs:Ce,cacheIndex:Re}=k;if(ce===-2&&(J=!1),le!=null&&ql(le,null,H,k,!0),Re!=null&&(D.renderCache[Re]=void 0),Oe&256){D.ctx.deactivate(k);return}const Le=Oe&1&&Ce,tt=!Ma(k);let Ve;if(tt&&(Ve=de&&de.onVnodeBeforeUnmount)&&us(Ve,D,k),Oe&6)Pn(k.component,H,ne);else{if(Oe&128){k.suspense.unmount(H,ne);return}Le&&Io(k,null,D,"beforeUnmount"),Oe&64?k.type.remove(k,D,H,Se,ne):se&&!se.hasOnce&&(re!==_s||ce>0&&ce&64)?Wt(se,D,H,!1,!0):(re===_s&&ce&384||!J&&Oe&16)&&Wt(ue,D,H),ne&&tn(k)}(tt&&(Ve=de&&de.onVnodeUnmounted)||Le)&&lr(()=>{Ve&&us(Ve,D,k),Le&&Io(k,null,D,"unmounted")},H)},tn=k=>{const{type:D,el:H,anchor:ne,transition:J}=k;if(D===_s){Dn(H,ne);return}if(D===xl){C(k);return}const re=()=>{s(H),J&&!J.persisted&&J.afterLeave&&J.afterLeave()};if(k.shapeFlag&1&&J&&!J.persisted){const{leave:de,delayLeave:le}=J,ue=()=>de(H,re);le?le(k.el,re,ue):ue()}else re()},Dn=(k,D)=>{let H;for(;k!==D;)H=f(k),s(k),k=H;s(D)},Pn=(k,D,H)=>{const{bum:ne,scope:J,job:re,subTree:de,um:le,m:ue,a:se}=k;Nd(ue),Nd(se),ne&&hl(ne),J.stop(),re&&(re.flags|=8,vt(de,k,D,H)),le&&lr(le,D),lr(()=>{k.isUnmounted=!0},D),D&&D.pendingBranch&&!D.isUnmounted&&k.asyncDep&&!k.asyncResolved&&k.suspenseId===D.pendingId&&(D.deps--,D.deps===0&&D.resolve())},Wt=(k,D,H,ne=!1,J=!1,re=0)=>{for(let de=re;de<k.length;de++)vt(k[de],D,H,ne,J)},Q=k=>{if(k.shapeFlag&6)return Q(k.component.subTree);if(k.shapeFlag&128)return k.suspense.next();const D=f(k.anchor||k.el),H=D&&D[bS];return H?f(H):D};let be=!1;const ye=(k,D,H)=>{k==null?D._vnode&&vt(D._vnode,null,null,!0):x(D._vnode||null,k,D,null,null,null,H),D._vnode=k,be||(be=!0,bd(),Km(),be=!1)},Se={p:x,um:vt,m:Bt,r:tn,mt:$e,mc:z,pc:Ie,pbc:q,n:Q,o:t};let je,rt;return{render:ye,hydrate:je,createApp:zS(ye,je)}}function gl({type:t,props:e},n){return n==="svg"&&t==="foreignObject"||n==="mathml"&&t==="annotation-xml"&&e&&e.encoding&&e.encoding.includes("html")?void 0:n}function ko({effect:t,job:e},n){n?(t.flags|=32,e.flags|=4):(t.flags&=-33,e.flags&=-5)}function ZS(t,e){return(!t||t&&!t.pendingBranch)&&e&&!e.persisted}function dg(t,e,n=!1){const r=t.children,s=e.children;if(Ge(r)&&Ge(s))for(let o=0;o<r.length;o++){const i=r[o];let a=s[o];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=s[o]=no(s[o]),a.el=i.el),!n&&a.patchFlag!==-2&&dg(i,a)),a.type===Fc&&(a.el=i.el)}}function JS(t){const e=t.slice(),n=[0];let r,s,o,i,a;const u=t.length;for(r=0;r<u;r++){const c=t[r];if(c!==0){if(s=n[n.length-1],t[s]<c){e[r]=s,n.push(r);continue}for(o=0,i=n.length-1;o<i;)a=o+i>>1,t[n[a]]<c?o=a+1:i=a;c<t[n[o]]&&(o>0&&(e[r]=n[o-1]),n[o]=r)}}for(o=n.length,i=n[o-1];o-- >0;)n[o]=i,i=e[i];return n}function pg(t){const e=t.subTree.component;if(e)return e.asyncDep&&!e.asyncResolved?e:pg(e)}function Nd(t){if(t)for(let e=0;e<t.length;e++)t[e].flags|=8}const eC=Symbol.for("v-scx"),tC=()=>Ds(eC);function Bi(t,e,n){return mg(t,e,n)}function mg(t,e,n=bt){const{immediate:r,deep:s,flush:o,once:i}=n,a=cn({},n),u=e&&r||!e&&o!=="post";let c;if(Qa){if(o==="sync"){const d=tC();c=d.__watcherHandles||(d.__watcherHandles=[])}else if(!u){const d=()=>{};return d.stop=ps,d.resume=ps,d.pause=ps,d}}const l=In;a.call=(d,m,x)=>ys(d,l,m,x);let h=!1;o==="post"?a.scheduler=d=>{lr(d,l&&l.suspense)}:o!=="sync"&&(h=!0,a.scheduler=(d,m)=>{m?d():cf(d)}),a.augmentJob=d=>{e&&(d.flags|=4),h&&(d.flags|=2,l&&(d.id=l.uid,d.i=l))};const f=pS(t,e,a);return Qa&&(c?c.push(f):u&&f()),f}function nC(t,e,n){const r=this.proxy,s=ln(t)?t.includes(".")?gg(r,t):()=>r[t]:t.bind(r,r);let o;Ue(e)?o=e:(o=e.handler,n=e);const i=pu(this),a=mg(s,o.bind(r),n);return i(),a}function gg(t,e){const n=e.split(".");return()=>{let r=t;for(let s=0;s<n.length&&r;s++)r=r[n[s]];return r}}const rC=(t,e)=>e==="modelValue"||e==="model-value"?t.modelModifiers:t[`${e}Modifiers`]||t[`${Ar(e)}Modifiers`]||t[`${ii(e)}Modifiers`];function sC(t,e,...n){if(t.isUnmounted)return;const r=t.vnode.props||bt;let s=n;const o=e.startsWith("update:"),i=o&&rC(r,e.slice(7));i&&(i.trim&&(s=n.map(l=>ln(l)?l.trim():l)),i.number&&(s=n.map(Dw)));let a,u=r[a=ll(e)]||r[a=ll(Ar(e))];!u&&o&&(u=r[a=ll(ii(e))]),u&&ys(u,t,6,s);const c=r[a+"Once"];if(c){if(!t.emitted)t.emitted={};else if(t.emitted[a])return;t.emitted[a]=!0,ys(c,t,6,s)}}function yg(t,e,n=!1){const r=e.emitsCache,s=r.get(t);if(s!==void 0)return s;const o=t.emits;let i={},a=!1;if(!Ue(t)){const u=c=>{const l=yg(c,e,!0);l&&(a=!0,cn(i,l))};!n&&e.mixins.length&&e.mixins.forEach(u),t.extends&&u(t.extends),t.mixins&&t.mixins.forEach(u)}return!o&&!a?(qt(t)&&r.set(t,null),null):(Ge(o)?o.forEach(u=>i[u]=null):cn(i,o),qt(t)&&r.set(t,i),i)}function Pc(t,e){return!t||!Nc(e)?!1:(e=e.slice(2).replace(/Once$/,""),ut(t,e[0].toLowerCase()+e.slice(1))||ut(t,ii(e))||ut(t,e))}function yl(t){const{type:e,vnode:n,proxy:r,withProxy:s,propsOptions:[o],slots:i,attrs:a,emit:u,render:c,renderCache:l,props:h,data:f,setupState:d,ctx:m,inheritAttrs:x}=t,g=ec(t);let y,S;try{if(n.shapeFlag&4){const C=s||r,_=C;y=ls(c.call(_,C,l,h,d,f,m)),S=a}else{const C=e;y=ls(C.length>1?C(h,{attrs:a,slots:i,emit:u}):C(h,null)),S=e.props?a:oC(a)}}catch(C){Ua.length=0,Ac(C,t,1),y=jn(Xa)}let $=y;if(S&&x!==!1){const C=Object.keys(S),{shapeFlag:_}=$;C.length&&_&7&&(o&&C.some(Xh)&&(S=iC(S,o)),$=zi($,S,!1,!0))}return n.dirs&&($=zi($,null,!1,!0),$.dirs=$.dirs?$.dirs.concat(n.dirs):n.dirs),n.transition&&lf($,n.transition),y=$,ec(g),y}const oC=t=>{let e;for(const n in t)(n==="class"||n==="style"||Nc(n))&&((e||(e={}))[n]=t[n]);return e},iC=(t,e)=>{const n={};for(const r in t)(!Xh(r)||!(r.slice(9)in e))&&(n[r]=t[r]);return n};function aC(t,e,n){const{props:r,children:s,component:o}=t,{props:i,children:a,patchFlag:u}=e,c=o.emitsOptions;if(e.dirs||e.transition)return!0;if(n&&u>=0){if(u&1024)return!0;if(u&16)return r?Ed(r,i,c):!!i;if(u&8){const l=e.dynamicProps;for(let h=0;h<l.length;h++){const f=l[h];if(i[f]!==r[f]&&!Pc(c,f))return!0}}}else return(s||a)&&(!a||!a.$stable)?!0:r===i?!1:r?i?Ed(r,i,c):!0:!!i;return!1}function Ed(t,e,n){const r=Object.keys(e);if(r.length!==Object.keys(t).length)return!0;for(let s=0;s<r.length;s++){const o=r[s];if(e[o]!==t[o]&&!Pc(n,o))return!0}return!1}function uC({vnode:t,parent:e},n){for(;e;){const r=e.subTree;if(r.suspense&&r.suspense.activeBranch===t&&(r.el=t.el),r===t)(t=e.vnode).el=n,e=e.parent;else break}}const xg=t=>t.__isSuspense;function cC(t,e){e&&e.pendingBranch?Ge(t)?e.effects.push(...t):e.effects.push(t):yS(t)}const _s=Symbol.for("v-fgt"),Fc=Symbol.for("v-txt"),Xa=Symbol.for("v-cmt"),xl=Symbol.for("v-stc"),Ua=[];let pr=null;function du(t=!1){Ua.push(pr=t?null:[])}function lC(){Ua.pop(),pr=Ua[Ua.length-1]||null}let Ya=1;function _d(t){Ya+=t,t<0&&pr&&(pr.hasOnce=!0)}function bg(t){return t.dynamicChildren=Ya>0?pr||Pi:null,lC(),Ya>0&&pr&&pr.push(t),t}function Lc(t,e,n,r,s,o){return bg(Kr(t,e,n,r,s,o,!0))}function hC(t,e,n,r,s){return bg(jn(t,e,n,r,s,!0))}function nc(t){return t?t.__v_isVNode===!0:!1}function Ca(t,e){return t.type===e.type&&t.key===e.key}const vg=({key:t})=>t??null,ju=({ref:t,ref_key:e,ref_for:n})=>(typeof t=="number"&&(t=""+t),t!=null?ln(t)||Rn(t)||Ue(t)?{i:dr,r:t,k:e,f:!!n}:t:null);function Kr(t,e=null,n=null,r=0,s=null,o=t===_s?0:1,i=!1,a=!1){const u={__v_isVNode:!0,__v_skip:!0,type:t,props:e,key:e&&vg(e),ref:e&&ju(e),scopeId:Xm,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:r,dynamicProps:s,dynamicChildren:null,appContext:null,ctx:dr};return a?(df(u,n),o&128&&t.normalize(u)):n&&(u.shapeFlag|=ln(n)?8:16),Ya>0&&!i&&pr&&(u.patchFlag>0||o&6)&&u.patchFlag!==32&&pr.push(u),u}const jn=fC;function fC(t,e=null,n=null,r=0,s=null,o=!1){if((!t||t===DS)&&(t=Xa),nc(t)){const a=zi(t,e,!0);return n&&df(a,n),Ya>0&&!o&&pr&&(a.shapeFlag&6?pr[pr.indexOf(t)]=a:pr.push(a)),a.patchFlag=-2,a}if($C(t)&&(t=t.__vccOpts),e){e=dC(e);let{class:a,style:u}=e;a&&!ln(a)&&(e.class=Jh(a)),qt(u)&&(uf(u)&&!Ge(u)&&(u=cn({},u)),e.style=Zh(u))}const i=ln(t)?1:xg(t)?128:vS(t)?64:qt(t)?4:Ue(t)?2:0;return Kr(t,e,n,r,s,i,o,!0)}function dC(t){return t?uf(t)||ig(t)?cn({},t):t:null}function zi(t,e,n=!1,r=!1){const{props:s,ref:o,patchFlag:i,children:a,transition:u}=t,c=e?mC(s||{},e):s,l={__v_isVNode:!0,__v_skip:!0,type:t.type,props:c,key:c&&vg(c),ref:e&&e.ref?n&&o?Ge(o)?o.concat(ju(e)):[o,ju(e)]:ju(e):o,scopeId:t.scopeId,slotScopeIds:t.slotScopeIds,children:a,target:t.target,targetStart:t.targetStart,targetAnchor:t.targetAnchor,staticCount:t.staticCount,shapeFlag:t.shapeFlag,patchFlag:e&&t.type!==_s?i===-1?16:i|16:i,dynamicProps:t.dynamicProps,dynamicChildren:t.dynamicChildren,appContext:t.appContext,dirs:t.dirs,transition:u,component:t.component,suspense:t.suspense,ssContent:t.ssContent&&zi(t.ssContent),ssFallback:t.ssFallback&&zi(t.ssFallback),el:t.el,anchor:t.anchor,ctx:t.ctx,ce:t.ce};return u&&r&&lf(l,u.clone(l)),l}function pC(t=" ",e=0){return jn(Fc,null,t,e)}function ls(t){return t==null||typeof t=="boolean"?jn(Xa):Ge(t)?jn(_s,null,t.slice()):nc(t)?no(t):jn(Fc,null,String(t))}function no(t){return t.el===null&&t.patchFlag!==-1||t.memo?t:zi(t)}function df(t,e){let n=0;const{shapeFlag:r}=t;if(e==null)e=null;else if(Ge(e))n=16;else if(typeof e=="object")if(r&65){const s=e.default;s&&(s._c&&(s._d=!1),df(t,s()),s._c&&(s._d=!0));return}else{n=32;const s=e._;!s&&!ig(e)?e._ctx=dr:s===3&&dr&&(dr.slots._===1?e._=1:(e._=2,t.patchFlag|=1024))}else Ue(e)?(e={default:e,_ctx:dr},n=32):(e=String(e),r&64?(n=16,e=[pC(e)]):n=8);t.children=e,t.shapeFlag|=n}function mC(...t){const e={};for(let n=0;n<t.length;n++){const r=t[n];for(const s in r)if(s==="class")e.class!==r.class&&(e.class=Jh([e.class,r.class]));else if(s==="style")e.style=Zh([e.style,r.style]);else if(Nc(s)){const o=e[s],i=r[s];i&&o!==i&&!(Ge(o)&&o.includes(i))&&(e[s]=o?[].concat(o,i):i)}else s!==""&&(e[s]=r[s])}return e}function us(t,e,n,r=null){ys(t,e,7,[n,r])}const gC=rg();let yC=0;function xC(t,e,n){const r=t.type,s=(e?e.appContext:t.appContext)||gC,o={uid:yC++,vnode:t,type:r,parent:e,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Uw(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(s.provides),ids:e?e.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:ug(r,s),emitsOptions:yg(r,s),emit:null,emitted:null,propsDefaults:bt,inheritAttrs:r.inheritAttrs,ctx:bt,data:bt,props:bt,attrs:bt,slots:bt,refs:bt,setupState:bt,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=e?e.root:o,o.emit=sC.bind(null,o),t.ce&&t.ce(o),o}let In=null,rc,Jl;{const t=kc(),e=(n,r)=>{let s;return(s=t[n])||(s=t[n]=[]),s.push(r),o=>{s.length>1?s.forEach(i=>i(o)):s[0](o)}};rc=e("__VUE_INSTANCE_SETTERS__",n=>In=n),Jl=e("__VUE_SSR_SETTERS__",n=>Qa=n)}const pu=t=>{const e=In;return rc(t),t.scope.on(),()=>{t.scope.off(),rc(e)}},Id=()=>{In&&In.scope.off(),rc(null)};function wg(t){return t.vnode.shapeFlag&4}let Qa=!1;function bC(t,e=!1,n=!1){e&&Jl(e);const{props:r,children:s}=t.vnode,o=wg(t);GS(t,r,o,e),qS(t,s,n);const i=o?vC(t,e):void 0;return e&&Jl(!1),i}function vC(t,e){const n=t.type;t.accessCache=Object.create(null),t.proxy=new Proxy(t.ctx,FS);const{setup:r}=n;if(r){go();const s=t.setupContext=r.length>1?SC(t):null,o=pu(t),i=fu(r,t,0,[t.props,s]),a=Cm(i);if(yo(),o(),(a||t.sp)&&!Ma(t)&&Zm(t),a){if(i.then(Id,Id),e)return i.then(u=>{kd(t,u,e)}).catch(u=>{Ac(u,t,0)});t.asyncDep=i}else kd(t,i,e)}else Sg(t,e)}function kd(t,e,n){Ue(e)?t.type.__ssrInlineRender?t.ssrRender=e:t.render=e:qt(e)&&(t.setupState=zm(e)),Sg(t,n)}let Rd;function Sg(t,e,n){const r=t.type;if(!t.render){if(!e&&Rd&&!r.render){const s=r.template||hf(t).template;if(s){const{isCustomElement:o,compilerOptions:i}=t.appContext.config,{delimiters:a,compilerOptions:u}=r,c=cn(cn({isCustomElement:o,delimiters:a},i),u);r.render=Rd(s,c)}}t.render=r.render||ps}{const s=pu(t);go();try{LS(t)}finally{yo(),s()}}}const wC={get(t,e){return Nn(t,"get",""),t[e]}};function SC(t){const e=n=>{t.exposed=n||{}};return{attrs:new Proxy(t.attrs,wC),slots:t.slots,emit:t.emit,expose:e}}function Bc(t){return t.exposed?t.exposeProxy||(t.exposeProxy=new Proxy(zm(aS(t.exposed)),{get(e,n){if(n in e)return e[n];if(n in Va)return Va[n](t)},has(e,n){return n in e||n in Va}})):t.proxy}function CC(t,e=!0){return Ue(t)?t.displayName||t.name:t.name||e&&t.__name}function $C(t){return Ue(t)&&"__vccOpts"in t}const jr=(t,e)=>fS(t,e,Qa);function Cg(t,e,n){const r=arguments.length;return r===2?qt(e)&&!Ge(e)?nc(e)?jn(t,null,[e]):jn(t,e):jn(t,null,e):(r>3?n=Array.prototype.slice.call(arguments,2):r===3&&nc(n)&&(n=[n]),jn(t,e,n))}const TC="3.5.12";/**
* @vue/runtime-dom v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let eh;const Ad=typeof window<"u"&&window.trustedTypes;if(Ad)try{eh=Ad.createPolicy("vue",{createHTML:t=>t})}catch{}const $g=eh?t=>eh.createHTML(t):t=>t,NC="http://www.w3.org/2000/svg",EC="http://www.w3.org/1998/Math/MathML",Es=typeof document<"u"?document:null,Od=Es&&Es.createElement("template"),_C={insert:(t,e,n)=>{e.insertBefore(t,n||null)},remove:t=>{const e=t.parentNode;e&&e.removeChild(t)},createElement:(t,e,n,r)=>{const s=e==="svg"?Es.createElementNS(NC,t):e==="mathml"?Es.createElementNS(EC,t):n?Es.createElement(t,{is:n}):Es.createElement(t);return t==="select"&&r&&r.multiple!=null&&s.setAttribute("multiple",r.multiple),s},createText:t=>Es.createTextNode(t),createComment:t=>Es.createComment(t),setText:(t,e)=>{t.nodeValue=e},setElementText:(t,e)=>{t.textContent=e},parentNode:t=>t.parentNode,nextSibling:t=>t.nextSibling,querySelector:t=>Es.querySelector(t),setScopeId(t,e){t.setAttribute(e,"")},insertStaticContent(t,e,n,r,s,o){const i=n?n.previousSibling:e.lastChild;if(s&&(s===o||s.nextSibling))for(;e.insertBefore(s.cloneNode(!0),n),!(s===o||!(s=s.nextSibling)););else{Od.innerHTML=$g(r==="svg"?`<svg>${t}</svg>`:r==="mathml"?`<math>${t}</math>`:t);const a=Od.content;if(r==="svg"||r==="mathml"){const u=a.firstChild;for(;u.firstChild;)a.appendChild(u.firstChild);a.removeChild(u)}e.insertBefore(a,n)}return[i?i.nextSibling:e.firstChild,n?n.previousSibling:e.lastChild]}},IC=Symbol("_vtc");function kC(t,e,n){const r=t[IC];r&&(e=(e?[e,...r]:[...r]).join(" ")),e==null?t.removeAttribute("class"):n?t.setAttribute("class",e):t.className=e}const sc=Symbol("_vod"),Tg=Symbol("_vsh"),Ng={beforeMount(t,{value:e},{transition:n}){t[sc]=t.style.display==="none"?"":t.style.display,n&&e?n.beforeEnter(t):$a(t,e)},mounted(t,{value:e},{transition:n}){n&&e&&n.enter(t)},updated(t,{value:e,oldValue:n},{transition:r}){!e!=!n&&(r?e?(r.beforeEnter(t),$a(t,!0),r.enter(t)):r.leave(t,()=>{$a(t,!1)}):$a(t,e))},beforeUnmount(t,{value:e}){$a(t,e)}};function $a(t,e){t.style.display=e?t[sc]:"none",t[Tg]=!e}const RC=Symbol(""),AC=/(^|;)\s*display\s*:/;function OC(t,e,n){const r=t.style,s=ln(n);let o=!1;if(n&&!s){if(e)if(ln(e))for(const i of e.split(";")){const a=i.slice(0,i.indexOf(":")).trim();n[a]==null&&Hu(r,a,"")}else for(const i in e)n[i]==null&&Hu(r,i,"");for(const i in n)i==="display"&&(o=!0),Hu(r,i,n[i])}else if(s){if(e!==n){const i=r[RC];i&&(n+=";"+i),r.cssText=n,o=AC.test(n)}}else e&&t.removeAttribute("style");sc in t&&(t[sc]=o?r.display:"",t[Tg]&&(r.display="none"))}const Dd=/\s*!important$/;function Hu(t,e,n){if(Ge(n))n.forEach(r=>Hu(t,e,r));else if(n==null&&(n=""),e.startsWith("--"))t.setProperty(e,n);else{const r=DC(t,e);Dd.test(n)?t.setProperty(ii(r),n.replace(Dd,""),"important"):t[r]=n}}const Pd=["Webkit","Moz","ms"],bl={};function DC(t,e){const n=bl[e];if(n)return n;let r=Ar(e);if(r!=="filter"&&r in t)return bl[e]=r;r=Ic(r);for(let s=0;s<Pd.length;s++){const o=Pd[s]+r;if(o in t)return bl[e]=o}return e}const Fd="http://www.w3.org/1999/xlink";function Ld(t,e,n,r,s,o=Vw(e)){r&&e.startsWith("xlink:")?n==null?t.removeAttributeNS(Fd,e.slice(6,e.length)):t.setAttributeNS(Fd,e,n):n==null||o&&!Tm(n)?t.removeAttribute(e):t.setAttribute(e,o?"":ea(n)?String(n):n)}function Bd(t,e,n,r,s){if(e==="innerHTML"||e==="textContent"){n!=null&&(t[e]=e==="innerHTML"?$g(n):n);return}const o=t.tagName;if(e==="value"&&o!=="PROGRESS"&&!o.includes("-")){const a=o==="OPTION"?t.getAttribute("value")||"":t.value,u=n==null?t.type==="checkbox"?"on":"":String(n);(a!==u||!("_value"in t))&&(t.value=u),n==null&&t.removeAttribute(e),t._value=n;return}let i=!1;if(n===""||n==null){const a=typeof t[e];a==="boolean"?n=Tm(n):n==null&&a==="string"?(n="",i=!0):a==="number"&&(n=0,i=!0)}try{t[e]=n}catch{}i&&t.removeAttribute(s||e)}function PC(t,e,n,r){t.addEventListener(e,n,r)}function FC(t,e,n,r){t.removeEventListener(e,n,r)}const Md=Symbol("_vei");function LC(t,e,n,r,s=null){const o=t[Md]||(t[Md]={}),i=o[e];if(r&&i)i.value=r;else{const[a,u]=BC(e);if(r){const c=o[e]=UC(r,s);PC(t,a,c,u)}else i&&(FC(t,a,i,u),o[e]=void 0)}}const Vd=/(?:Once|Passive|Capture)$/;function BC(t){let e;if(Vd.test(t)){e={};let r;for(;r=t.match(Vd);)t=t.slice(0,t.length-r[0].length),e[r[0].toLowerCase()]=!0}return[t[2]===":"?t.slice(3):ii(t.slice(2)),e]}let vl=0;const MC=Promise.resolve(),VC=()=>vl||(MC.then(()=>vl=0),vl=Date.now());function UC(t,e){const n=r=>{if(!r._vts)r._vts=Date.now();else if(r._vts<=n.attached)return;ys(WC(r,n.value),e,5,[r])};return n.value=t,n.attached=VC(),n}function WC(t,e){if(Ge(e)){const n=t.stopImmediatePropagation;return t.stopImmediatePropagation=()=>{n.call(t),t._stopped=!0},e.map(r=>s=>!s._stopped&&r&&r(s))}else return e}const Ud=t=>t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)>96&&t.charCodeAt(2)<123,zC=(t,e,n,r,s,o)=>{const i=s==="svg";e==="class"?kC(t,r,i):e==="style"?OC(t,n,r):Nc(e)?Xh(e)||LC(t,e,n,r,o):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):GC(t,e,r,i))?(Bd(t,e,r),!t.tagName.includes("-")&&(e==="value"||e==="checked"||e==="selected")&&Ld(t,e,r,i,o,e!=="value")):t._isVueCE&&(/[A-Z]/.test(e)||!ln(r))?Bd(t,Ar(e),r,o,e):(e==="true-value"?t._trueValue=r:e==="false-value"&&(t._falseValue=r),Ld(t,e,r,i))};function GC(t,e,n,r){if(r)return!!(e==="innerHTML"||e==="textContent"||e in t&&Ud(e)&&Ue(n));if(e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&t.tagName==="INPUT"||e==="type"&&t.tagName==="TEXTAREA")return!1;if(e==="width"||e==="height"){const s=t.tagName;if(s==="IMG"||s==="VIDEO"||s==="CANVAS"||s==="SOURCE")return!1}return Ud(e)&&ln(n)?!1:e in t}const jC=cn({patchProp:zC},_C);let Wd;function HC(){return Wd||(Wd=YS(jC))}const KC=(...t)=>{const e=HC().createApp(...t),{mount:n}=e;return e.mount=r=>{const s=XC(r);if(!s)return;const o=e._component;!Ue(o)&&!o.render&&!o.template&&(o.template=s.innerHTML),s.nodeType===1&&(s.textContent="");const i=n(s,!1,qC(s));return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),i},e};function qC(t){if(t instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&t instanceof MathMLElement)return"mathml"}function XC(t){return ln(t)?document.querySelector(t):t}const pf=(t,e)=>{const n=t.__vccOpts||t;for(const[r,s]of e)n[r]=s;return n},YC={};function QC(t,e){const n=OS("RouterView");return du(),hC(n)}const ZC=pf(YC,[["render",QC]]);/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */const ki=typeof document<"u";function Eg(t){return typeof t=="object"||"displayName"in t||"props"in t||"__vccOpts"in t}function JC(t){return t.__esModule||t[Symbol.toStringTag]==="Module"||t.default&&Eg(t.default)}const ft=Object.assign;function wl(t,e){const n={};for(const r in e){const s=e[r];n[r]=Jr(s)?s.map(t):t(s)}return n}const Wa=()=>{},Jr=Array.isArray,_g=/#/g,e$=/&/g,t$=/\//g,n$=/=/g,r$=/\?/g,Ig=/\+/g,s$=/%5B/g,o$=/%5D/g,kg=/%5E/g,i$=/%60/g,Rg=/%7B/g,a$=/%7C/g,Ag=/%7D/g,u$=/%20/g;function mf(t){return encodeURI(""+t).replace(a$,"|").replace(s$,"[").replace(o$,"]")}function c$(t){return mf(t).replace(Rg,"{").replace(Ag,"}").replace(kg,"^")}function th(t){return mf(t).replace(Ig,"%2B").replace(u$,"+").replace(_g,"%23").replace(e$,"%26").replace(i$,"`").replace(Rg,"{").replace(Ag,"}").replace(kg,"^")}function l$(t){return th(t).replace(n$,"%3D")}function h$(t){return mf(t).replace(_g,"%23").replace(r$,"%3F")}function f$(t){return t==null?"":h$(t).replace(t$,"%2F")}function Za(t){try{return decodeURIComponent(""+t)}catch{}return""+t}const d$=/\/$/,p$=t=>t.replace(d$,"");function Sl(t,e,n="/"){let r,s={},o="",i="";const a=e.indexOf("#");let u=e.indexOf("?");return a<u&&a>=0&&(u=-1),u>-1&&(r=e.slice(0,u),o=e.slice(u+1,a>-1?a:e.length),s=t(o)),a>-1&&(r=r||e.slice(0,a),i=e.slice(a,e.length)),r=x$(r??e,n),{fullPath:r+(o&&"?")+o+i,path:r,query:s,hash:Za(i)}}function m$(t,e){const n=e.query?t(e.query):"";return e.path+(n&&"?")+n+(e.hash||"")}function zd(t,e){return!e||!t.toLowerCase().startsWith(e.toLowerCase())?t:t.slice(e.length)||"/"}function g$(t,e,n){const r=e.matched.length-1,s=n.matched.length-1;return r>-1&&r===s&&Gi(e.matched[r],n.matched[s])&&Og(e.params,n.params)&&t(e.query)===t(n.query)&&e.hash===n.hash}function Gi(t,e){return(t.aliasOf||t)===(e.aliasOf||e)}function Og(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const n in t)if(!y$(t[n],e[n]))return!1;return!0}function y$(t,e){return Jr(t)?Gd(t,e):Jr(e)?Gd(e,t):t===e}function Gd(t,e){return Jr(e)?t.length===e.length&&t.every((n,r)=>n===e[r]):t.length===1&&t[0]===e}function x$(t,e){if(t.startsWith("/"))return t;if(!t)return e;const n=e.split("/"),r=t.split("/"),s=r[r.length-1];(s===".."||s===".")&&r.push("");let o=n.length-1,i,a;for(i=0;i<r.length;i++)if(a=r[i],a!==".")if(a==="..")o>1&&o--;else break;return n.slice(0,o).join("/")+"/"+r.slice(i).join("/")}const Js={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};var Ja;(function(t){t.pop="pop",t.push="push"})(Ja||(Ja={}));var za;(function(t){t.back="back",t.forward="forward",t.unknown=""})(za||(za={}));function b$(t){if(!t)if(ki){const e=document.querySelector("base");t=e&&e.getAttribute("href")||"/",t=t.replace(/^\w+:\/\/[^\/]+/,"")}else t="/";return t[0]!=="/"&&t[0]!=="#"&&(t="/"+t),p$(t)}const v$=/^[^#]+#/;function w$(t,e){return t.replace(v$,"#")+e}function S$(t,e){const n=document.documentElement.getBoundingClientRect(),r=t.getBoundingClientRect();return{behavior:e.behavior,left:r.left-n.left-(e.left||0),top:r.top-n.top-(e.top||0)}}const Mc=()=>({left:window.scrollX,top:window.scrollY});function C$(t){let e;if("el"in t){const n=t.el,r=typeof n=="string"&&n.startsWith("#"),s=typeof n=="string"?r?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!s)return;e=S$(s,t)}else e=t;"scrollBehavior"in document.documentElement.style?window.scrollTo(e):window.scrollTo(e.left!=null?e.left:window.scrollX,e.top!=null?e.top:window.scrollY)}function jd(t,e){return(history.state?history.state.position-e:-1)+t}const nh=new Map;function $$(t,e){nh.set(t,e)}function T$(t){const e=nh.get(t);return nh.delete(t),e}let N$=()=>location.protocol+"//"+location.host;function Dg(t,e){const{pathname:n,search:r,hash:s}=e,o=t.indexOf("#");if(o>-1){let a=s.includes(t.slice(o))?t.slice(o).length:1,u=s.slice(a);return u[0]!=="/"&&(u="/"+u),zd(u,"")}return zd(n,t)+r+s}function E$(t,e,n,r){let s=[],o=[],i=null;const a=({state:f})=>{const d=Dg(t,location),m=n.value,x=e.value;let g=0;if(f){if(n.value=d,e.value=f,i&&i===m){i=null;return}g=x?f.position-x.position:0}else r(d);s.forEach(y=>{y(n.value,m,{delta:g,type:Ja.pop,direction:g?g>0?za.forward:za.back:za.unknown})})};function u(){i=n.value}function c(f){s.push(f);const d=()=>{const m=s.indexOf(f);m>-1&&s.splice(m,1)};return o.push(d),d}function l(){const{history:f}=window;f.state&&f.replaceState(ft({},f.state,{scroll:Mc()}),"")}function h(){for(const f of o)f();o=[],window.removeEventListener("popstate",a),window.removeEventListener("beforeunload",l)}return window.addEventListener("popstate",a),window.addEventListener("beforeunload",l,{passive:!0}),{pauseListeners:u,listen:c,destroy:h}}function Hd(t,e,n,r=!1,s=!1){return{back:t,current:e,forward:n,replaced:r,position:window.history.length,scroll:s?Mc():null}}function _$(t){const{history:e,location:n}=window,r={value:Dg(t,n)},s={value:e.state};s.value||o(r.value,{back:null,current:r.value,forward:null,position:e.length-1,replaced:!0,scroll:null},!0);function o(u,c,l){const h=t.indexOf("#"),f=h>-1?(n.host&&document.querySelector("base")?t:t.slice(h))+u:N$()+t+u;try{e[l?"replaceState":"pushState"](c,"",f),s.value=c}catch(d){console.error(d),n[l?"replace":"assign"](f)}}function i(u,c){const l=ft({},e.state,Hd(s.value.back,u,s.value.forward,!0),c,{position:s.value.position});o(u,l,!0),r.value=u}function a(u,c){const l=ft({},s.value,e.state,{forward:u,scroll:Mc()});o(l.current,l,!0);const h=ft({},Hd(r.value,u,null),{position:l.position+1},c);o(u,h,!1),r.value=u}return{location:r,state:s,push:a,replace:i}}function I$(t){t=b$(t);const e=_$(t),n=E$(t,e.state,e.location,e.replace);function r(o,i=!0){i||n.pauseListeners(),history.go(o)}const s=ft({location:"",base:t,go:r,createHref:w$.bind(null,t)},e,n);return Object.defineProperty(s,"location",{enumerable:!0,get:()=>e.location.value}),Object.defineProperty(s,"state",{enumerable:!0,get:()=>e.state.value}),s}function k$(t){return typeof t=="string"||t&&typeof t=="object"}function Pg(t){return typeof t=="string"||typeof t=="symbol"}const Fg=Symbol("");var Kd;(function(t){t[t.aborted=4]="aborted",t[t.cancelled=8]="cancelled",t[t.duplicated=16]="duplicated"})(Kd||(Kd={}));function ji(t,e){return ft(new Error,{type:t,[Fg]:!0},e)}function Ns(t,e){return t instanceof Error&&Fg in t&&(e==null||!!(t.type&e))}const qd="[^/]+?",R$={sensitive:!1,strict:!1,start:!0,end:!0},A$=/[.+*?^${}()[\]/\\]/g;function O$(t,e){const n=ft({},R$,e),r=[];let s=n.start?"^":"";const o=[];for(const c of t){const l=c.length?[]:[90];n.strict&&!c.length&&(s+="/");for(let h=0;h<c.length;h++){const f=c[h];let d=40+(n.sensitive?.25:0);if(f.type===0)h||(s+="/"),s+=f.value.replace(A$,"\\$&"),d+=40;else if(f.type===1){const{value:m,repeatable:x,optional:g,regexp:y}=f;o.push({name:m,repeatable:x,optional:g});const S=y||qd;if(S!==qd){d+=10;try{new RegExp(`(${S})`)}catch(C){throw new Error(`Invalid custom RegExp for param "${m}" (${S}): `+C.message)}}let $=x?`((?:${S})(?:/(?:${S}))*)`:`(${S})`;h||($=g&&c.length<2?`(?:/${$})`:"/"+$),g&&($+="?"),s+=$,d+=20,g&&(d+=-8),x&&(d+=-20),S===".*"&&(d+=-50)}l.push(d)}r.push(l)}if(n.strict&&n.end){const c=r.length-1;r[c][r[c].length-1]+=.7000000000000001}n.strict||(s+="/?"),n.end?s+="$":n.strict&&(s+="(?:/|$)");const i=new RegExp(s,n.sensitive?"":"i");function a(c){const l=c.match(i),h={};if(!l)return null;for(let f=1;f<l.length;f++){const d=l[f]||"",m=o[f-1];h[m.name]=d&&m.repeatable?d.split("/"):d}return h}function u(c){let l="",h=!1;for(const f of t){(!h||!l.endsWith("/"))&&(l+="/"),h=!1;for(const d of f)if(d.type===0)l+=d.value;else if(d.type===1){const{value:m,repeatable:x,optional:g}=d,y=m in c?c[m]:"";if(Jr(y)&&!x)throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);const S=Jr(y)?y.join("/"):y;if(!S)if(g)f.length<2&&(l.endsWith("/")?l=l.slice(0,-1):h=!0);else throw new Error(`Missing required param "${m}"`);l+=S}}return l||"/"}return{re:i,score:r,keys:o,parse:a,stringify:u}}function D$(t,e){let n=0;for(;n<t.length&&n<e.length;){const r=e[n]-t[n];if(r)return r;n++}return t.length<e.length?t.length===1&&t[0]===80?-1:1:t.length>e.length?e.length===1&&e[0]===80?1:-1:0}function Lg(t,e){let n=0;const r=t.score,s=e.score;for(;n<r.length&&n<s.length;){const o=D$(r[n],s[n]);if(o)return o;n++}if(Math.abs(s.length-r.length)===1){if(Xd(r))return 1;if(Xd(s))return-1}return s.length-r.length}function Xd(t){const e=t[t.length-1];return t.length>0&&e[e.length-1]<0}const P$={type:0,value:""},F$=/[a-zA-Z0-9_]/;function L$(t){if(!t)return[[]];if(t==="/")return[[P$]];if(!t.startsWith("/"))throw new Error(`Invalid path "${t}"`);function e(d){throw new Error(`ERR (${n})/"${c}": ${d}`)}let n=0,r=n;const s=[];let o;function i(){o&&s.push(o),o=[]}let a=0,u,c="",l="";function h(){c&&(n===0?o.push({type:0,value:c}):n===1||n===2||n===3?(o.length>1&&(u==="*"||u==="+")&&e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),o.push({type:1,value:c,regexp:l,repeatable:u==="*"||u==="+",optional:u==="*"||u==="?"})):e("Invalid state to consume buffer"),c="")}function f(){c+=u}for(;a<t.length;){if(u=t[a++],u==="\\"&&n!==2){r=n,n=4;continue}switch(n){case 0:u==="/"?(c&&h(),i()):u===":"?(h(),n=1):f();break;case 4:f(),n=r;break;case 1:u==="("?n=2:F$.test(u)?f():(h(),n=0,u!=="*"&&u!=="?"&&u!=="+"&&a--);break;case 2:u===")"?l[l.length-1]=="\\"?l=l.slice(0,-1)+u:n=3:l+=u;break;case 3:h(),n=0,u!=="*"&&u!=="?"&&u!=="+"&&a--,l="";break;default:e("Unknown state");break}}return n===2&&e(`Unfinished custom RegExp for param "${c}"`),h(),i(),s}function B$(t,e,n){const r=O$(L$(t.path),n),s=ft(r,{record:t,parent:e,children:[],alias:[]});return e&&!s.record.aliasOf==!e.record.aliasOf&&e.children.push(s),s}function M$(t,e){const n=[],r=new Map;e=Jd({strict:!1,end:!0,sensitive:!1},e);function s(h){return r.get(h)}function o(h,f,d){const m=!d,x=Qd(h);x.aliasOf=d&&d.record;const g=Jd(e,h),y=[x];if("alias"in h){const C=typeof h.alias=="string"?[h.alias]:h.alias;for(const _ of C)y.push(Qd(ft({},x,{components:d?d.record.components:x.components,path:_,aliasOf:d?d.record:x})))}let S,$;for(const C of y){const{path:_}=C;if(f&&_[0]!=="/"){const L=f.record.path,V=L[L.length-1]==="/"?"":"/";C.path=f.record.path+(_&&V+_)}if(S=B$(C,f,g),d?d.alias.push(S):($=$||S,$!==S&&$.alias.push(S),m&&h.name&&!Zd(S)&&i(h.name)),Bg(S)&&u(S),x.children){const L=x.children;for(let V=0;V<L.length;V++)o(L[V],S,d&&d.children[V])}d=d||S}return $?()=>{i($)}:Wa}function i(h){if(Pg(h)){const f=r.get(h);f&&(r.delete(h),n.splice(n.indexOf(f),1),f.children.forEach(i),f.alias.forEach(i))}else{const f=n.indexOf(h);f>-1&&(n.splice(f,1),h.record.name&&r.delete(h.record.name),h.children.forEach(i),h.alias.forEach(i))}}function a(){return n}function u(h){const f=W$(h,n);n.splice(f,0,h),h.record.name&&!Zd(h)&&r.set(h.record.name,h)}function c(h,f){let d,m={},x,g;if("name"in h&&h.name){if(d=r.get(h.name),!d)throw ji(1,{location:h});g=d.record.name,m=ft(Yd(f.params,d.keys.filter($=>!$.optional).concat(d.parent?d.parent.keys.filter($=>$.optional):[]).map($=>$.name)),h.params&&Yd(h.params,d.keys.map($=>$.name))),x=d.stringify(m)}else if(h.path!=null)x=h.path,d=n.find($=>$.re.test(x)),d&&(m=d.parse(x),g=d.record.name);else{if(d=f.name?r.get(f.name):n.find($=>$.re.test(f.path)),!d)throw ji(1,{location:h,currentLocation:f});g=d.record.name,m=ft({},f.params,h.params),x=d.stringify(m)}const y=[];let S=d;for(;S;)y.unshift(S.record),S=S.parent;return{name:g,path:x,params:m,matched:y,meta:U$(y)}}t.forEach(h=>o(h));function l(){n.length=0,r.clear()}return{addRoute:o,resolve:c,removeRoute:i,clearRoutes:l,getRoutes:a,getRecordMatcher:s}}function Yd(t,e){const n={};for(const r of e)r in t&&(n[r]=t[r]);return n}function Qd(t){const e={path:t.path,redirect:t.redirect,name:t.name,meta:t.meta||{},aliasOf:t.aliasOf,beforeEnter:t.beforeEnter,props:V$(t),children:t.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in t?t.components||null:t.component&&{default:t.component}};return Object.defineProperty(e,"mods",{value:{}}),e}function V$(t){const e={},n=t.props||!1;if("component"in t)e.default=n;else for(const r in t.components)e[r]=typeof n=="object"?n[r]:n;return e}function Zd(t){for(;t;){if(t.record.aliasOf)return!0;t=t.parent}return!1}function U$(t){return t.reduce((e,n)=>ft(e,n.meta),{})}function Jd(t,e){const n={};for(const r in t)n[r]=r in e?e[r]:t[r];return n}function W$(t,e){let n=0,r=e.length;for(;n!==r;){const o=n+r>>1;Lg(t,e[o])<0?r=o:n=o+1}const s=z$(t);return s&&(r=e.lastIndexOf(s,r-1)),r}function z$(t){let e=t;for(;e=e.parent;)if(Bg(e)&&Lg(t,e)===0)return e}function Bg({record:t}){return!!(t.name||t.components&&Object.keys(t.components).length||t.redirect)}function G$(t){const e={};if(t===""||t==="?")return e;const r=(t[0]==="?"?t.slice(1):t).split("&");for(let s=0;s<r.length;++s){const o=r[s].replace(Ig," "),i=o.indexOf("="),a=Za(i<0?o:o.slice(0,i)),u=i<0?null:Za(o.slice(i+1));if(a in e){let c=e[a];Jr(c)||(c=e[a]=[c]),c.push(u)}else e[a]=u}return e}function ep(t){let e="";for(let n in t){const r=t[n];if(n=l$(n),r==null){r!==void 0&&(e+=(e.length?"&":"")+n);continue}(Jr(r)?r.map(o=>o&&th(o)):[r&&th(r)]).forEach(o=>{o!==void 0&&(e+=(e.length?"&":"")+n,o!=null&&(e+="="+o))})}return e}function j$(t){const e={};for(const n in t){const r=t[n];r!==void 0&&(e[n]=Jr(r)?r.map(s=>s==null?null:""+s):r==null?r:""+r)}return e}const H$=Symbol(""),tp=Symbol(""),gf=Symbol(""),Mg=Symbol(""),rh=Symbol("");function Ta(){let t=[];function e(r){return t.push(r),()=>{const s=t.indexOf(r);s>-1&&t.splice(s,1)}}function n(){t=[]}return{add:e,list:()=>t.slice(),reset:n}}function ro(t,e,n,r,s,o=i=>i()){const i=r&&(r.enterCallbacks[s]=r.enterCallbacks[s]||[]);return()=>new Promise((a,u)=>{const c=f=>{f===!1?u(ji(4,{from:n,to:e})):f instanceof Error?u(f):k$(f)?u(ji(2,{from:e,to:f})):(i&&r.enterCallbacks[s]===i&&typeof f=="function"&&i.push(f),a())},l=o(()=>t.call(r&&r.instances[s],e,n,c));let h=Promise.resolve(l);t.length<3&&(h=h.then(c)),h.catch(f=>u(f))})}function Cl(t,e,n,r,s=o=>o()){const o=[];for(const i of t)for(const a in i.components){let u=i.components[a];if(!(e!=="beforeRouteEnter"&&!i.instances[a]))if(Eg(u)){const l=(u.__vccOpts||u)[e];l&&o.push(ro(l,n,r,i,a,s))}else{let c=u();o.push(()=>c.then(l=>{if(!l)throw new Error(`Couldn't resolve component "${a}" at "${i.path}"`);const h=JC(l)?l.default:l;i.mods[a]=l,i.components[a]=h;const d=(h.__vccOpts||h)[e];return d&&ro(d,n,r,i,a,s)()}))}}return o}function np(t){const e=Ds(gf),n=Ds(Mg),r=jr(()=>{const u=zo(t.to);return e.resolve(u)}),s=jr(()=>{const{matched:u}=r.value,{length:c}=u,l=u[c-1],h=n.matched;if(!l||!h.length)return-1;const f=h.findIndex(Gi.bind(null,l));if(f>-1)return f;const d=rp(u[c-2]);return c>1&&rp(l)===d&&h[h.length-1].path!==d?h.findIndex(Gi.bind(null,u[c-2])):f}),o=jr(()=>s.value>-1&&Y$(n.params,r.value.params)),i=jr(()=>s.value>-1&&s.value===n.matched.length-1&&Og(n.params,r.value.params));function a(u={}){return X$(u)?e[zo(t.replace)?"replace":"push"](zo(t.to)).catch(Wa):Promise.resolve()}return{route:r,href:jr(()=>r.value.href),isActive:o,isExactActive:i,navigate:a}}const K$=Qm({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:np,setup(t,{slots:e}){const n=Rc(np(t)),{options:r}=Ds(gf),s=jr(()=>({[sp(t.activeClass,r.linkActiveClass,"router-link-active")]:n.isActive,[sp(t.exactActiveClass,r.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{const o=e.default&&e.default(n);return t.custom?o:Cg("a",{"aria-current":n.isExactActive?t.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:s.value},o)}}}),q$=K$;function X$(t){if(!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)&&!t.defaultPrevented&&!(t.button!==void 0&&t.button!==0)){if(t.currentTarget&&t.currentTarget.getAttribute){const e=t.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return t.preventDefault&&t.preventDefault(),!0}}function Y$(t,e){for(const n in e){const r=e[n],s=t[n];if(typeof r=="string"){if(r!==s)return!1}else if(!Jr(s)||s.length!==r.length||r.some((o,i)=>o!==s[i]))return!1}return!0}function rp(t){return t?t.aliasOf?t.aliasOf.path:t.path:""}const sp=(t,e,n)=>t??e??n,Q$=Qm({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(t,{attrs:e,slots:n}){const r=Ds(rh),s=jr(()=>t.route||r.value),o=Ds(tp,0),i=jr(()=>{let c=zo(o);const{matched:l}=s.value;let h;for(;(h=l[c])&&!h.components;)c++;return c}),a=jr(()=>s.value.matched[i.value]);Gu(tp,jr(()=>i.value+1)),Gu(H$,a),Gu(rh,s);const u=Kl();return Bi(()=>[u.value,a.value,t.name],([c,l,h],[f,d,m])=>{l&&(l.instances[h]=c,d&&d!==l&&c&&c===f&&(l.leaveGuards.size||(l.leaveGuards=d.leaveGuards),l.updateGuards.size||(l.updateGuards=d.updateGuards))),c&&l&&(!d||!Gi(l,d)||!f)&&(l.enterCallbacks[h]||[]).forEach(x=>x(c))},{flush:"post"}),()=>{const c=s.value,l=t.name,h=a.value,f=h&&h.components[l];if(!f)return op(n.default,{Component:f,route:c});const d=h.props[l],m=d?d===!0?c.params:typeof d=="function"?d(c):d:null,g=Cg(f,ft({},m,e,{onVnodeUnmounted:y=>{y.component.isUnmounted&&(h.instances[l]=null)},ref:u}));return op(n.default,{Component:g,route:c})||g}}});function op(t,e){if(!t)return null;const n=t(e);return n.length===1?n[0]:n}const Z$=Q$;function J$(t){const e=M$(t.routes,t),n=t.parseQuery||G$,r=t.stringifyQuery||ep,s=t.history,o=Ta(),i=Ta(),a=Ta(),u=uS(Js);let c=Js;ki&&t.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const l=wl.bind(null,Q=>""+Q),h=wl.bind(null,f$),f=wl.bind(null,Za);function d(Q,be){let ye,Se;return Pg(Q)?(ye=e.getRecordMatcher(Q),Se=be):Se=Q,e.addRoute(Se,ye)}function m(Q){const be=e.getRecordMatcher(Q);be&&e.removeRoute(be)}function x(){return e.getRoutes().map(Q=>Q.record)}function g(Q){return!!e.getRecordMatcher(Q)}function y(Q,be){if(be=ft({},be||u.value),typeof Q=="string"){const D=Sl(n,Q,be.path),H=e.resolve({path:D.path},be),ne=s.createHref(D.fullPath);return ft(D,H,{params:f(H.params),hash:Za(D.hash),redirectedFrom:void 0,href:ne})}let ye;if(Q.path!=null)ye=ft({},Q,{path:Sl(n,Q.path,be.path).path});else{const D=ft({},Q.params);for(const H in D)D[H]==null&&delete D[H];ye=ft({},Q,{params:h(D)}),be.params=h(be.params)}const Se=e.resolve(ye,be),je=Q.hash||"";Se.params=l(f(Se.params));const rt=m$(r,ft({},Q,{hash:c$(je),path:Se.path})),k=s.createHref(rt);return ft({fullPath:rt,hash:je,query:r===ep?j$(Q.query):Q.query||{}},Se,{redirectedFrom:void 0,href:k})}function S(Q){return typeof Q=="string"?Sl(n,Q,u.value.path):ft({},Q)}function $(Q,be){if(c!==Q)return ji(8,{from:be,to:Q})}function C(Q){return V(Q)}function _(Q){return C(ft(S(Q),{replace:!0}))}function L(Q){const be=Q.matched[Q.matched.length-1];if(be&&be.redirect){const{redirect:ye}=be;let Se=typeof ye=="function"?ye(Q):ye;return typeof Se=="string"&&(Se=Se.includes("?")||Se.includes("#")?Se=S(Se):{path:Se},Se.params={}),ft({query:Q.query,hash:Q.hash,params:Se.path!=null?{}:Q.params},Se)}}function V(Q,be){const ye=c=y(Q),Se=u.value,je=Q.state,rt=Q.force,k=Q.replace===!0,D=L(ye);if(D)return V(ft(S(D),{state:typeof D=="object"?ft({},je,D.state):je,force:rt,replace:k}),be||ye);const H=ye;H.redirectedFrom=be;let ne;return!rt&&g$(r,Se,ye)&&(ne=ji(16,{to:H,from:Se}),Bt(Se,Se,!0,!1)),(ne?Promise.resolve(ne):q(H,Se)).catch(J=>Ns(J)?Ns(J,2)?J:Lt(J):Ie(J,H,Se)).then(J=>{if(J){if(Ns(J,2))return V(ft({replace:k},S(J.to),{state:typeof J.to=="object"?ft({},je,J.to.state):je,force:rt}),be||H)}else J=fe(H,Se,!0,k,je);return Z(H,Se,J),J})}function z(Q,be){const ye=$(Q,be);return ye?Promise.reject(ye):Promise.resolve()}function K(Q){const be=Dn.values().next().value;return be&&typeof be.runWithContext=="function"?be.runWithContext(Q):Q()}function q(Q,be){let ye;const[Se,je,rt]=eT(Q,be);ye=Cl(Se.reverse(),"beforeRouteLeave",Q,be);for(const D of Se)D.leaveGuards.forEach(H=>{ye.push(ro(H,Q,be))});const k=z.bind(null,Q,be);return ye.push(k),Wt(ye).then(()=>{ye=[];for(const D of o.list())ye.push(ro(D,Q,be));return ye.push(k),Wt(ye)}).then(()=>{ye=Cl(je,"beforeRouteUpdate",Q,be);for(const D of je)D.updateGuards.forEach(H=>{ye.push(ro(H,Q,be))});return ye.push(k),Wt(ye)}).then(()=>{ye=[];for(const D of rt)if(D.beforeEnter)if(Jr(D.beforeEnter))for(const H of D.beforeEnter)ye.push(ro(H,Q,be));else ye.push(ro(D.beforeEnter,Q,be));return ye.push(k),Wt(ye)}).then(()=>(Q.matched.forEach(D=>D.enterCallbacks={}),ye=Cl(rt,"beforeRouteEnter",Q,be,K),ye.push(k),Wt(ye))).then(()=>{ye=[];for(const D of i.list())ye.push(ro(D,Q,be));return ye.push(k),Wt(ye)}).catch(D=>Ns(D,8)?D:Promise.reject(D))}function Z(Q,be,ye){a.list().forEach(Se=>K(()=>Se(Q,be,ye)))}function fe(Q,be,ye,Se,je){const rt=$(Q,be);if(rt)return rt;const k=be===Js,D=ki?history.state:{};ye&&(Se||k?s.replace(Q.fullPath,ft({scroll:k&&D&&D.scroll},je)):s.push(Q.fullPath,je)),u.value=Q,Bt(Q,be,ye,k),Lt()}let xe;function $e(){xe||(xe=s.listen((Q,be,ye)=>{if(!Pn.listening)return;const Se=y(Q),je=L(Se);if(je){V(ft(je,{replace:!0}),Se).catch(Wa);return}c=Se;const rt=u.value;ki&&$$(jd(rt.fullPath,ye.delta),Mc()),q(Se,rt).catch(k=>Ns(k,12)?k:Ns(k,2)?(V(k.to,Se).then(D=>{Ns(D,20)&&!ye.delta&&ye.type===Ja.pop&&s.go(-1,!1)}).catch(Wa),Promise.reject()):(ye.delta&&s.go(-ye.delta,!1),Ie(k,Se,rt))).then(k=>{k=k||fe(Se,rt,!1),k&&(ye.delta&&!Ns(k,8)?s.go(-ye.delta,!1):ye.type===Ja.pop&&Ns(k,20)&&s.go(-1,!1)),Z(Se,rt,k)}).catch(Wa)}))}let Te=Ta(),ke=Ta(),Ee;function Ie(Q,be,ye){Lt(Q);const Se=ke.list();return Se.length?Se.forEach(je=>je(Q,be,ye)):console.error(Q),Promise.reject(Q)}function Je(){return Ee&&u.value!==Js?Promise.resolve():new Promise((Q,be)=>{Te.add([Q,be])})}function Lt(Q){return Ee||(Ee=!Q,$e(),Te.list().forEach(([be,ye])=>Q?ye(Q):be()),Te.reset()),Q}function Bt(Q,be,ye,Se){const{scrollBehavior:je}=t;if(!ki||!je)return Promise.resolve();const rt=!ye&&T$(jd(Q.fullPath,0))||(Se||!ye)&&history.state&&history.state.scroll||null;return jm().then(()=>je(Q,be,rt)).then(k=>k&&C$(k)).catch(k=>Ie(k,Q,be))}const vt=Q=>s.go(Q);let tn;const Dn=new Set,Pn={currentRoute:u,listening:!0,addRoute:d,removeRoute:m,clearRoutes:e.clearRoutes,hasRoute:g,getRoutes:x,resolve:y,options:t,push:C,replace:_,go:vt,back:()=>vt(-1),forward:()=>vt(1),beforeEach:o.add,beforeResolve:i.add,afterEach:a.add,onError:ke.add,isReady:Je,install(Q){const be=this;Q.component("RouterLink",q$),Q.component("RouterView",Z$),Q.config.globalProperties.$router=be,Object.defineProperty(Q.config.globalProperties,"$route",{enumerable:!0,get:()=>zo(u)}),ki&&!tn&&u.value===Js&&(tn=!0,C(s.location).catch(je=>{}));const ye={};for(const je in Js)Object.defineProperty(ye,je,{get:()=>u.value[je],enumerable:!0});Q.provide(gf,be),Q.provide(Mg,Vm(ye)),Q.provide(rh,u);const Se=Q.unmount;Dn.add(Q),Q.unmount=function(){Dn.delete(Q),Dn.size<1&&(c=Js,xe&&xe(),xe=null,u.value=Js,tn=!1,Ee=!1),Se()}}};function Wt(Q){return Q.reduce((be,ye)=>be.then(()=>K(ye)),Promise.resolve())}return Pn}function eT(t,e){const n=[],r=[],s=[],o=Math.max(e.matched.length,t.matched.length);for(let i=0;i<o;i++){const a=e.matched[i];a&&(t.matched.find(c=>Gi(c,a))?r.push(a):n.push(a));const u=t.matched[i];u&&(e.matched.find(c=>Gi(c,u))||s.push(u))}return[n,r,s]}class tT{constructor(){this.undoStack=[],this.state={homeScore:0,guestScore:0,homeGame:0,guestGame:0,homeSet:0,guestSet:0,homeService:!1,guestService:!1,homeFirstService:!1}}capturePoint(){this.undoStack.push(JSON.stringify(this.state))}undo(){var n;if(this.undoStack.length===1)return;this.undoStack.pop();const e=(n=this.undoStack)==null?void 0:n[this.undoStack.length-1];e&&(this.state=JSON.parse(e))}changeServiceGame(){this.state.homeService?this.setGuestService():this.setHomeService()}changeServiceSet(){this.state.homeFirstService?(this.setGuestService(),this.state.homeFirstService=!1):(this.setHomeService(),this.state.homeFirstService=!0)}addGuestScore(){this.state.guestSet!==3&&(this.state.guestScore!==3?(this.state.guestScore++,this.capturePoint()):this.state.guestGame!==5?this.addGuestGame():this.addGuestSet())}addHomeScore(){this.state.homeSet!==3&&(this.state.homeScore!==3?(this.state.homeScore++,this.capturePoint()):this.state.homeGame!==5?this.addHomeGame():this.addHomeSet())}addGuestGame(){this.state.guestGame++,this.resetScore(),this.changeServiceGame(),this.capturePoint()}addHomeGame(){this.state.homeGame++,this.resetScore(),this.changeServiceGame(),this.capturePoint()}addGuestSet(){this.state.guestSet++,this.resetScoreGame(),this.resetScore(),this.changeServiceSet(),this.capturePoint()}addHomeSet(){this.state.homeSet++,this.resetScoreGame(),this.resetScore(),this.changeServiceSet(),this.capturePoint()}setGuestService(){this.state.guestService=!0,this.state.homeService=!1}setHomeService(){this.state.homeService=!0,this.state.guestService=!1}resetScore(){this.state.homeScore=0,this.state.guestScore=0}resetScoreGame(){this.state.homeGame=0,this.state.guestGame=0}}class nT{constructor(){this.gameNumbers=[[[1,1,1],[1,0,1],[1,0,1],[1,0,1],[1,1,1]],[[1,1,0],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],[[1,1,1],[0,0,1],[1,1,1],[1,0,0],[1,1,1]],[[1,1,1],[0,0,1],[1,1,1],[0,0,1],[1,1,1]],[[1,0,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],[[1,1,1],[1,0,0],[1,1,1],[0,0,1],[1,1,1]],[[1,1,1],[1,0,0],[1,1,1],[1,0,1],[1,1,1]],[[1,1,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],[[1,1,1],[1,0,1],[1,1,1],[1,0,1],[1,1,1]],[[1,1,1],[1,0,1],[1,1,1],[0,0,1],[1,1,1]]],this.scoreNumbers={0:[[1,1,1,0,1,1,1],[1,0,1,0,1,0,1],[1,0,1,0,1,0,1],[1,0,1,0,1,0,1],[1,0,1,0,1,0,1],[1,0,1,0,1,0,1],[1,1,1,0,1,1,1]],15:[[1,1,0,0,1,1,1],[0,1,0,0,1,0,0],[0,1,0,0,1,0,0],[0,1,0,0,1,1,1],[0,1,0,0,0,0,1],[0,1,0,0,0,0,1],[1,1,1,0,1,1,1]],30:[[1,1,1,0,1,1,1],[0,0,1,0,1,0,1],[0,0,1,0,1,0,1],[1,1,1,0,1,0,1],[0,0,1,0,1,0,1],[0,0,1,0,1,0,1],[1,1,1,0,1,1,1]],40:[[1,0,1,0,1,1,1],[1,0,1,0,1,0,1],[1,0,1,0,1,0,1],[1,1,1,0,1,0,1],[0,0,1,0,1,0,1],[0,0,1,0,1,0,1],[0,0,1,0,1,1,1]]},this.letterS=[[1,1],[1,0],[1,1],[0,1],[1,1]],this.letterE=[[1,1],[1,0],[1,1],[1,0],[1,1]],this.letterT=[[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],this.pointsToScore={0:this.scoreNumbers[0],1:this.scoreNumbers[15],2:this.scoreNumbers[30],3:this.scoreNumbers[40]},this.mapSetHome={0:[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],1:[[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1]],2:[[0,0,0,1,1,0,1,1],[0,0,0,1,1,0,1,1]],3:[[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1]]},this.mapSetGuest={0:[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],1:[[1,1,0,0,0,0,0,0],[1,1,0,0,0,0,0,0]],2:[[1,1,0,1,1,0,0,0],[1,1,0,1,1,0,0,0]],3:[[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1]]},this.pixelCanvas=Array.from(Array(16),()=>Array.from(Array(32),()=>0))}gameToPixels(e){return this.drawInPosition(12,10,this.letterS,1),this.drawInPosition(15,10,this.letterE,1),this.drawInPosition(18,10,this.letterT,1),this.drawRect(15,0,2,9,1),this.drawInPosition(2,2,this.pointsToScore[e.state.homeScore],3),this.drawInPosition(23,2,this.pointsToScore[e.state.guestScore],3),this.drawInPosition(11,1,this.gameNumbers[e.state.homeGame],4),this.drawInPosition(18,1,this.gameNumbers[e.state.guestGame],4),this.drawInPosition(1,13,this.mapSetHome[e.state.homeSet],4),this.drawInPosition(23,13,this.mapSetGuest[e.state.guestSet],4),e.state.homeService?(this.drawRect(12,7,1,1,5),this.drawRect(19,7,1,1,0)):(this.drawRect(12,7,1,1,0),this.drawRect(19,7,1,1,5)),this.pixelCanvas}drawInPosition(e,n,r,s){for(let o=n;o<n+r.length;o++)for(let i=e;i<e+r[0].length;i++)r[o-n][i-e]!==0?this.pixelCanvas[o][i]=s:this.pixelCanvas[o][i]=0}drawRect(e,n,r,s,o){for(let i=n;i<n+s;i++)for(let a=e;a<e+r;a++)this.pixelCanvas[i][a]=o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rT=1e-7,sT=1e-4;class oT{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Vg{refCount(e){return er("refCount")}incRef(e){return er("incRef")}timerAvailable(){return!0}time(e){return er("time")}read(e){return er("read")}readSync(e){return er("readSync")}readToGPU(e,n){return er("readToGPU")}numDataIds(){return er("numDataIds")}disposeData(e,n){return er("disposeData")}write(e,n,r){return er("write")}move(e,n,r,s,o){return er("move")}createTensorFromGPUData(e,n,r){return er("createTensorFromGPUData")}memory(){return er("memory")}floatPrecision(){return er("floatPrecision")}epsilon(){return this.floatPrecision()===32?rT:sT}dispose(){return er("dispose")}}function er(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(t,e,n){return Math.max(t,Math.min(e,n))}function yf(t){return t%2===0?t:t+1}function Na(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function iT(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function I(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function yr(t,e,n=""){I(Pt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function ta(t){I(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ae(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function aT(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Pt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Hi(t){return t%1===0}function sh(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Mi(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function ip(t,e=s=>0,n,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t()){s();return}i++;const u=e(i);if(n!=null&&i>=n){o();return}r!=null?r(a,u):setTimeout(a,u)};a()})}function uT(t,e){let n=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function en(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),I(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),I(t.every(r=>Hi(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function xo(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:en(e,t).sort();let i=0;for(let a=0;a<t.length;++a){if(o!=null){if(o[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(o[i]==null||o[i]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),o[i]<=a&&i++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function ho(t,e){return Jt(t,e)}function Jt(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function cT(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function lT(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function hT(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function ic(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function fT(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Vc(t){return typeof t=="string"||t instanceof String}function dT(t){return typeof t=="boolean"}function pT(t){return typeof t=="number"}function mu(t){return Array.isArray(t)?mu(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":pT(t)?"float32":Vc(t)?"string":dT(t)?"bool":"float32"}function oh(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ih(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function an(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Ug(t,e,n,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=n[t+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<o;u++)s[u]=Ug(t+u*a,i,n,r)}return s}function ah(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Ug(0,t,e,n)}function Wg(t,e){const n=fo(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function fo(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function xr(t){t.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function uh(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function xf(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function qo(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ap="tfjsflags";class mT{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=gT,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(qo(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);ap in e&&e[ap].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=xT(s,o)})}}function gT(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(yT(e,r[0],r[1]),r.join("="))),e}function yT(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function xT(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function G(){return zg}let zg=null;function bT(t){zg=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $l;function Gg(){if($l==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");$l=t}return $l}function vT(){const t=Gg();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function bf(t,e){const n=vT();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const jg="Abs",Hg="Acos",Kg="Acosh",vf="Add",qg="AddN",Xg="All",Yg="Any",Qg="ArgMax",Zg="ArgMin",Jg="Asin",ey="Asinh",ty="Atan",ny="Atanh",ry="Atan2",sy="AvgPool",wT="AvgPoolGrad",oy="AvgPool3D",ST="AvgPool3DGrad",iy="BatchMatMul",ay="BatchToSpaceND",uy="Bincount",cy="BitwiseAnd",ly="BroadcastArgs",wf="Cast",hy="Ceil",fy="ClipByValue",dy="Complex",py="ComplexAbs",my="Concat",gy="Conv2D",yy="Conv2DBackpropFilter",xy="Conv2DBackpropInput",by="Conv3D",CT="Conv3DBackpropFilterV2",vy="Conv3DBackpropInputV2",wy="Cos",Sy="Cosh",Cy="Cumprod",$y="Cumsum",Ty="CropAndResize",Ny="DenseBincount",Ey="DepthToSpace",_y="DepthwiseConv2dNative",Iy="DepthwiseConv2dNativeBackpropFilter",ky="DepthwiseConv2dNativeBackpropInput",Ry="Diag",Ay="Dilation2D",Oy="RealDiv",Dy="Einsum",Py="Elu",$T="EluGrad",Fy="Erf",Ly="Equal",By="Exp",My="ExpandDims",Vy="Expm1",Uy="FFT",Wy="Fill",zy="FlipLeftRight",Gy="Floor",jy="FloorDiv",Hy="FusedBatchNorm",Ky="GatherV2",qy="GatherNd",Xy="Greater",Yy="GreaterEqual",Sf="Identity",Qy="IFFT",Zy="Imag",Jy="IsFinite",e0="IsInf",t0="IsNan",n0="LeakyRelu",r0="Less",s0="LessEqual",o0="LinSpace",i0="Log",a0="Log1p",u0="LogicalAnd",c0="LogicalNot",l0="LogicalOr",h0="LRN",TT="LRNGrad",f0="Max",d0="Maximum",p0="MaxPool",NT="MaxPoolGrad",m0="MaxPool3D",ET="MaxPool3DGrad",g0="MaxPoolWithArgmax",y0="Mean",x0="Min",b0="Minimum",v0="MirrorPad",w0="Mod",S0="Multinomial",C0="Multiply",$0="Neg",T0="NotEqual",N0="NonMaxSuppressionV3",E0="NonMaxSuppressionV4",_0="NonMaxSuppressionV5",I0="OnesLike",k0="OneHot",R0="Pack",A0="PadV2",O0="Pow",D0="Prelu",P0="Prod",F0="RaggedGather",L0="RaggedRange",B0="RaggedTensorToTensor",M0="Range",V0="Real",U0="Reciprocal",W0="Relu",z0="Reshape",G0="ResizeNearestNeighbor",_T="ResizeNearestNeighborGrad",j0="ResizeBilinear",IT="ResizeBilinearGrad",H0="Relu6",K0="Reverse",q0="Round",X0="Rsqrt",Y0="ScatterNd",Q0="TensorScatterUpdate",Z0="SearchSorted",J0="Select",ex="Selu",tx="Slice",nx="Sin",rx="Sinh",sx="Sign",ox="Sigmoid",ix="Softplus",ax="Sqrt",ux="Sum",cx="SpaceToBatchND",lx="SplitV",hx="Softmax",fx="SparseFillEmptyRows",dx="SparseReshape",px="SparseSegmentMean",mx="SparseSegmentSum",gx="SparseToDense",yx="SquaredDifference",kT="Square",xx="StaticRegexReplace",bx="StridedSlice",vx="StringNGrams",wx="StringSplit",Sx="StringToHashBucketFast",Cx="Sub",$x="Tan",Tx="Tanh",Cf="Tile",Nx="TopK",Ex="Transform",Ku="Transpose",_x="Unique",Ix="Unpack",kx="UnsortedSegmentSum",Rx="ZerosLike",Ax="Step",ch="FromPixels",Ox="RotateWithOffset",lh="_FusedMatMul",hh="FusedConv2D",fh="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hr(...t){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...t)}function RT(...t){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ac=bf("kernelRegistry",()=>new Map),AT=bf("gradRegistry",()=>new Map);function dh(t,e){const n=Dx(t,e);return ac.get(n)}function up(t){return AT.get(t)}function cp(t){const e=ac.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&n.push(i)}return n}function OT(t){const{kernelName:e,backendName:n}=t,r=Dx(e,n);ac.has(r)&&Hr(`The kernel '${e}' for backend '${n}' is already registered`),ac.set(r,t)}function Dx(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var Rr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Fx(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function DT(t){if(t.__esModule)return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var Lx=$t,Er=null;try{Er=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function $t(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}$t.prototype.__isLong__;Object.defineProperty($t.prototype,"__isLong__",{value:!0});function or(t){return(t&&t.__isLong__)===!0}$t.isLong=or;var lp={},hp={};function ai(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=hp[t],r)?r:(n=Tt(t,(t|0)<0?-1:0,!0),s&&(hp[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=lp[t],r)?r:(n=Tt(t,t<0?-1:0,!1),s&&(lp[t]=n),n))}$t.fromInt=ai;function _r(t,e){if(isNaN(t))return e?Mo:Ir;if(e){if(t<0)return Mo;if(t>=Bx)return Ux}else{if(t<=-dp)return rr;if(t+1>=dp)return Vx}return t<0?_r(-t,e).neg():Tt(t%Ki|0,t/Ki|0,e)}$t.fromNumber=_r;function Tt(t,e,n){return new $t(t,e,n)}$t.fromBits=Tt;var uc=Math.pow;function $f(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return Ir;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return $f(t.substring(1),e,n).neg();for(var s=_r(uc(n,8)),o=Ir,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),u=parseInt(t.substring(i,i+a),n);if(a<8){var c=_r(uc(n,a));o=o.mul(c).add(_r(u))}else o=o.mul(s),o=o.add(_r(u))}return o.unsigned=e,o}$t.fromString=$f;function ts(t,e){return typeof t=="number"?_r(t,e):typeof t=="string"?$f(t,e):Tt(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}$t.fromValue=ts;var fp=65536,PT=1<<24,Ki=fp*fp,Bx=Ki*Ki,dp=Bx/2,pp=ai(PT),Ir=ai(0);$t.ZERO=Ir;var Mo=ai(0,!0);$t.UZERO=Mo;var Di=ai(1);$t.ONE=Di;var Mx=ai(1,!0);$t.UONE=Mx;var ph=ai(-1);$t.NEG_ONE=ph;var Vx=Tt(-1,2147483647,!1);$t.MAX_VALUE=Vx;var Ux=Tt(-1,-1,!0);$t.MAX_UNSIGNED_VALUE=Ux;var rr=Tt(0,-2147483648,!1);$t.MIN_VALUE=rr;var ge=$t.prototype;ge.toInt=function(){return this.unsigned?this.low>>>0:this.low};ge.toNumber=function(){return this.unsigned?(this.high>>>0)*Ki+(this.low>>>0):this.high*Ki+(this.low>>>0)};ge.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(rr)){var n=_r(e),r=this.div(n),s=r.mul(n).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=_r(uc(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),c=i.sub(u.mul(o)).toInt()>>>0,l=c.toString(e);if(i=u,i.isZero())return l+a;for(;l.length<6;)l="0"+l;a=""+l+a}};ge.getHighBits=function(){return this.high};ge.getHighBitsUnsigned=function(){return this.high>>>0};ge.getLowBits=function(){return this.low};ge.getLowBitsUnsigned=function(){return this.low>>>0};ge.getNumBitsAbs=function(){if(this.isNegative())return this.eq(rr)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};ge.isZero=function(){return this.high===0&&this.low===0};ge.eqz=ge.isZero;ge.isNegative=function(){return!this.unsigned&&this.high<0};ge.isPositive=function(){return this.unsigned||this.high>=0};ge.isOdd=function(){return(this.low&1)===1};ge.isEven=function(){return(this.low&1)===0};ge.equals=function(e){return or(e)||(e=ts(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};ge.eq=ge.equals;ge.notEquals=function(e){return!this.eq(e)};ge.neq=ge.notEquals;ge.ne=ge.notEquals;ge.lessThan=function(e){return this.comp(e)<0};ge.lt=ge.lessThan;ge.lessThanOrEqual=function(e){return this.comp(e)<=0};ge.lte=ge.lessThanOrEqual;ge.le=ge.lessThanOrEqual;ge.greaterThan=function(e){return this.comp(e)>0};ge.gt=ge.greaterThan;ge.greaterThanOrEqual=function(e){return this.comp(e)>=0};ge.gte=ge.greaterThanOrEqual;ge.ge=ge.greaterThanOrEqual;ge.compare=function(e){if(or(e)||(e=ts(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};ge.comp=ge.compare;ge.negate=function(){return!this.unsigned&&this.eq(rr)?rr:this.not().add(Di)};ge.neg=ge.negate;ge.add=function(e){or(e)||(e=ts(e));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,c=e.low&65535,l=0,h=0,f=0,d=0;return d+=o+c,f+=d>>>16,d&=65535,f+=s+u,h+=f>>>16,f&=65535,h+=r+a,l+=h>>>16,h&=65535,l+=n+i,l&=65535,Tt(f<<16|d,l<<16|h,this.unsigned)};ge.subtract=function(e){return or(e)||(e=ts(e)),this.add(e.neg())};ge.sub=ge.subtract;ge.multiply=function(e){if(this.isZero())return Ir;if(or(e)||(e=ts(e)),Er){var n=Er.mul(this.low,this.high,e.low,e.high);return Tt(n,Er.get_high(),this.unsigned)}if(e.isZero())return Ir;if(this.eq(rr))return e.isOdd()?rr:Ir;if(e.eq(rr))return this.isOdd()?rr:Ir;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(pp)&&e.lt(pp))return _r(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,c=e.low>>>16,l=e.low&65535,h=0,f=0,d=0,m=0;return m+=i*l,d+=m>>>16,m&=65535,d+=o*l,f+=d>>>16,d&=65535,d+=i*c,f+=d>>>16,d&=65535,f+=s*l,h+=f>>>16,f&=65535,f+=o*c,h+=f>>>16,f&=65535,f+=i*u,h+=f>>>16,f&=65535,h+=r*l+s*c+o*u+i*a,h&=65535,Tt(d<<16|m,h<<16|f,this.unsigned)};ge.mul=ge.multiply;ge.divide=function(e){if(or(e)||(e=ts(e)),e.isZero())throw Error("division by zero");if(Er){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?Er.div_u:Er.div_s)(this.low,this.high,e.low,e.high);return Tt(n,Er.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Mo:Ir;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Mo;if(e.gt(this.shru(1)))return Mx;o=Mo}else{if(this.eq(rr)){if(e.eq(Di)||e.eq(ph))return rr;if(e.eq(rr))return Di;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(Ir)?e.isNegative()?Di:ph:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(rr))return this.unsigned?Mo:Ir;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=Ir}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),u=a<=48?1:uc(2,a-48),c=_r(r),l=c.mul(e);l.isNegative()||l.gt(s);)r-=u,c=_r(r,this.unsigned),l=c.mul(e);c.isZero()&&(c=Di),o=o.add(c),s=s.sub(l)}return o};ge.div=ge.divide;ge.modulo=function(e){if(or(e)||(e=ts(e)),Er){var n=(this.unsigned?Er.rem_u:Er.rem_s)(this.low,this.high,e.low,e.high);return Tt(n,Er.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};ge.mod=ge.modulo;ge.rem=ge.modulo;ge.not=function(){return Tt(~this.low,~this.high,this.unsigned)};ge.and=function(e){return or(e)||(e=ts(e)),Tt(this.low&e.low,this.high&e.high,this.unsigned)};ge.or=function(e){return or(e)||(e=ts(e)),Tt(this.low|e.low,this.high|e.high,this.unsigned)};ge.xor=function(e){return or(e)||(e=ts(e)),Tt(this.low^e.low,this.high^e.high,this.unsigned)};ge.shiftLeft=function(e){return or(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Tt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Tt(0,this.low<<e-32,this.unsigned)};ge.shl=ge.shiftLeft;ge.shiftRight=function(e){return or(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Tt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Tt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};ge.shr=ge.shiftRight;ge.shiftRightUnsigned=function(e){if(or(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Tt(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Tt(n,0,this.unsigned):Tt(n>>>e-32,0,this.unsigned)};ge.shru=ge.shiftRightUnsigned;ge.shr_u=ge.shiftRightUnsigned;ge.toSigned=function(){return this.unsigned?Tt(this.low,this.high,!1):this};ge.toUnsigned=function(){return this.unsigned?this:Tt(this.low,this.high,!0)};ge.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};ge.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};ge.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};$t.fromBytes=function(e,n,r){return r?$t.fromBytesLE(e,n):$t.fromBytesBE(e,n)};$t.fromBytesLE=function(e,n){return new $t(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};$t.fromBytesBE=function(e,n){return new $t(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};const Wx=Fx(Lx),FT=Tw({__proto__:null,default:Wx},[Lx]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po=Wx||FT;function Uc(t){return Po.fromString(t,!0,16)}const zx=Uc("c3a5c85c97cb3127"),Do=Uc("b492b66fbe98f273"),En=Uc("9ae16a3b2f90404f");function mh(t){return t.xor(t.shru(47))}function Gx(t,e,n){const r=t.slice(e,e+n);return Po.fromBytes(Array.from(r),!0,!0)}function xt(t,e){return Gx(t,e,8)}function mp(t,e){return Gx(t,e,4)}function Zt(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function uo(t,e,n=Uc("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function LT(t,e,n,r,s,o){s=s.add(t),o=Zt(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(n),o=o.add(Zt(s,44)),[s.add(r),o.add(i)]}function Au(t,e,n,r){return LT(xt(t,e),xt(t,e+8),xt(t,e+16),xt(t,e+24),n,r)}function BT(t,e=t.length){if(e>=8){const n=En.add(e*2),r=xt(t,0).add(En),s=xt(t,e-8),o=Zt(s,37).mul(n).add(r),i=Zt(r,25).add(s).mul(n);return uo(o,i,n)}if(e>=4){const n=En.add(e*2),r=mp(t,0);return uo(r.shl(3).add(e),mp(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],o=n+(r<<8),i=e+(s<<2);return mh(En.mul(o).xor(zx.mul(i))).mul(En)}return En}function MT(t,e=t.length){const n=En.add(e*2),r=xt(t,0).mul(Do),s=xt(t,8),o=xt(t,e-8).mul(n),i=xt(t,e-16).mul(En);return uo(Zt(r.add(s),43).add(Zt(o,30)).add(i),r.add(Zt(s.add(En),18)).add(o),n)}function VT(t,e=t.length){const n=En.add(e*2),r=xt(t,0).mul(En),s=xt(t,8),o=xt(t,e-8).mul(n),i=xt(t,e-16).mul(En),a=Zt(r.add(s),43).add(Zt(o,30)).add(i),u=uo(a,r.add(Zt(s.add(En),18)).add(o),n),c=xt(t,16).mul(n),l=xt(t,24),h=a.add(xt(t,e-32)).mul(n),f=u.add(xt(t,e-24)).mul(n);return uo(Zt(c.add(l),43).add(Zt(h,30)).add(f),c.add(Zt(l.add(r),18)).add(h),n)}function UT(t,e=t.length){const n=Po.fromNumber(81,!0);if(e<=32)return e<=16?BT(t,e):MT(t,e);if(e<=64)return VT(t,e);let r=n,s=n.mul(Do).add(113),o=mh(s.mul(En).add(113)).mul(En),i=[Po.UZERO,Po.UZERO],a=[Po.UZERO,Po.UZERO];r=r.mul(En).add(xt(t,0));let u=0;const c=(e-1>>6)*64,l=c+(e-1&63)-63;do r=Zt(r.add(s).add(i[0]).add(xt(t,u+8)),37).mul(Do),s=Zt(s.add(i[1]).add(xt(t,u+48)),42).mul(Do),r=r.xor(a[1]),s=s.add(i[0]).add(xt(t,u+40)),o=Zt(o.add(a[0]),33).mul(Do),i=Au(t,u,i[1].mul(Do),r.add(a[0])),a=Au(t,u+32,o.add(a[1]),s.add(xt(t,u+16))),[o,r]=[r,o],u+=64;while(u!==c);const h=Do.add(o.and(255).shl(1));return u=l,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Zt(r.add(s).add(i[0]).add(xt(t,u+8)),37).mul(h),s=Zt(s.add(i[1]).add(xt(t,u+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(xt(t,u+40))),o=Zt(o.add(a[0]),33).mul(h),i=Au(t,u,i[1].mul(h),r.add(a[0])),a=Au(t,u+32,o.add(a[1]),s.add(xt(t,u+16))),[o,r]=[r,o],uo(uo(i[0],a[0],h).add(mh(s).mul(zx)).add(o),uo(i[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function na(t,e){return e==="string"?Go(t):Wc([t],e)}function WT(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Wc(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Xo(t)),G().getBool("DEBUG")&&cT(t,e),WT(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Wr(){return G().platform.now()}function Go(t,e="utf-8"){return e=e||"utf-8",G().platform.encode(t,e)}function qi(t,e="utf-8"){return e=e||"utf-8",G().platform.decode(t,e)}function Or(t){return G().platform.isTypedArray!=null?G().platform.isTypedArray(t):Px(t)}function Xo(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||qo(t)||t==null||Or(t)&&n)e.push(t);else if(Array.isArray(t)||Or(t))for(let r=0;r<t.length;++r)Xo(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Xo(t[s],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zT{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new jT)}profileKernel(e,n,r){let s;const o=()=>{s=r()};let i;const a=Wr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();i=Promise.resolve({kernelMs:Wr()-a})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const l=s[c];l.data().then(h=>{GT(h,l.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(u=>{this.logger.logKernelProfile(n,a,u[0],u[1],o,u[2])})})}}function GT(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class jT{logKernelProfile(e,n,r,s,o,i){const a=typeof s=="number"?Mi(`${s}ms`,9):s.error,u=Mi(e,25),c=n.rank,l=n.size,h=Mi(n.shape.toString(),14);let f="";for(const d in o){const m=o[d];if(m!=null){const x=m.shape||n.shape,g=x.length;f+=`${d}: ${g}D ${g>0?x:""} `}}console.log(`%c${u}	%c${a}	%c${c}D ${h}	%c${l}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HT(t,e,n){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<t.length;u++){const c=t[u],l=c.inputs;for(const h in l){const f=l[h];let d=!1;for(let m=0;m<e.length;m++)if(r[f.id]){c.outputs.forEach(x=>r[x.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const o={};o[n.id]=!0;const i={};for(let u=t.length-1;u>=0;u--){const c=t[u],l=c.inputs;for(let h=0;h<c.outputs.length;h++)if(o[c.outputs[h].id]){for(const f in l)o[l[f].id]=!0,i[c.id]=!0;break}}const a=[];for(let u=0;u<t.length;u++){const c=t[u];if(s[c.id]&&i[c.id]){const l={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(l[f]=d)}const h=Object.assign({},c);h.inputs=l,h.outputs=c.outputs,a.push(h)}}return a}function KT(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(u=>{const c=t[u.id];c!=null?i.push(c):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const u in o.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const l=o.inputs[u];if(!Pt(c.shape,l.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(t[l.id]==null)t[l.id]=c;else{const h=t[l.id];t[l.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gp=20,Ea=3,Tl=7;function qT(t,e,n,r){const s=an(e),o=XT(t,e,n,s),i=e.length,a=qu(t,e,n,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(c=>"    "+c).join(`
`)),u.join(`
`)}function XT(t,e,n,r){const s=ae(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,u=n==="complex64"?Ra(t):t;if(a>1)for(let c=0;c<s/o;c++){const l=c*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],ka(u[l+h],0,n).length)}return i}function ka(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(Tl))} + ${parseFloat(t[1].toFixed(Tl))}j`:Vc(t)?r=`'${t}'`:n==="bool"?r=jx(t):r=parseFloat(t.toFixed(Tl)).toString(),Mi(r,e)}function jx(t){return t===0?"false":"true"}function qu(t,e,n,r,s,o=!0){const i=n==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(n==="complex64"){const x=Ra(t);return[ka(x[0],0,n)]}return n==="bool"?[jx(t[0])]:[t[0].toString()]}if(u===1){if(a>gp){const g=Ea*i;let y=Array.from(t.slice(0,g)),S=Array.from(t.slice((a-Ea)*i,a*i));return n==="complex64"&&(y=Ra(y),S=Ra(S)),["["+y.map(($,C)=>ka($,s[C],n)).join(", ")+", ..., "+S.map(($,C)=>ka($,s[a-Ea+C],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ra(t):Array.from(t)).map((g,y)=>ka(g,s[y],n)).join(", ")+"]"]}const c=e.slice(1),l=r.slice(1),h=r[0]*i,f=[];if(a>gp){for(let x=0;x<Ea;x++){const g=x*h,y=g+h;f.push(...qu(t.slice(g,y),c,n,l,s,!1))}f.push("...");for(let x=a-Ea;x<a;x++){const g=x*h,y=g+h;f.push(...qu(t.slice(g,y),c,n,l,s,x===a-1))}}else for(let x=0;x<a;x++){const g=x*h,y=g+h;f.push(...qu(t.slice(g,y),c,n,l,s,x===a-1))}const d=u===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let x=1;x<f.length-1;x++)f[x]=" "+f[x]+d;let m=`,
`;for(let x=2;x<u;x++)m+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(o?"":m),f}function Ra(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xi{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=ae(e),r!=null){const s=r.length;I(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Jt(n,this.size),this.strides=an(e)}set(e,...n){n.length===0&&(n=[0]),I(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return zr().makeTensor(this.values,this.shape,this.dtype)}}let zr=null,Ri=null;function YT(t){zr=t}function QT(t){Ri=t}class Yt{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=ae(e),this.strides=an(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ri.buffer(this.shape,this.dtype,e)}bufferSync(){return Ri.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ah(this.shape,e,this.dtype==="complex64")}arraySync(){return ah(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=zr().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>qi(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),zr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=zr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>qi(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await zr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),zr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ri.print(this,e)}clone(){return this.throwIfDisposed(),Ri.clone(this)}toString(e=!1){const n=this.dataSync();return qT(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ri.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),zr().makeVariable(this,e,n,r)}}Object.defineProperty(Yt,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function Hx(){return bf("Tensor",()=>Yt)}Hx();class cc extends Yt{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Pt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);zr().disposeTensor(this),this.dataId=e.dataId,zr().incRef(this,null)}dispose(){zr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(cc,Symbol.hasInstance,{value:t=>t instanceof Yt&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yp;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(yp||(yp={}));var gh;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(gh||(gh={}));var yh;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(yh||(yh={}));var xh;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(xh||(xh={}));var bh;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(bh||(bh={}));const ZT={float32:xh,int32:gh,bool:yh,complex64:bh};function xs(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return ZT[t][e]}function Tf(t){return xs(t,"int32")}function Kx(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function qx(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ut(t,e){if(t.dtype===e.dtype)return[t,e];const n=xs(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function JT(t,e){I(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function Xx(t){const e=[];return Yx(t,e,new Set),e}function Yx(t,e,n){if(t==null)return;if(t instanceof Yt){e.push(t);return}if(!e2(t))return;const r=t;for(const s in r){const o=r[s];n.has(o)||(n.add(o),Yx(o,e,n))}}function e2(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(t){return t.kernelName!=null}class xp{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Yi{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new xp}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(Hr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new zT(this.backendInstance),!0}setupRegisteredKernels(){cp(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cp(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Vg)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Hr(`Initialization of backend ${e} failed`),Hr(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Hr(`Initialization of backend ${e} failed`),Hr(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Yi.nextTensorId++}nextVariableId(){return Yi.nextVariableId++}clone(e){const n=B.runKernel(Sf,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",u={x:i},c={dtype:a};return B.runKernel(wf,u,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(dh(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let o=0;r.forEach(u=>{o+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-n-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const c=Nl(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Nl(e)){const{kernelName:m,inputs:x,attrs:g}=e;this.backendName==null&&this.backend;const y=dh(m,this.backendName);I(y!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),a=()=>{const S=this.backend.numDataIds();u=y.kernelFunc({inputs:x,attrs:g,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,S,$);const C=$.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(m,x,C);r=this.saveTensorsForBackwardMode(_)}return C}}else{const{forwardFunc:m}=e,x=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,x));const y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:l,attrs:h}=e,f=Nl(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(d=this.profiler.profileKernel(c,l,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),n=d.outputs)}),s&&this.addTapeNode(c,l,n,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(m=>l[m]!=null?l[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=up(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(I(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=o.map(c=>n[c]);const u=r.filter((c,l)=>i[l]);return a.concat(u)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&Vc(e[0])&&(o=e.map(u=>Go(u)));const i=s.write(o,n,r),a=new Yt(n,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const u=this.state.tensorInfo.get(i),c=fT(o);this.state.numBytes+=c-u.bytes,u.bytes=c}return a}makeTensorFromDataId(e,n,r,s){r=r||"float32";const o={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:o}=e,i=new Yt(s,o,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new cc(e,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*ic(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof cc||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*ic(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:o},u=up(e);u!=null&&(s=u.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((l,h)=>{if(l==null){const f=r[h],d=fo(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return l}),s(c.length>1?c:c[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=Xx(e),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,n,r,s=!1){if(I(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof Yt,()=>"The result y returned by f() must be a tensor.");const i=HT(this.state.activeTape,n,o);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r??t2(o.shape),KT(a,i,c=>this.tidy(c),n2);const u=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const l of c.saved)l.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return I(oh(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{I(n.every(a=>a instanceof Yt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((a,u)=>{s[u]=a});const o=(a,u)=>(r=e(...n,u),I(r.value instanceof Yt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(oh(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,u)=>{const c=r.gradFunc(a,u),l=Array.isArray(c)?c:[c];I(l.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(l.every(f=>f instanceof Yt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return l.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Wr(),r=await this.backend.time(e);return r.wallMs=Wr()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new xp;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Yi.nextTensorId=0;Yi.nextVariableId=0;function t2(t){const e=Wg(ae(t),"float32");return B.makeTensor(e,t,"float32")}function Qx(){const t=Gg();if(t._tfengine==null){const e=new mT(t);t._tfengine=new Yi(e)}return bT(t._tfengine.ENV),YT(()=>t._tfengine),t._tfengine}const B=Qx();function n2(t,e){const n={a:t,b:e};return B.runKernel(vf,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(){return typeof navigator<"u"&&navigator!=null}function Zx(t){if(t||r2()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Jx(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn=G();Hn.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Hn.registerFlag("IS_BROWSER",()=>Jx());Hn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Hn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Hn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Hn.registerFlag("PROD",()=>!1);Hn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Hn.getBool("DEBUG"));Hn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Hn.registerFlag("IS_TEST",()=>!1);Hn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Hn.getBool("DEBUG"));Hn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Hn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Hn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bo(t,e){let n=t;if(Or(t))return e==="string"?[]:[t.length];if(Kx(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(qx(t))return[t.buffer.size/(e==null?4:ic(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Or(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&e1(t,r,[]),r}function e1(t,e,n){if(n=n||[],!Array.isArray(t)&&!Or(t)){I(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),I(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)e1(t[s],r,n.concat(s))}function bp(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function N(t,e,n,r="numeric"){if(t instanceof Hx())return bp(r,t.dtype,e,n),t;let s=mu(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),bp(r,s,e,n),t==null||!Or(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const o=bo(t,s);!Or(t)&&!Array.isArray(t)&&(t=[t]);const a=s!=="string"?Wc(t,s):Xo(t,[],!0);return B.makeTensor(a,o,s)}function lc(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>N(o,`${e}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t1="__op";function F(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+t1;const s=(...o)=>{B.startScope(n);try{const i=r(...o);return qo(i)&&console.error("Cannot return a Promise inside of tidy."),B.endScope(i),i}catch(i){throw B.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(t,e){const n=N(t,"real","complex"),r=N(e,"imag","complex");yr(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return B.runKernel(dy,s)}const po=F({complex_:s2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vo(t,e,n,r){if(r==null)r=mu(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(qx(t)||Kx(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return B.backend.createTensorFromGPUData(t,e||n,r)}if(!Or(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){xr(e);const s=ae(e),o=ae(n);I(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i],u=i===n.length-1?a!==ae(e.slice(i)):!0;I(n[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Or(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Wc(t,r):Xo(t,[],!0),B.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(t,e,n){const r=bo(t,n);return vo(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ns{static join(e){return new ns(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Or(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,o=new ArrayBuffer(s),i=new Uint8Array(o);let a=0;for(let u=r;u<this.shards.length;u++){const c=this.shards[u],h=e+a-c.start,f=a,m=Math.min(n,c.end)-c.start,x=new Uint8Array(c.buffer,h,m-h);if(i.set(x,f),a+=x.length,n<c.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=o2(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function o2(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,o=e(t[s]);if(o===0)return s;o<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(){return B}function qe(t,e){return B.tidy(t,e)}function Ot(t){Xx(t).forEach(n=>n.dispose())}function fs(t){return B.keep(t)}function i2(){return B.backendName}function a2(t,e,n=1){return B.registerBackend(t,e,n)}function u2(){return B.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=4;async function c2(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],u=Array.isArray(t)?t[i].tensor:t[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const c={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async h=>{const f=await u.bytes(),d=f.reduce((g,y)=>g+y.length,0)+mo*f.length,m=new Uint8Array(d);let x=0;for(let g=0;g<f.length;g++){const y=f[g],S=new Uint8Array(new Uint32Array([y.length]).buffer);m.set(S,x),x+=mo,m.set(y,x),x+=y.length}h(m)});r.push(l)}else r.push(u.data());e!=null&&(c.group=e),n.push(c)}const o=await Promise.all(r);return{data:f2(o),specs:n}}function n1(t,e){const n=new ns(t),r={};let s=0;for(const o of e){const i=l2(o,(a,u)=>n.slice(s+a,s+u));r[o.name]=r1(o,n.slice(s,s+i)),s+=i}return r}function l2(t,e){const n=ae(t.shape);let r;if("quantization"in t){const s=t.quantization;r=Yo[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=mo+new Uint32Array(e(s,s+mo))[0];return s}else r=Yo[t.dtype];return n*r}async function h2(t,e){const n=ae(t.shape);let r;if("quantization"in t){const s=t.quantization;r=Yo[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=mo+new Uint32Array(await e(s,s+mo))[0];return s}else r=Yo[t.dtype];return n*r}function r1(t,e){const n=t.name,r=t.dtype,s=t.shape,o=ae(s);let i,a=0;if("quantization"in t){const u=t.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${t.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=Yo[u.dtype],l=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(l.length);for(let h=0;h<l.length;h++){const f=l[h];i[h]=f*u.scale+u.min}}else if(u.dtype==="float16")i=b2()(l);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(r==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(l.length);for(let h=0;h<l.length;h++){const f=l[h];i[h]=Math.round(f*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*c}else if(r==="string"){const u=ae(t.shape);i=[];for(let c=0;c<u;c++){const l=new Uint32Array(e.slice(a,a+mo))[0];a+=mo;const h=new Uint8Array(e.slice(a,a+l));i.push(h),a+=l}}else{const u=Yo[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const c=new Float32Array(i.length/2),l=new Float32Array(i.length/2);for(let m=0;m<c.length;m++)c[m]=i[m*2],l[m]=i[m*2+1];const h=ms(c,s,"float32"),f=ms(l,s,"float32"),d=po(h,f);return h.dispose(),f.dispose(),d}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*u}return ms(i,s,r)}async function vp(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:o}=await t.read();if(s&&o==null){const a=n-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function s1(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const o of e){const i=await h2(o,async(c,l)=>(s=await vp(r,s,l),s.slice(c,l)));s=await vp(r,s,i);const a=s.slice(0,i);s=s.slice(i);const u=r1(o,a);if(n[o.name]=u,i2()==="webgpu"){const c=u2();"uploadToGPU"in c&&ae(u.shape)>=G().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(u.dataId)}}return n}function f2(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const Nf=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function wp(t){return Nf?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function d2(t){if(Nf)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function p2(t){if(Nf){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function m2(t){return ns.join(t)}function Sp(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function o1(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function i1(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function Ef(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),i1(t,n,r)}function gu(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:wp(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:wp(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new ns(t.weightData).byteLength}}function vh(t){const e=[];for(const n of t)e.push(...n.weights);return e}function g2(){const t=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function y2(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function x2(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function b2(){const t=g2(),e=y2(),n=x2();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],u=t[n[a>>10]+(a&1023)]+e[a>>10];o[i]=u}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class At{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return At.instance==null&&(At.instance=new At),At.instance}static registerSaveRouter(e){At.getInstance().saveRouters.push(e)}static registerLoadRouter(e){At.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return At.getHandlers(e,"save")}static getLoadHandlers(e,n){return At.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?At.getInstance().loadRouters:At.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const v2=t=>At.registerSaveRouter(t),w2=t=>At.registerLoadRouter(t),S2=t=>At.getSaveHandlers(t),C2=(t,e)=>At.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wh="tensorflowjs",Sh=1,Vo="models_store",oo="model_info_store";function a1(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ch(t){const e=t.result;e.createObjectStore(Vo,{keyPath:"modelPath"}),e.createObjectStore(oo,{keyPath:"modelPath"})}class Qo{constructor(e){if(this.indexedDB=a1(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const o=this.indexedDB.open(wh,Sh);o.onupgradeneeded=()=>Ch(o),o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(Vo,"readonly"),c=a.objectStore(Vo).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=l=>(i.close(),s(c.error)),a.oncomplete=()=>i.close()}else{n.weightData=ns.join(n.weightData);const a=gu(n),u=i.transaction(oo,"readwrite");let c=u.objectStore(oo),l;try{l=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return s(f)}let h;l.onsuccess=()=>{h=i.transaction(Vo,"readwrite");const f=h.objectStore(Vo);let d;try{d=f.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(m){return s(m)}d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=m=>{c=u.objectStore(oo);const x=c.delete(this.modelPath);x.onsuccess=()=>(i.close(),s(d.error)),x.onerror=g=>(i.close(),s(d.error))}},l.onerror=f=>(i.close(),s(l.error)),u.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}Qo.URL_SCHEME="indexeddb://";const u1=t=>G().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Qo.URL_SCHEME)?$2(t.slice(Qo.URL_SCHEME.length)):null;At.registerSaveRouter(u1);At.registerLoadRouter(u1);function $2(t){return new Qo(t)}function T2(t){return t.startsWith(Qo.URL_SCHEME)?t.slice(Qo.URL_SCHEME.length):t}class N2{constructor(){this.indexedDB=a1()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(wh,Sh);r.onupgradeneeded=()=>Ch(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(oo,"readonly"),a=o.objectStore(oo).getAll();a.onsuccess=()=>{const u={};for(const c of a.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},a.onerror=u=>(s.close(),n(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=T2(e),new Promise((n,r)=>{const s=this.indexedDB.open(wh,Sh);s.onupgradeneeded=()=>Ch(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(oo,"readwrite"),a=i.objectStore(oo),u=a.get(e);let c;u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const l=a.delete(e),h=()=>{c=o.transaction(Vo,"readwrite");const d=c.objectStore(Vo).delete(e);d.onsuccess=()=>n(u.result.modelArtifactsInfo),d.onerror=m=>r(u.error)};l.onsuccess=h,l.onerror=f=>(h(),o.close(),r(u.error))}},u.onerror=l=>(o.close(),r(u.error)),i.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Os="/",Ai="tensorflowjs_models",c1="info",E2="model_topology",_2="weight_specs",I2="weight_data",k2="model_metadata";function l1(t){return{info:[Ai,t,c1].join(Os),topology:[Ai,t,E2].join(Os),weightSpecs:[Ai,t,_2].join(Os),weightData:[Ai,t,I2].join(Os),modelMetadata:[Ai,t,k2].join(Os)}}function h1(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function R2(t){const e=t.split(Os);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Os)}function A2(t){return t.startsWith(Zo.URL_SCHEME)?t.slice(Zo.URL_SCHEME.length):t}class Zo{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=l1(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=gu(e),o=ns.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,d2(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw h1(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=p2(i),n}}Zo.URL_SCHEME="localstorage://";const f1=t=>G().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Zo.URL_SCHEME)?O2(t.slice(Zo.URL_SCHEME.length)):null;At.registerSaveRouter(f1);At.registerLoadRouter(f1);function O2(t){return new Zo(t)}class D2{constructor(){I(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Ai+Os,r=Os+c1;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){const i=R2(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=A2(e);const n=l1(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return h1(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi="://";class Tn{constructor(){this.managers={}}static getInstance(){return Tn.instance==null&&(Tn.instance=new Tn),Tn.instance}static registerManager(e,n){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Vi)&&(e=e.slice(0,e.indexOf(Vi))),I(e.length>0,()=>"scheme must not be an empty string.");const r=Tn.getInstance();I(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Tn.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Tn.getInstance().managers)}}function Xu(t){if(t.indexOf(Vi)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Tn.getSchemes().join(",")}`);return{scheme:t.split(Vi)[0],path:t.split(Vi)[1]}}async function d1(t,e,n=!1){I(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=At.getLoadHandlers(t);I(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),I(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=At.getSaveHandlers(e);I(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),I(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Xu(t).scheme,u=Xu(t).path,c=a===Xu(t).scheme,l=await s.load();n&&c&&await Tn.getManager(a).removeModel(u);const h=await i.save(l);return n&&!c&&await Tn.getManager(a).removeModel(u),h.modelArtifactsInfo}async function P2(){const t=Tn.getSchemes(),e={};for(const n of t){const r=await Tn.getManager(n).listModels();for(const s in r){const o=n+Vi+s;e[o]=r[s]}}return e}async function F2(t){const e=Xu(t);return Tn.getManager(e.scheme).removeModel(e.path)}async function L2(t,e){return d1(t,e,!1)}async function B2(t,e){return d1(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M2{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Px(e)}}if(G().get("IS_BROWSER")){G().setPlatform("browser",new M2);try{Tn.registerManager(Zo.URL_SCHEME,new D2)}catch{}try{Tn.registerManager(Qo.URL_SCHEME,new N2)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V2={importFetch:()=>require("node-fetch")};let El;class U2{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return G().global.fetch!=null?G().global.fetch(e,n):(El==null&&(El=V2.importFetch()),El(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new U2);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ft(t,e="float32",n){return e=e||"float32",xr(t),new Xi(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2(t,e){const n=N(t,"x","cast");if(!lT(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return B.runKernel(wf,r,s)}const Dt=F({cast_:W2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(t){const n={x:N(t,"x","clone","string_or_numeric")};return B.runKernel(Sf,n)}const co=F({clone_:z2});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Qx();const G2={buffer:Ft,cast:Dt,clone:co,print:p1};QT(G2);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j2(t,e){let n=N(t,"a","add"),r=N(e,"b","add");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(vf,s)}const Fe=F({add_:j2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(t,e){let n=N(t,"a","floorDiv"),r=N(e,"b","floorDiv");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(jy,s)}const m1=F({floorDiv_:H2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2(t,e){let n=N(t,"a","div"),r=N(e,"b","div");if([n,r]=Ut(n,r),n.dtype==="int32"&&r.dtype==="int32")return m1(n,r);const s={a:n,b:r},o={};return B.runKernel(Oy,s,o)}const Xe=F({div_:K2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(t,e){let n=N(t,"a","mul"),r=N(e,"b","mul");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(C0,s)}const he=F({mul_:q2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2(t){const e=N(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return B.runKernel(py,n)}else{const n={x:e};return B.runKernel(jg,n)}}const fr=F({abs_:X2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2(t){const n={x:N(t,"x","acos")};return B.runKernel(Hg,n)}const Q2=F({acos_:Y2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2(t){const n={x:N(t,"x","acosh")};return B.runKernel(Kg,n)}const J2=F({acosh_:Z2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(t){I(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),I(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,o)=>N(s,`tensors${o}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Pt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return B.runKernel(qg,r)}const tN=F({addN_:eN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nN(t,e=null,n=!1){const s={x:N(t,"x","all","bool")},o={axis:e,keepDims:n};return B.runKernel(Xg,s,o)}const rN=F({all_:nN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(t,e=null,n=!1){const s={x:N(t,"x","any","bool")},o={axis:e,keepDims:n};return B.runKernel(Yg,s,o)}const oN=F({any_:sN});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(t,e=0){const r={x:N(t,"x","argMax")},s={axis:e};return B.runKernel(Qg,r,s)}const aN=F({argMax_:iN});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(t,e=0){const r={x:N(t,"x","argMin")},s={axis:e};return B.runKernel(Zg,r,s)}const cN=F({argMin_:uN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(t){const n={x:N(t,"x","asin")};return B.runKernel(Jg,n)}const hN=F({asin_:lN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(t){const n={x:N(t,"x","asinh")};return B.runKernel(ey,n)}const dN=F({asinh_:fN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(t){const n={x:N(t,"x","atan")};return B.runKernel(ty,n)}const mN=F({atan_:pN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(t,e){let n=N(t,"a","atan2"),r=N(e,"b","atan2");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(ry,s)}const yN=F({atan2_:gN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(t){const n={x:N(t,"x","atanh")};return B.runKernel(ny,n)}const bN=F({atanh_:xN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1(t,e,n,r,s="NHWC",o){const i=t[3],a=[...e,i],u=ra(s);return br(t,a,n,o,r,null,null,u)}function ui(t,e,n,r,s,o,i="channelsLast"){const[a,u]=eu(e);let c;if(i==="channelsLast")c=[a,u,t[3],t[3]];else if(i==="channelsFirst")c=[a,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return br(t,c,n,r,s,o,!1,i)}function yu(t,e,n,r,s,o,i="NDHWC"){const[a,u,c]=$h(e);let l,h;if(i==="NDHWC")h="channelsLast",l=[a,u,c,t[4],t[4]];else if(i==="NCDHW")h="channelsFirst",l=[a,u,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return xu(t,l,n,r,s,!1,h,o)}function br(t,e,n,r,s,o,i=!1,a="channelsLast"){let[u,c,l,h]=[-1,-1,-1,-1];if(a==="channelsLast")[u,c,l,h]=t;else if(a==="channelsFirst")[u,h,c,l]=t;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,m]=e,[x,g]=eu(n),[y,S]=eu(r),$=Ui(f,y),C=Ui(d,S),{padInfo:_,outHeight:L,outWidth:V}=SN(s,c,l,x,g,$,C,o,a),z=i?m*h:m;let K;return a==="channelsFirst"?K=[u,z,L,V]:a==="channelsLast"&&(K=[u,L,V,z]),{batchSize:u,dataFormat:a,inHeight:c,inWidth:l,inChannels:h,outHeight:L,outWidth:V,outChannels:z,padInfo:_,strideHeight:x,strideWidth:g,filterHeight:f,filterWidth:d,effectiveFilterHeight:$,effectiveFilterWidth:C,dilationHeight:y,dilationWidth:S,inShape:t,outShape:K,filterShape:e}}function xu(t,e,n,r,s,o=!1,i="channelsLast",a){let[u,c,l,h,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,h,f]=t;else if(i==="channelsFirst")[u,f,c,l,h]=t;else throw new Error(`Unknown dataFormat ${i}`);const[d,m,x,,g]=e,[y,S,$]=$h(n),[C,_,L]=$h(r),V=Ui(d,C),z=Ui(m,_),K=Ui(x,L),{padInfo:q,outDepth:Z,outHeight:fe,outWidth:xe}=CN(s,c,l,h,y,S,$,V,z,K,a),$e=o?g*f:g;let Te;return i==="channelsFirst"?Te=[u,$e,Z,fe,xe]:i==="channelsLast"&&(Te=[u,Z,fe,xe,$e]),{batchSize:u,dataFormat:i,inDepth:c,inHeight:l,inWidth:h,inChannels:f,outDepth:Z,outHeight:fe,outWidth:xe,outChannels:$e,padInfo:q,strideDepth:y,strideHeight:S,strideWidth:$,filterDepth:d,filterHeight:m,filterWidth:x,effectiveFilterDepth:V,effectiveFilterHeight:z,effectiveFilterWidth:K,dilationDepth:C,dilationHeight:_,dilationWidth:L,inShape:t,outShape:Te,filterShape:e}}function vN(t,e,n,r,s){r==null&&(r=_f(t,e,n));const o=t[0],i=t[1],a=tu((o-e+2*r)/n+1,s),u=tu((i-e+2*r)/n+1,s);return[a,u]}function wN(t,e,n,r,s,o){s==null&&(s=_f(t,e[0],r[0]));const i=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*s>=e[a]&&(i[a]=tu((t[a]-e[a]+2*s)/r[a]+1,o));return i}function _f(t,e,n,r=1){const s=Ui(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function eu(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function $h(t){return typeof t=="number"?[t,t,t]:t}function Ui(t,e){return e<=1?t:t+(t-1)*(e-1)}function SN(t,e,n,r,s,o,i,a,u){let c,l,h;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const d=vN([e,n],o,r,t,a);l=d[0],h=d[1]}else if(t==="same"){l=Math.ceil(e/r),h=Math.ceil(n/s);const f=Math.max(0,(l-1)*r+o-e),d=Math.max(0,(h-1)*s+i-n),m=Math.floor(f/2),x=f-m,g=Math.floor(d/2),y=d-g;c={top:m,bottom:x,left:g,right:y,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-o+1)/r),h=Math.ceil((n-i+1)/s);else if(typeof t=="object"){const f=u==="channelsLast"?t[1][0]:t[2][0],d=u==="channelsLast"?t[1][1]:t[2][1],m=u==="channelsLast"?t[2][0]:t[3][0],x=u==="channelsLast"?t[2][1]:t[3][1];c={top:f,bottom:d,left:m,right:x,type:f===0&&d===0&&m===0&&x===0?"VALID":"EXPLICIT"},l=tu((e-o+f+d)/r+1,a),h=tu((n-i+m+x)/s+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:l,outWidth:h}}function CN(t,e,n,r,s,o,i,a,u,c,l){let h,f,d,m;if(t==="valid"&&(t=0),typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const g=wN([e,n,r,1],[a,u,c],1,[s,o,i],t,l);f=g[0],d=g[1],m=g[2]}else if(t==="same"){f=Math.ceil(e/s),d=Math.ceil(n/o),m=Math.ceil(r/i);const x=(f-1)*s+a-e,g=(d-1)*o+u-n,y=(m-1)*i+c-r,S=Math.floor(x/2),$=x-S,C=Math.floor(g/2),_=g-C,L=Math.floor(y/2),V=y-L;h={top:C,bottom:_,left:L,right:V,front:S,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:f,outHeight:d,outWidth:m}}function tu(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function nu(t){const[e,n,r]=eu(t);return e===1&&n===1&&r===1}function ir(t,e){return nu(t)||nu(e)}function Jo(t){return eu(t).every(e=>e>0)}function ra(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Dr(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")I(Hi(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{I(Hi(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(t,e){const r={x:N(t,"x","reshape","string_or_numeric")},s={shape:e};return B.runKernel(z0,r,s)}const ee=F({reshape_:$N});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(t,e,n,r,s){const o=N(t,"x","avgPool","float32"),i=1;I(ir(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o,u=!1;o.rank===3&&(u=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Dr("avgPool",r,s);const c={x:a},l={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let h=B.runKernel(sy,c,l);return h=Dt(h,o.dtype),u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const y1=F({avgPool_:TN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(t,e,n,r,s,o="NDHWC"){const i=N(t,"x","avgPool3d","float32");let a=i,u=!1;i.rank===4&&(u=!0,a=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),I(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Dr("avgPool3d",r,s);const c={x:a},l={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o};let h=B.runKernel(oy,c,l);return h=Dt(h,a.dtype),u?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const EN=F({avgPool3d_:NN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(t,e=0){I(t.length>=1,()=>"Pass at least one tensor to concat");const n=lc(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return co(n[0]);const r=n,s={axis:e};return B.runKernel(my,r,s)}const un=F({concat_:_N});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(t,e,n=!1,r=!1){let s=N(t,"a","matMul"),o=N(e,"b","matMul");[s,o]=Ut(s,o);const i={a:s,b:o},a={transposeA:n,transposeB:r};return B.runKernel(iy,i,a)}const dt=F({matMul_:IN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(t){const n={x:N(t,"x","sigmoid","float32")};return B.runKernel(ox,n)}const jo=F({sigmoid_:kN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(t,e,n){const r=N(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:n};return B.runKernel(tx,s,o)}const We=F({slice_:RN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(t){const n={x:N(t,"x","tanh","float32")};return B.runKernel(Tx,n)}const Th=F({tanh_:AN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(t,e,n,r,s,o){const i=N(t,"forgetBias","basicLSTMCell"),a=N(e,"lstmKernel","basicLSTMCell"),u=N(n,"lstmBias","basicLSTMCell"),c=N(r,"data","basicLSTMCell"),l=N(s,"c","basicLSTMCell"),h=N(o,"h","basicLSTMCell"),f=un([c,h],1),d=dt(f,a),m=Fe(d,u),x=m.shape[0],g=m.shape[1]/4,y=[x,g],S=We(m,[0,0],y),$=We(m,[0,g],y),C=We(m,[0,g*2],y),_=We(m,[0,g*3],y),L=Fe(he(jo(S),Th($)),he(l,jo(Fe(i,C)))),V=he(Th(L),jo(_));return[L,V]}const DN=F({basicLSTMCell_:ON});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(t,e,n){const r=N(t,"x","batchToSpaceND"),s=e.reduce((a,u)=>a*u);I(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),I(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),I(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:n};return B.runKernel(ay,o,i)}const x1=F({batchToSpaceND_:PN});function FN(t){let e;return t.rank===0||t.rank===1?e=ee(t,[1,1,1,t.size]):t.rank===2?e=ee(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(t,e,n,r,s,o){o==null&&(o=.001);const i=N(t,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(n,"variance","batchNorm");let c;s!=null&&(c=N(s,"scale","batchNorm"));let l;r!=null&&(l=N(r,"offset","batchNorm")),I(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:FN(i),scale:c,offset:l,mean:a,variance:u},d={varianceEpsilon:o},m=B.runKernel(Hy,f,d);return ee(m,i.shape)}const zc=F({batchNorm_:LN});function BN(t,e,n,r,s,o){const i=N(t,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(n,"variance","batchNorm");let c;s!=null&&(c=N(s,"scale","batchNorm"));let l;return r!=null&&(l=N(r,"offset","batchNorm")),I(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),I(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),I(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&I(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),zc(i,a,u,l,c,o)}const MN=F({batchNorm2d_:BN});function VN(t,e,n,r,s,o){const i=N(t,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(n,"variance","batchNorm");let c;s!=null&&(c=N(s,"scale","batchNorm"));let l;return r!=null&&(l=N(r,"offset","batchNorm")),I(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),I(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),I(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&I(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),zc(i,a,u,l,c,o)}const UN=F({batchNorm3d_:VN});function WN(t,e,n,r,s,o){const i=N(t,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(n,"variance","batchNorm");let c;s!=null&&(c=N(s,"scale","batchNorm"));let l;return r!=null&&(l=N(r,"offset","batchNorm")),I(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),I(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),I(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&I(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),zc(i,a,u,l,c,o)}const zN=F({batchNorm4d_:WN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GN(t,e,n){const r=N(t,"x","bincount"),s=N(e,"weights","bincount");I(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),I(n>=0,()=>`size must be non-negative, but got ${n}.`),I(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:n};return B.runKernel(uy,o,i)}const b1=F({bincount_:GN});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(t,e){const n=N(t,"x","bitwiseAnd"),r=N(e,"y","bitwiseAnd");if(!Pt(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return B.runKernel(cy,s)}const HN=F({bitwiseAnd_:jN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(t,e){const n=N(t,"s0","broadcastArgs","int32"),r=N(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return B.runKernel(ly,s)}const qN=F({broadcastArgs_:KN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XN(t,e){let n=N(t,"broadcastTo","x");const r=n.shape;if(xr(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=ee(n,c)}const s=n.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return co(n);const a={x:n},u={reps:o};return B.runKernel(Cf,a,u)}const Ga=F({broadcastTo_:XN});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(t){const n={x:N(t,"x","ceil","float32")};return B.runKernel(hy,n)}const QN=F({ceil_:YN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(t,e,n){xr(t),n=n||mu(e);const r={shape:t,value:e,dtype:n};return B.runKernel(Wy,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZN(t,e,n){const r=N(t,"x","clipByValue");if(I(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return bu(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:n};return B.runKernel(fy,s,o)}const v1=F({clipByValue_:ZN});function JN(t){return un(t,0)}const eE=F({concat1d_:JN});function tE(t,e){return un(t,e)}const nE=F({concat2d_:tE});function rE(t,e){return un(t,e)}const sE=F({concat3d_:rE});function oE(t,e){return un(t,e)}const iE=F({concat4d_:oE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(t,e,n,r,s="NHWC",o=[1,1],i){const a=N(t,"x","conv2d","float32"),u=N(e,"filter","conv2d","float32");let c=a,l=!1;a.rank===3&&(l=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),I(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Dr("conv2d",r,i);const h=s==="NHWC"?c.shape[3]:c.shape[1];I(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),I(ir(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),I(Jo(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),I(Jo(n),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=B.runKernel(gy,f,d);return l?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Gc=F({conv2d_:aE});function uE(t,e,n,r,s="NWC",o=1,i){const a=N(t,"x","conv1d"),u=N(e,"filter","conv1d");let c=a,l=!1;a.rank===2&&(l=!0,c=ee(a,[1,a.shape[0],a.shape[1]])),I(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),I(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Dr("conv1d",r,i),I(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),I(ir(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),I(Jo(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),I(Jo(n),()=>"Error in conv1D: Stride should be larger than 0."),I(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=ee(u,[1,u.shape[0],u.shape[1],u.shape[2]]),f=ee(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=Gc(f,h,[1,n],r,"NHWC",[1,o],i);return l?ee(g,[g.shape[2],g.shape[3]]):ee(g,[g.shape[0],g.shape[2],g.shape[3]])}const cE=F({conv1d_:uE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(t,e,n,r,s,o="NHWC",i){I(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,u=e,c=!1;e.rank===3&&(c=!0,u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),I(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),I(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),I(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const l=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?u.shape[3]:u.shape[1];I(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),I(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Dr("conv2dDerInput",s,i);const f={dy:u,filter:n},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},m=B.runKernel(xy,f,d);return c?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const w1=F({conv2DBackpropInput_:lE});function hE(t,e,n,r,s,o){const i=N(t,"x","conv2dTranspose"),a=N(e,"filter","conv2dTranspose");return w1(n,i,a,r,s,"NHWC",o)}const fE=F({conv2dTranspose_:hE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(t,e,n,r,s="NDHWC",o=[1,1,1]){const i=N(t,"x","conv3d"),a=N(e,"filter","conv3d");let u=i,c=!1;i.rank===4&&(c=!0,u=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),I(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),I(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),I(ir(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),I(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),I(Jo(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),I(Jo(n),()=>"Error in conv3D: Strides should be larger than 0.");const l={x:u,filter:a},h={strides:n,pad:r,dataFormat:s,dilations:o},f=B.runKernel(by,l,h);return c?ee(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const pE=F({conv3d_:dE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mE(t,e,n,r,s){I(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,i=e,a=!1;e.rank===4&&(a=!0,i=ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const u=o[4],c=i.shape[4];I(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),I(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),I(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),I(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),I(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const l={dy:i,filter:n},h={pad:s,strides:r,inputShape:o},f=B.runKernel(vy,l,h);return a?ee(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const gE=F({conv3DBackpropInput_:mE});function yE(t,e,n,r,s){const o=N(t,"x","conv3dTranspose"),i=N(e,"filter","conv3dTranspose");return gE(n,o,i,r,s)}const xE=F({conv3dTranspose_:yE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(t){const n={x:N(t,"x","cos","float32")};return B.runKernel(wy,n)}const vE=F({cos_:bE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(t){const n={x:N(t,"x","cosh","float32")};return B.runKernel(Sy,n)}const SE=F({cosh_:wE});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(t,e=0,n=!1,r=!1){const o={x:N(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:r};return B.runKernel(Cy,o,i)}const $E=F({cumprod_:CE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TE(t,e=0,n=!1,r=!1){const o={x:N(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:r};return B.runKernel($y,o,i)}const NE=F({cumsum_:TE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(t,e,n,r=!1){const s=N(t,"x","denseBincount"),o=N(e,"weights","denseBincount");I(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),I(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),I(n>=0,()=>`size must be non-negative, but got ${n}.`),I(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:n,binaryOutput:r};return B.runKernel(Ny,i,a)}const _E=F({denseBincount_:EE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(t,e,n="NHWC"){const r=N(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),I(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),I(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},u={blockSize:e,dataFormat:n};return B.runKernel(Ey,a,u)}const kE=F({depthToSpace_:IE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(t,e,n,r,s="NHWC",o=[1,1],i){const a=N(t,"x","depthwiseConv2d","float32"),u=N(e,"filter","depthwiseConv2d","float32");let c=a,l=!1;a.rank===3&&(l=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),I(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=s==="NHWC"?c.shape[3]:c.shape[1];I(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),Dr("depthwiseConv2d",r,i);const f={x:c,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=B.runKernel(_y,f,d);return l?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const If=F({depthwiseConv2d_:RE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(t){const n={x:N(t,"x","diag")};return B.runKernel(Ry,n)}const OE=F({diag_:AE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DE(t,e,n,r,s=[1,1],o="NHWC"){const i=N(t,"x","dilation2d"),a=N(e,"filter","dilation2d");I(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),I(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),I(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,c=!1;i.rank===3&&(u=ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),I(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const l={x:u,filter:a},h={strides:n,pad:r,dilations:s},f=B.runKernel(Ay,l,h);return c?ee(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const PE=F({dilation2d_:DE});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hc(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=t[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function S1(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&n.unshift(o)}return n}function nt(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let o=t[t.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else r[n-s-1]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(t,e){let n=N(t,"a","equal","string_or_numeric"),r=N(e,"b","equal","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(Ly,s)}const C1=F({equal_:FE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LE(t,e,n){const r=N(e,"a","where"),s=N(n,"b","where"),o=N(t,"condition","where","bool"),i=nt(nt(o.shape,r.shape),s.shape),a=Ga(o,i),u=Ga(r,i),c=Ga(s,i),l={condition:a,t:u,e:c};return B.runKernel(J0,l)}const lo=F({where_:LE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BE(t){const n={x:N(t,"x","zerosLike")};return B.runKernel(Rx,n)}const gr=F({zerosLike_:BE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ME(t,e){let n=N(t,"a","div"),r=N(e,"b","div");[n,r]=Ut(n,r);const s=Xe(n,r),o=gr(s),i=C1(r,o);return lo(i,o,s)}const VE=F({divNoNan_:ME});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(t,e){const n=N(t,"t1","dot"),r=N(e,"t2","dot");I((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(I(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){const i=ee(n,[1,-1]),a=ee(r,[-1,1]),u=dt(i,a);return ee(u,[])}else if(n.rank===1&&r.rank===2){const i=ee(n,[1,-1]),a=ee(r,[r.shape[0],r.shape[1]]),u=dt(i,a);return ee(u,[u.size])}else if(n.rank===2&&r.rank===1){const i=ee(r,[-1,1]),a=dt(n,i);return ee(a,[a.size])}else{const i=ee(r,[r.shape[0],r.shape[1]]);return dt(n,i)}}const WE=F({dot_:UE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(t,...e){const n=e.map((s,o)=>N(s,`tensors${o}`,"einsum")),r={equation:t};return B.runKernel(Dy,n,r)}const Oi=F({einsum_:zE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GE(t){const n={x:N(t,"x","elu","float32")};return B.runKernel(Py,n)}const $1=F({elu_:GE});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE(t,e){const n=N(t,"x","ensureShape","string_or_numeric");if(!aT(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const HE=F({ensureShape_:jE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KE(t){let e=N(t,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Dt(e,"float32"));const n={x:e};return B.runKernel(Fy,n)}const qE=F({erf_:KE});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kf(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function T1(t,e,n){const r=t.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?s.push(t[o++]):s.push(e[i++]);return s}function bs(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&n.push(t[o]);const s=e.map(o=>t[o]);return[n,s]}function vr(t,e){const n=e.map(r=>1);return T1(t,n,e)}function rs(t,e,n){I(kf(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function Pr(t,e){if(kf(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function Rf(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Fr(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XE(t,e=null,n=!1){const s={x:N(t,"x","max")},o={reductionIndices:e,keepDims:n};return B.runKernel(f0,s,o)}const Wi=F({max_:XE});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YE(t,e=null,n=!1){const s={x:N(t,"x","min")},o={axis:e,keepDims:n};return B.runKernel(x0,s,o)}const Nh=F({min_:YE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(t,e){let n=N(t,"base","pow"),r=N(e,"exp","pow");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(O0,s)}const ru=F({pow_:QE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(t,e){if((Or(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Or(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vo(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(t){const n={x:N(t,"x","sqrt","float32")};return B.runKernel(ax,n)}const Ps=F({sqrt_:ZE});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JE(t){const e=N(t,"x","square"),n={};return B.runKernel("Square",{x:e},n)}const Yr=F({square_:JE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(t,e=null,n=!1){let r=N(t,"x","sum");r.dtype==="bool"&&(r=Dt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return B.runKernel(ux,s,o)}const Ct=F({sum_:e_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(t,e="euclidean",n=null,r=!1){t=N(t,"x","norm");const s=N1(t,e,n);let o=s.shape;if(r){const i=en(n,t.shape);o=vr(s.shape,i)}return ee(s,o)}function N1(t,e,n=null){if(t.rank===0)return fr(t);if(t.rank!==1&&n===null)return N1(ee(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Ct(fr(t),n);if(e===1/0)return Wi(fr(t),n);if(e===-1/0)return Nh(fr(t),n);if(e==="euclidean"||e===2)return Ps(Ct(ru(fr(t),Ze(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Wi(Ct(fr(t),n[0]),n[1]-1);if(e===1/0)return Wi(Ct(fr(t),n[1]),n[0]);if(e===-1/0)return Nh(Ct(fr(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Ps(Ct(Yr(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const jc=F({norm_:t_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_(t,e=null,n=!1){return jc(t,"euclidean",e,n)}const r_=F({euclideanNorm_:n_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(t){const n={x:N(t,"x","exp")};return B.runKernel(By,n)}const Fs=F({exp_:s_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(t,e=0){const n=N(t,"x","expandDims","string_or_numeric");I(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return B.runKernel(My,r,s)}const hs=F({expandDims_:o_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(t){const n={x:N(t,"x","expm1")};return B.runKernel(Vy,n)}const a_=F({expm1_:i_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(t,e){const n=N(t,"x","tile","string_or_numeric");I(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return B.runKernel(Cf,r,s)}const ja=F({tile_:u_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(t,e,n,r="float32"){e==null&&(e=t);const s=Ft([t,e],r),o=t<=e?t:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=ee(s.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return ja(hs(i,0),[n[0],1,1]);if(n.length===2)return ja(hs(hs(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return ja(hs(hs(hs(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const E1=F({eye_:c_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(t){const n={x:N(t,"x","floor","float32")};return B.runKernel(Gy,n)}const _1=F({floor_:l_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(t,e,n=0,r=0){const s=N(t,"x","gather"),o=N(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:n,batchDims:r};return B.runKernel(Ky,i,a)}const I1=F({gather_:h_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(t,e){let n=N(t,"a","greater","string_or_numeric"),r=N(e,"b","greater","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(Xy,s)}const Hc=F({greater_:f_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(t,e){let n=N(t,"a","greaterEqual","string_or_numeric"),r=N(e,"b","greaterEqual","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(Yy,s)}const k1=F({greaterEqual_:d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(t){const n={input:N(t,"input","imag")};return B.runKernel(Zy,n)}const Kc=F({imag_:p_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_(t){const n={x:N(t,"x","isFinite")};return B.runKernel(Jy,n)}const g_=F({isFinite_:m_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_(t){const n={x:N(t,"x","isInf")};return B.runKernel(e0,n)}const x_=F({isInf_:y_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(t){const n={x:N(t,"x","isNaN")};return B.runKernel(t0,n)}const v_=F({isNaN_:b_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(t,e=.2){const r={x:N(t,"x","leakyRelu")},s={alpha:e};return B.runKernel(n0,r,s)}const R1=F({leakyRelu_:w_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(t,e){let n=N(t,"a","less","string_or_numeric"),r=N(e,"b","less","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(r0,s)}const Eh=F({less_:S_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(t,e){let n=N(t,"a","lessEqual","string_or_numeric"),r=N(e,"b","lessEqual","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(s0,s)}const Af=F({lessEqual_:C_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return B.runKernel(o0,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_(t,e=5,n=1,r=1,s=.5){const o=N(t,"x","localResponseNormalization");I(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),I(Hi(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},c={depthRadius:e,bias:n,alpha:r,beta:s},l=B.runKernel(h0,u,c);return a?ee(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const N_=F({localResponseNormalization_:T_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(t){const n={x:N(t,"x","log","float32")};return B.runKernel(i0,n)}const su=F({log_:E_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(t){const n={x:N(t,"x","log1p")};return B.runKernel(a0,n)}const A1=F({log1p_:__});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(t,e){I(oh(t),()=>"The f passed in variableGrads(f) must be a function"),I(e==null||Array.isArray(e)&&e.every(c=>c instanceof cc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in B.registeredVariables)e.push(B.registeredVariables[c])}const r=n?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),I(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:i,grads:a}=B.gradients(t,e,null,o);I(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),I(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return e.forEach((c,l)=>{a[l]!=null&&(u[c.name]=a[l])}),r!=null&&r.forEach(c=>u[c.name]=null),{value:i,grads:u}}function Ls(t){return B.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(t){const n={x:N(t,"x","neg")};return B.runKernel($0,n)}const gs=F({neg_:k_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(t){const n={x:N(t,"x","softplus")};return B.runKernel(ix,n)}const O1=F({softplus_:R_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(t){const e=N(t,"x","logSigmoid");return Ls(r=>({value:gs(O1(gs(r))),gradFunc:i=>he(i,jo(gs(r)))}))(e)}const O_=F({logSigmoid_:A_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(t,e){let n=N(t,"a","sub"),r=N(e,"b","sub");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(Cx,s)}const ze=F({sub_:D_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(t,e=-1){const n=N(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Ls((s,o)=>{const a=Wi(s,e,!0),u=ze(s,a),c=ze(Dt(u,"float32"),su(Ct(Fs(u),e,!0)));return o([c]),{value:c,gradFunc:(h,f)=>{const[d]=f,m=!0,x=Fs(d);return ze(h,he(Ct(h,e,m),x))}}})(n)}const F_=F({logSoftmax_:P_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_(t,e=null,n=!1){const r=N(t,"x","logSumExp"),s=en(e,r.shape),o=Wi(r,s,!0),i=ze(r,o),a=Fs(i),u=Ct(a,s),c=su(u),l=Fe(ee(o,c.shape),c);if(n){const h=vr(l.shape,s);return ee(l,h)}return l}const D1=F({logSumExp_:L_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(t,e){const n=N(t,"a","logicalAnd","bool"),r=N(e,"b","logicalAnd","bool");nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(u0,s)}const fc=F({logicalAnd_:B_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(t){const n={x:N(t,"x","logicalNot","bool")};return B.runKernel(c0,n)}const P1=F({logicalNot_:M_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(t,e){const n=N(t,"a","logicalOr","bool"),r=N(e,"b","logicalOr","bool");nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(l0,s)}const F1=F({logicalOr_:V_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(t,e){const n=N(t,"a","logicalXor","bool"),r=N(e,"b","logicalXor","bool");return nt(n.shape,r.shape),fc(F1(t,e),P1(fc(t,e)))}const W_=F({logicalXor_:U_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ou=2147483648;function z_(t,e,n="left"){const r=N(t,"sortedSequence","searchSorted"),s=N(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=ee(r,[-1,o]),u=ee(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ae(u.shape)>=Ou)throw new Error(`values tensor size must less than ${Ou}`);if(a.shape[1]>=Ou)throw new Error(`trailing dim_size must less than ${Ou} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:u},l={side:n};return B.runKernel(Z0,c,l)}const Of=F({searchSorted_:z_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(t,e){return Of(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(t,e,n,r,s){const o=N(t,"x","maxPool"),i=1;let a=o,u=!1;o.rank===3&&(u=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),I(ir(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Dr("maxPool",r,s);const c={x:a},l={filterSize:e,strides:n,pad:r,dimRoundingMode:s},h=B.runKernel(p0,c,l);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const L1=F({maxPool_:j_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(t,e=[1,1,1],n,r,s,o="NDHWC"){const i=N(t,"x","maxPool3d");let a=i,u=!1;i.rank===4&&(u=!0,a=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Dr("maxPool3d",r,s);const c={x:a},l={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},h=B.runKernel(m0,c,l);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const K_=F({maxPool3d_:H_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(t,e,n,r,s=!1){const i={x:N(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},u=B.runKernel(g0,i,a);return{result:u[0],indexes:u[1]}}const X_=F({maxPoolWithArgmax_:q_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(t,e){let n=N(t,"a","maximum"),r=N(e,"b","maximum");[n,r]=Ut(n,r),n.dtype==="bool"&&(n=Dt(n,"int32"),r=Dt(r,"int32")),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(d0,s)}const B1=F({maximum_:Y_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_(t,e=null,n=!1){const s={x:N(t,"x","mean")},o={axis:e,keepDims:n};return B.runKernel(y0,s,o)}const dc=F({mean_:Q_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(t,e="float32"){if(xr(t),e==="complex64"){const r=ei(t,"float32"),s=ei(t,"float32");return po(r,s)}const n=fo(ae(t),e);return B.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uo(t,e="float32"){if(xr(t),e==="complex64"){const r=Uo(t,"float32"),s=ei(t,"float32");return po(r,s)}const n=Wg(ae(t),e);return B.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=N(t,"x","meshgrid",t instanceof Yt?t.dtype:"float32");if(e===void 0)return[r];let s=N(e,"y","meshgrid",e instanceof Yt?e.dtype:"float32");const o=ae(r.shape),i=ae(s.shape);return n==="xy"?(r=ee(r,[1,-1]),s=ee(s,[-1,1]),[dt(Uo([i,1],r.dtype),r),dt(s,Uo([1,o],s.dtype))]):(r=ee(r,[-1,1]),s=ee(s,[1,-1]),[dt(r,Uo([1,i],r.dtype)),dt(Uo([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(t,e){let n=N(t,"a","minimum"),r=N(e,"b","minimum");[n,r]=Ut(n,r),n.dtype==="bool"&&(n=Dt(n,"int32"),r=Dt(r,"int32")),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(b0,s)}const pc=F({minimum_:J_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(t,e,n){I(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=N(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)I(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:n},i={x:r};return B.runKernel(v0,i,o)}const tI=F({mirrorPad_:eI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nI(t,e){let n=N(t,"a","mod"),r=N(e,"b","mod");[n,r]=Ut(n,r);const s={a:n,b:r};return B.runKernel(w0,s)}const rI=F({mod_:nI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(t,e=null,n=!1){t=N(t,"x","moments");const r=en(e,t.shape),s=dc(t,r,n);let o=s.shape;n||(o=vr(s.shape,r));const i=Yr(ze(Dt(t,"float32"),ee(s,o))),a=dc(i,r,n);return{mean:s,variance:a}}const oI=F({moments_:sI});function iI(t,e,n,r){const s=N(e,"data","multiRNNCell"),o=lc(n,"c","multiRNNCell"),i=lc(r,"h","multiRNNCell");let a=s;const u=[];for(let h=0;h<t.length;h++){const f=t[h](a,o[h],i[h]);u.push(f[0]),u.push(f[1]),a=f[1]}const c=[],l=[];for(let h=0;h<u.length;h+=2)c.push(u[h]),l.push(u[h+1]);return[c,l]}const aI=F({multiRNNCell_:iI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(t,e,n,r=!1){const s=N(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const u={logits:i===1?ee(s,[1,-1]):s},c={numSamples:e,seed:n,normalized:r},l=B.runKernel(S0,u,c);return i===1?ee(l,[l.size]):l}const cI=F({multinomial_:uI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(t,e){let n=N(t,"a","notEqual","string_or_numeric"),r=N(e,"b","notEqual","string_or_numeric");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r};return B.runKernel(T0,s)}const M1=F({notEqual_:lI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:N(t,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:n,offValue:r};return B.runKernel(k0,i,a)}const fI=F({oneHot_:hI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(t){const n={x:N(t,"x","onesLike")};return B.runKernel(I0,n)}const pI=F({onesLike_:dI});function mI(t,e){const n=N(t,"v1","outerProduct"),r=N(e,"v2","outerProduct");I(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=ee(n,[-1,1]),o=ee(r,[1,-1]);return dt(s,o)}const gI=F({outerProduct_:mI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(t,e,n=0){const r=N(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},o={x:r};return B.runKernel(A0,o,s)}const vu=F({pad_:yI});function xI(t,e,n=0){return I(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),vu(t,[e],n)}const bI=F({pad1d_:xI});function vI(t,e,n=0){return I(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(t,e,n)}const wI=F({pad2d_:vI});function SI(t,e,n=0){return I(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(t,e,n)}const CI=F({pad3d_:SI});function $I(t,e,n=0){return I(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(t,e,n)}const TI=F({pad4d_:$I});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NI(t,e,n){const r=N(t,"x","spaceToBatchND");I(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),I(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),I(r.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+n[u-1][0]+n[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:n};return B.runKernel(cx,s,o)}const V1=F({spaceToBatchND_:NI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(t,e,n,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=N(t,"x","maxPool");let u=a,c=!1;a.rank===3&&(c=!0,u=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(ir(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const l=ui(u.shape,e,o,s,r),h=[l.dilationHeight,l.dilationWidth];let f;r==="same"?f=II([l.filterHeight,l.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[m,x]=_I([l.inHeight,l.inWidth],h,f),g=d?r:"valid",y=d?u:V1(u,h,m),$=(n==="avg"?()=>y1(y,e,o,g,i):()=>L1(y,e,o,g,i))(),C=d?$:x1($,h,x);return c?ee(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function _I(t,e,n){const r=n.map(l=>l[0]),s=n.map(l=>l[1]),o=t.concat(r,s),i=e.map((l,h)=>(l-o[h]%l)%l),a=s.map((l,h)=>l+i[h]),u=e.map((l,h)=>[r[h],a[h]]),c=e.map((l,h)=>[0,i[h]]);return[u,c]}function II(t,e){const r=t.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const kI=F({pool_:EI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(t,e){const n=N(t,"x","prelu"),r=N(e,"alpha","prelu"),s={x:n,alpha:r};return B.runKernel(D0,s)}const U1=F({prelu_:RI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(t,e=null,n=!1){let r=N(t,"x","prod");r.dtype==="bool"&&(r=Dt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return B.runKernel(P0,s,o)}const OI=F({prod_:AI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(t,e,n,r){const s=t.map((l,h)=>N(l,`tensors${h}`,"raggedGather","int32")),o=N(e,"paramsDenseValues","raggedGather"),i=N(n,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},u={outputRaggedRank:r},c=B.runKernel(F0,a,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const PI=F({raggedGather_:DI});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(t,e,n){const r=N(t,"starts","raggedRange"),s=N(e,"limits","raggedRange",r.dtype),o=N(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:o},a=B.runKernel(L0,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const LI=F({raggedRange_:FI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(t,e,n,r,s){const o=N(t,"shape","raggedTensorToTensor","int32"),i=N(e,"values","raggedTensorToTensor"),a=N(n,"defaultValue","raggedTensorToTensor",i.dtype),u=r.map((h,f)=>N(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:o,values:i,defaultValue:a,rowPartitionTensors:u},l={rowPartitionTypes:s};return B.runKernel(B0,c,l)}const MI=F({raggedTensorToTensor_:BI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(t,e,n){xr(t);const r=ae(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=e();return B.makeTensor(s,t,n)}const UI=F({rand_:VI});var Df={exports:{}};Df.exports;(function(t){(function(e,n,r){function s(u){var c=this,l=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=l(" "),c.s1=l(" "),c.s2=l(" "),c.s0-=l(u),c.s0<0&&(c.s0+=1),c.s1-=l(u),c.s1<0&&(c.s1+=1),c.s2-=l(u),c.s2<0&&(c.s2+=1),l=null}function o(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function i(u,c){var l=new s(u),h=c&&c.state,f=l.next;return f.int32=function(){return l.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&o(h,l),f.state=function(){return o(l,{})}),f}function a(){var u=4022871197,c=function(l){l=String(l);for(var h=0;h<l.length;h++){u+=l.charCodeAt(h);var f=.02519603282416938*u;u=f>>>0,f-=u,f*=u,u=f>>>0,f-=u,u+=f*4294967296}return(u>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(Rr,t)})(Df);var WI=Df.exports,Pf={exports:{}};Pf.exports;(function(t){(function(e,n,r){function s(a){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},a===(a|0)?u.x=a:c+=a;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function i(a,u){var c=new s(a),l=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,m=(f+d)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,l&&(typeof l=="object"&&o(l,c),h.state=function(){return o(c,{})}),h}n&&n.exports?n.exports=i:this.xor128=i})(Rr,t)})(Pf);var zI=Pf.exports,Ff={exports:{}};Ff.exports;(function(t){(function(e,n,r){function s(a){var u=this,c="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:c+=a;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,l==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function i(a,u){var c=new s(a),l=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,m=(f+d)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,l&&(typeof l=="object"&&o(l,c),h.state=function(){return o(c,{})}),h}n&&n.exports?n.exports=i:this.xorwow=i})(Rr,t)})(Ff);var GI=Ff.exports,Lf={exports:{}};Lf.exports;(function(t){(function(e,n,r){function s(a){var u=this;u.next=function(){var l=u.x,h=u.i,f,d;return f=l[h],f^=f>>>7,d=f^f<<24,f=l[h+1&7],d^=f^f>>>10,f=l[h+3&7],d^=f^f>>>3,f=l[h+4&7],d^=f^f<<7,f=l[h+7&7],f=f^f<<13,d^=f^f<<9,l[h]=d,u.i=h+1&7,d};function c(l,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],l.x=d,l.i=0,f=256;f>0;--f)l.next()}c(u,a)}function o(a,u){return u.x=a.x.slice(),u.i=a.i,u}function i(a,u){a==null&&(a=+new Date);var c=new s(a),l=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,m=(f+d)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,l&&(l.x&&o(l,c),h.state=function(){return o(c,{})}),h}n&&n.exports?n.exports=i:this.xorshift7=i})(Rr,t)})(Lf);var jI=Lf.exports,Bf={exports:{}};Bf.exports;(function(t){(function(e,n,r){function s(a){var u=this;u.next=function(){var l=u.w,h=u.X,f=u.i,d,m;return u.w=l=l+1640531527|0,m=h[f+34&127],d=h[f=f+1&127],m^=m<<13,d^=d<<17,m^=m>>>15,d^=d>>>12,m=h[f]=m^d,u.i=f,m+(l^l>>>16)|0};function c(l,h){var f,d,m,x,g,y=[],S=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,S=Math.max(S,h.length)),m=0,x=-32;x<S;++x)h&&(d^=h.charCodeAt((x+32)%h.length)),x===0&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,x>=0&&(g=g+1640531527|0,f=y[x&127]^=d+g,m=f==0?m+1:0);for(m>=128&&(y[(h&&h.length||0)&127]=-1),m=127,x=4*128;x>0;--x)d=y[m+34&127],f=y[m=m+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,y[m]=d^f;l.w=g,l.X=y,l.i=m}c(u,a)}function o(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function i(a,u){a==null&&(a=+new Date);var c=new s(a),l=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,m=(f+d)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,l&&(l.X&&o(l,c),h.state=function(){return o(c,{})}),h}n&&n.exports?n.exports=i:this.xor4096=i})(Rr,t)})(Bf);var HI=Bf.exports,Mf={exports:{}};Mf.exports;(function(t){(function(e,n,r){function s(a){var u=this,c="";u.next=function(){var h=u.b,f=u.c,d=u.d,m=u.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^m,m=m-h|0,u.b=h=h<<20^h>>>12^f,u.c=f=f-d|0,u.d=d<<16^f>>>16^m,u.a=m-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):c+=a;for(var l=0;l<c.length+20;l++)u.b^=c.charCodeAt(l)|0,u.next()}function o(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function i(a,u){var c=new s(a),l=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,m=(f+d)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,l&&(typeof l=="object"&&o(l,c),h.state=function(){return o(c,{})}),h}n&&n.exports?n.exports=i:this.tychei=i})(Rr,t)})(Mf);var KI=Mf.exports,W1={exports:{}};const qI={},XI=Object.freeze(Object.defineProperty({__proto__:null,default:qI},Symbol.toStringTag,{value:"Module"})),YI=DT(XI);(function(t){(function(e,n,r){var s=256,o=6,i=52,a="random",u=r.pow(s,o),c=r.pow(2,i),l=c*2,h=s-1,f;function d(C,_,L){var V=[];_=_==!0?{entropy:!0}:_||{};var z=y(g(_.entropy?[C,$(n)]:C??S(),3),V),K=new m(V),q=function(){for(var Z=K.g(o),fe=u,xe=0;Z<c;)Z=(Z+xe)*s,fe*=s,xe=K.g(1);for(;Z>=l;)Z/=2,fe/=2,xe>>>=1;return(Z+xe)/fe};return q.int32=function(){return K.g(4)|0},q.quick=function(){return K.g(4)/4294967296},q.double=q,y($(K.S),n),(_.pass||L||function(Z,fe,xe,$e){return $e&&($e.S&&x($e,K),Z.state=function(){return x(K,{})}),xe?(r[a]=Z,fe):Z})(q,z,"global"in _?_.global:this==r,_.state)}function m(C){var _,L=C.length,V=this,z=0,K=V.i=V.j=0,q=V.S=[];for(L||(C=[L++]);z<s;)q[z]=z++;for(z=0;z<s;z++)q[z]=q[K=h&K+C[z%L]+(_=q[z])],q[K]=_;(V.g=function(Z){for(var fe,xe=0,$e=V.i,Te=V.j,ke=V.S;Z--;)fe=ke[$e=h&$e+1],xe=xe*s+ke[h&(ke[$e]=ke[Te=h&Te+fe])+(ke[Te]=fe)];return V.i=$e,V.j=Te,xe})(s)}function x(C,_){return _.i=C.i,_.j=C.j,_.S=C.S.slice(),_}function g(C,_){var L=[],V=typeof C,z;if(_&&V=="object")for(z in C)try{L.push(g(C[z],_-1))}catch{}return L.length?L:V=="string"?C:C+"\0"}function y(C,_){for(var L=C+"",V,z=0;z<L.length;)_[h&z]=h&(V^=_[h&z]*19)+L.charCodeAt(z++);return $(_)}function S(){try{var C;return f&&(C=f.randomBytes)?C=C(s):(C=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(C)),$(C)}catch{var _=e.navigator,L=_&&_.plugins;return[+new Date,e,L,e.screen,$(n)]}}function $(C){return String.fromCharCode.apply(0,C)}if(y(r.random(),n),t.exports){t.exports=d;try{f=YI}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:Rr,[],Math)})(W1);var QI=W1.exports,ZI=WI,JI=zI,ek=GI,tk=jI,nk=HI,rk=KI,ci=QI;ci.alea=ZI;ci.xor128=JI;ci.xorwow=ek;ci.xorshift7=tk;ci.xor4096=nk;ci.tychei=rk;var Vf=ci;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uf{constructor(e,n,r,s,o){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=Vf.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,n=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class sk{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const o=s||Math.random();this.randu=Vf.alea(o.toString()),this.randn=new Uf(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<n||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class ok{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=Vf.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(t,e,n=1,r="float32",s){if(xr(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new sk(e,n,r,s),i=Ft(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ak=F({randomGamma_:ik});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uk(t,e=0,n=1,r,s){if(xr(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new Uf(e,n,r,!1,s),i=Ft(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const z1=F({randomNormal_:uk});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ck(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return z1(t,0,1,e,n)}const lk=F({randomStandardNormal_:ck});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hk(t,e=0,n=1,r="float32",s){xr(t);const o=Ft(t,r),i=new ok(e,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Wf=F({randomUniform_:hk});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fk(t,e,n,r){return Wf(t,e,n,"int32",r)}const dk=F({randomUniformInt_:fk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return B.runKernel(M0,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pk(t){const n={input:N(t,"input","real")};return B.runKernel(V0,n)}const iu=F({real_:pk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mk(t){const n={x:N(t,"x","reciprocal")};return B.runKernel(U0,n)}const gk=F({reciprocal_:mk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yk(t){const n={x:N(t,"x","relu")};return B.runKernel(W0,n)}const qc=F({relu_:yk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xk(t){const n={x:N(t,"x","relu6")};return B.runKernel(H0,n)}const G1=F({relu6_:xk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(t,e){const r={x:N(t,"x","reverse")},s={dims:e};return B.runKernel(K0,r,s)}const ti=F({reverse_:bk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(t){const e=N(t,"x","reverse");return I(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ti(e,0)}const wk=F({reverse1d_:vk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sk(t,e){const n=N(t,"x","reverse");return I(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ti(n,e)}const Ck=F({reverse2d_:Sk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(t,e){const n=N(t,"x","reverse");return I(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ti(n,e)}const Tk=F({reverse3d_:$k});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nk(t,e){const n=N(t,"x","reverse");return I(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ti(n,e)}const Ek=F({reverse4d_:Nk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _k(t){const n={x:N(t,"x","round")};return B.runKernel(q0,n)}const j1=F({round_:_k});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ik(t){const n={x:N(t,"x","rsqrt","float32")};return B.runKernel(X0,n)}const kk=F({rsqrt_:Ik});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rk(t){const n={x:N(t,"x","selu")};return B.runKernel(ex,n)}const Ak=F({selu_:Rk});function Ok(t,e,n,r,s,o=[1,1],i="NHWC"){const a=N(t,"x","separableConv2d"),u=N(e,"depthwiseFilter","separableConv2d"),c=N(n,"pointwiseFilter","separableConv2d");let l=a,h=!1;if(a.rank===3&&(h=!0,l=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),I(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),I(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),I(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=u.shape[2],d=u.shape[3];I(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);const m=If(l,u,r,s,i,o),g=Gc(m,c,1,"valid",i);return h?ee(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Dk=F({separableConv2d_:Ok});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Pk(t,e){const n=N(t,"x","setdiff1d"),r=N(e,"y","setdiff1d");I(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),I(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),I(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),o=await r.data(),i=new Set(o);let a=0;for(let l=0;l<s.length;l++)i.has(s[l])||a++;const u=new Xi([a],n.dtype),c=new Xi([a],"int32");for(let l=0,h=0;l<s.length;l++)i.has(s[l])||(u.values[h]=s[l],c.values[h]=l,h++);return[u.toTensor(),c.toTensor()]}const Fk=Pk;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lk(t){const n={x:N(t,"x","sign")};return B.runKernel(sx,n)}const Bk=F({sign_:Lk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mk(t){const n={x:N(t,"x","sin","float32")};return B.runKernel(nx,n)}const Vk=F({sin_:Mk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(t){const n={x:N(t,"x","sinh")};return B.runKernel(rx,n)}const Wk=F({sinh_:Uk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(t,e,n){const r=N(t,"x","slice1d");return I(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),We(r,[e],[n])}const Gk=F({slice1d_:zk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(t,e,n){const r=N(t,"x","slice2d");return I(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),We(r,e,n)}const Hk=F({slice2d_:jk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kk(t,e,n){const r=N(t,"x","slice3d");return I(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),We(r,e,n)}const qk=F({slice3d_:Kk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xk(t,e,n){const r=N(t,"x","slice4d");return I(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),We(r,e,n)}const Yk=F({slice4d_:Xk});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qk(t,e=-1){const n=N(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return B.runKernel(hx,r,s)}const Zk=F({softmax_:Qk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jk(t){I(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return B.runKernel(Uy,e)}const zf=F({fft_:Jk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(t){I(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return B.runKernel(Qy,e)}const mc=F({ifft_:eR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=ee(t,[n,e]);r=mc(s)}else{const s=[n,2*(e-1)],o=ee(iu(t),[n,e]),i=ee(Kc(t),[n,e]),a=ti(We(o,[0,1],[n,e-2]),1),u=he(ti(We(i,[0,1],[n,e-2]),1),Ze(-1)),c=un([o,a],1),l=un([i,u],1),h=ee(po(c,l),[s[0],s[1]]);r=mc(h)}if(r=iu(r),t.rank===3&&t.shape[0]!==0){const s=r,o=t.shape[0];r=ee(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const H1=F({irfft_:tR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nR(t,e,n=0){const s={x:N(t,"x","split")},o={numOrSizeSplits:e,axis:n};return B.runKernel(lx,s,o)}const au=F({split_:nR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(t,e){I(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const m=t.shape.map(g=>0),x=t.shape.map(g=>g);x[t.shape.length-1]=e,s=We(t,m,x),n=e}else if(e!=null&&e>n){const m=t.shape.map(x=>x);m[t.shape.length-1]=e-n,s=un([t,ei(m)],t.shape.length-1),n=e}else s=t;const o=gr(s),i=ee(po(s,o),[r,n]),a=zf(i),u=Math.floor(n/2)+1,c=iu(a),l=Kc(a),h=au(c,[u,n-u],c.shape.length-1),f=au(l,[u,n-u],l.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,ee(po(h[0],f[0]),d)}const Gf=F({rfft_:rR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(t,e){let n=N(t,"a","squaredDifference"),r=N(e,"b","squaredDifference");[n,r]=Ut(n,r),nt(n.shape,r.shape);const s={a:n,b:r},o={};return B.runKernel(yx,s,o)}const K1=F({squaredDifference_:sR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(t,e){const n=N(t,"x","squeeze","string_or_numeric");return ee(n,xo(n.shape,e).newShape)}const rn=F({squeeze_:oR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iR(t,e=0){const n=lc(t,"tensors","stack","string_or_numeric");I(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&I(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return B.runKernel(R0,r,s)}const Bs=F({stack_:iR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(t,e=0){const r={x:N(t,"x","step")},s={alpha:e};return B.runKernel(Ax,r,s)}const q1=F({step_:aR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(t,e,n,r,s=0,o=0,i=0,a=0,u=0){const l={x:N(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return B.runKernel(bx,l,h)}const cR=F({stridedSlice_:uR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(t){const n={x:N(t,"x","tan","float32")};return B.runKernel($x,n)}const hR=F({tan_:lR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gn(t,e){ta(t);const n=bo(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return vo(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ho(t,e,n){if(ta(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=bo(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return vo(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X1(t,e,n){if(ta(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=bo(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return vo(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(t,e,n){if(ta(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=bo(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return vo(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(t,e,n){if(ta(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=bo(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return vo(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(t,e,n){if(ta(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=bo(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,vo(t,e,r,n)}function Y1(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+` update.rank != ${s+t.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function jf(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Y1(n,e,t)}function Xc(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=n.length;let i=1;for(let h=s;h<o;++h)i*=n[h];const a=s<1?1:s,u=ae(e.shape)/a,c=[...an(n.slice(0,s)),1],l=ae(n);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:c,outputSize:l}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(t,e,n){const r=N(t,"tensor","tensorScatterupdate"),s=N(e,"indices","tensorScatterupdate","int32"),o=N(n,"updates","tensorScatterupdate");if(jf(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);const i={tensor:r,indices:s,updates:o},a={};return B.runKernel(Q0,i,a)}const gR=F({tensorScatterUpdate_:mR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(t,e=1,n=!0){const r=N(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:n},[a,u]=B.runKernel(Nx,o,i);return{values:a,indices:u}}const xR=F({topk_:yR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(t,e=0,n=1,r,s){if(xr(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Uf(e,n,r,!0,s),i=Ft(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const vR=F({truncatedNormal_:bR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(t,e=0){const n=N(t,"x","unique","string_or_numeric");I(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[o,i]=B.runKernel(_x,r,s);return{values:o,indices:i}}const SR=F({unique_:wR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(t,e,n){const r=N(t,"x","unsortedSegmentSum"),s=N(e,"segmentIds","unsortedSegmentSum","int32");I(Hi(n),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:n};return B.runKernel(kx,o,i)}const $R=F({unsortedSegmentSum_:CR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(t,e=0){const n=N(t,"x","unstack","string_or_numeric");I(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return B.runKernel(Ix,r,s)}const li=F({unstack_:TR});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(t,e){return Of(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(t,e=!0,n,r){return B.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const r=Ft(t,"int32"),s=Ft([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const i=r.indexToLoc(n[o]),a=o*t.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _R(t){const e=N(t,"condition","whereAsync","bool"),n=await e.data(),r=Q1(e.shape,n);return t!==e&&e.dispose(),r}const Z1=_R;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function IR(t,e,n){const r=N(t,"tensor","boolMask"),s=N(e,"mask","boolMask","bool"),o=n??0,i=s.rank,a=r.shape;I(i>0,()=>"mask cannot be scalar"),yr(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let x=o;x<o+i;x++)u*=a[x];const c=a.slice(0,o).concat([u],a.slice(o+i)),l=ee(r,c),h=ee(s,[-1]),f=await Z1(h),d=rn(f,[1]),m=I1(l,d,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),l.dispose(),h.dispose(),f.dispose(),m}const kR=IR;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(t,e,n){const r=N(t,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),I(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{I(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?qe(()=>{let i=iu(r),a=Kc(r);return i=B.runKernel(Ku,{x:i},o),a=B.runKernel(Ku,{x:a},o),n&&(a=gs(a)),po(i,a)}):B.runKernel(Ku,s,o)}const _h=F({transpose_:RR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(t,e,n,r,s=!0){const o=N(t,"v","movingAverage"),i=N(e,"x","movingAverage"),a=N(n,"decay","movingAverage");JT(o,i),I(Pt(o.shape,i.shape),()=>"Shape mismatch in v and x");const u=Ze(1),c=ze(u,a);let l=he(ze(i,o),c);if(s){I(r!=null,()=>"When using zeroDebias: true, step is required.");const h=N(r,"step","movingAverage");l=Xe(l,ze(u,ru(a,h)))}return Fe(o,l)}const OR=F({movingAverage_:AR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(t,e,n){xr(n);const r=N(t,"indices","scatterND","int32"),s=N(e,"updates","scatterND");jf(s,r,n);const o={indices:r,updates:s},i={shape:n};return B.runKernel(Y0,o,i)}const PR=F({scatterND_:DR});function FR(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(t,e,n,r=0){xr(n);const s=N(t,"sparseIndices","sparseToDense","int32"),o=N(e,"sparseValues","sparseToDense","string_or_numeric"),i=N(r,"defaultValue","sparseToDense",o.dtype);FR(s,o,n,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},u={outputShape:n};return B.runKernel(gx,a,u)}const BR=F({sparseToDense_:LR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(t,e){const n=N(e,"indices","gatherND","int32"),s={params:N(t,"x","gatherND","string_or_numeric"),indices:n};return B.runKernel(qy,s)}const VR=F({gatherND_:MR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(t,e){if(e==null)return t.shape.slice();if(Pt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(t,e,n,r){const s=N(t,"x","dropout");if(I(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),I(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof Yt?s.clone():s;const o=UR(s,n),i=1-e,a=Xe(_1(Fe(Wf(o,0,1,"float32",r),i)),i);return he(s,a)}const zR=F({dropout_:WR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Hf(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(i)}return gn(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function GR(t,e,n=1){const r=N(t,"predictions","inTopK"),s=N(e,"targets","inTopK");I(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),I(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),yr(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];I(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await r.data(),a=await s.data(),[u,c]=[i.length/o,o],l=ho("bool",u);for(let h=0;h<u;h++){const f=h*c,d=i.subarray(f,f+c),m=[];for(let x=0;x<d.length;x++)m.push({value:d[x],index:x});m.sort((x,g)=>g.value-x.value),l[h]=0;for(let x=0;x<n;x++)if(m[x].index===a[h]){l[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),ms(l,s.shape,"bool")}const jR=GR;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(t,e,n,r,s,o="NHWC",i){let a=t;t.rank===3&&(a=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),I(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),I(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?a.shape[3]:a.shape[1],l=o==="NHWC"?u.shape[3]:u.shape[1];I(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),I(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),Dr("conv2dDerFilter",s,i);const h={x:a,dy:u},f={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n};return B.runKernel(yy,h,f)}const KR=F({conv2DBackpropFilter_:HR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yc(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return he(t,q1(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Qc(t,e){let n=e;const r=S1(t.shape,e.shape);return r.length>0&&(n=Ct(n,r)),ee(n,t.shape)}function Zc(t,e,n,r){if(e==="linear")return t;if(e==="relu")return qc(t);if(e==="elu")return $1(t);if(e==="relu6")return G1(t);if(e==="prelu")return U1(t,n);if(e==="leakyrelu")return R1(t,r);if(e==="sigmoid")return jo(t);throw new Error(`Unknown fused activation ${e}.`)}const Jc=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",Jc(B.state.gradientDepth,u)===!1){I(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let L=Gc(t,e,n,r,s,o,i);return a!=null&&(L=Fe(L,a)),Zc(L,u,c,l)}const h=N(t,"x","conv2d","float32"),f=N(e,"filter","conv2d","float32");let d=h,m=!1;h.rank===3&&(m=!0,d=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),I(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Dr("fused conv2d",r,i);const x=s==="NHWC"?d.shape[3]:d.shape[1];I(f.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${f.shape[2]}.`),I(ir(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const g=br(d.shape,f.shape,n,o,r,i);let y;a!=null&&(y=N(a,"bias","fused conv2d"),[y]=Ut(y,h),s==="NHWC"?nt(g.outShape,y.shape):(I(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),I(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let S;if(c!=null){const L=c.shape;if(I(L.length<=1||L.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${L.length}.`),L.length===1)I(L[0]===1||L[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the number of output channels (${g.outChannels}).`);else if(L.length===3)try{nt(L,g.outShape)}catch{const z=`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(z)}S=N(c,"prelu weights","fused conv2d")}const $=(L,V)=>{I(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[z,K,q,Z]=V,fe=Yc(L,q,u);I(nu(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const xe=w1(K.shape,fe,z,n,r),$e=KR(K,fe,z.shape,n,r),Te=[xe,$e];if(Z!=null){const ke=Qc(Z,fe);Te.push(ke)}return Te},C={x:d,filter:f,bias:y,preluActivationWeights:S},_={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:l};return a==null?Ls((V,z,K)=>{let q=B.runKernel(hh,C,_);return K([z,V,q]),m&&(q=ee(q,[q.shape[1],q.shape[2],q.shape[3]])),{value:q,gradFunc:$}})(d,f):Ls((V,z,K,q)=>{let Z=B.runKernel(hh,C,_);return q([z,V,Z,K]),m&&(Z=ee(Z,[Z.shape[1],Z.shape[2],Z.shape[3]])),{value:Z,gradFunc:$}})(d,f,y)}const XR=F({fusedConv2d_:qR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(t,e,n,r,s,o=[1,1],i){let a=t;t.rank===3&&(a=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:u},l={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n};return B.runKernel(Iy,c,l)}const QR=F({depthwiseConv2dNativeBackpropFilter_:YR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(t,e,n,r,s,o=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},l={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t},h=B.runKernel(ky,c,l);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const JR=F({depthwiseConv2dNativeBackpropInput_:ZR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(Jc(B.state.gradientDepth,u)===!1){let _=If(t,e,n,r,s,o,i);return a!=null&&(_=Fe(_,a)),Zc(_,u,c,l)}const h=N(t,"x","depthwiseConv2d","float32"),f=N(e,"filter","depthwiseConv2d","float32");let d=h,m=!1;h.rank===3&&(m=!0,d=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),I(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),I(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),o==null&&(o=[1,1]),I(ir(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Dr("fused depthwiseConv2d",r,i);const x=br(d.shape,f.shape,n,o,r,i,!0);let g;a!=null&&(g=N(a,"bias","fused conv2d"),[g]=Ut(g,h),nt(x.outShape,g.shape));let y;c!=null&&(y=N(c,"prelu weights","fused depthwiseConv2d"));const S=(_,L)=>{I(nu(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[V,z,K,q]=L,Z=Yc(_,K,u),fe=JR(z.shape,Z,V,n,r,o,i),xe=QR(z,Z,V.shape,n,r,o,i);if(q!=null){const $e=Qc(g,Z);return[fe,xe,$e]}return[fe,xe]},$={x:d,filter:f,bias:g,preluActivationWeights:y},C={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:l};return a==null?Ls((L,V,z)=>{let K=B.runKernel(fh,$,C);return z([V,L,K]),m&&(K=ee(K,[K.shape[1],K.shape[2],K.shape[3]])),{value:K,gradFunc:S}})(d,f):Ls((L,V,z,K)=>{let q=B.runKernel(fh,$,C);return K([V,L,q,z]),m&&(q=ee(q,[q.shape[1],q.shape[2],q.shape[3]])),{value:q,gradFunc:S}})(d,f,g)}const tA=F({fusedDepthwiseConv2d_:eA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nA({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Jc(B.state.gradientDepth,o)===!1){let Z=dt(t,e,n,r);return s!=null&&(Z=Fe(Z,s)),Zc(Z,o,i,a)}let u=N(t,"a","fused matMul"),c=N(e,"b","fused matMul");[u,c]=Ut(u,c);const l=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),x=c.shape.slice(0,-2),g=ae(m),y=ae(x);I(l===h,()=>`Error in fused matMul: inner shapes (${l}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const $=nt(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),C=n?ee(u,[g,l,f]):ee(u,[g,f,l]),_=r?ee(c,[y,d,h]):ee(c,[y,h,d]);let L;s!=null&&(L=N(s,"bias","fused matMul"),[L]=Ut(L,u),nt($,L.shape));let V;i!=null&&(V=N(i,"prelu weights","fused matMul"));const z=(Z,fe)=>{const[xe,$e,Te,ke]=fe,Ee=Yc(ee(Z,Te.shape),Te,o);let Ie,Je;if(!n&&!r?(Ie=dt(Ee,$e,!1,!0),Je=dt(xe,Ee,!0,!1)):!n&&r?(Ie=dt(Ee,$e,!1,!1),Je=dt(Ee,xe,!0,!1)):n&&!r?(Ie=dt($e,Ee,!1,!0),Je=dt(xe,Ee,!1,!1)):(Ie=dt($e,Ee,!0,!0),Je=dt(Ee,xe,!0,!0)),s!=null){const Lt=Qc(ke,Ee);return[Ie,Je,Lt]}else return[Ie,Je]},K={a:C,b:_,bias:L,preluActivationWeights:V},q={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?Ls((fe,xe,$e)=>{const Te=B.runKernel(lh,K,q);return $e([fe,xe,Te]),{value:ee(Te,$),gradFunc:z}})(C,_):Ls((fe,xe,$e,Te)=>{const ke=B.runKernel(lh,K,q);return Te([fe,xe,ke,$e]),{value:ee(ke,$),gradFunc:z}})(C,_,L)}const rA=F({fusedMatMul_:nA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sA=Object.freeze(Object.defineProperty({__proto__:null,conv2d:XR,depthwiseConv2d:tA,matMul:rA},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(t){return Hf(t,.54,.46)}const iA=F({hammingWindow_:oA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA(t){return Hf(t,.5,.5)}const eb=F({hannWindow_:aA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(t,e,n,r=!1,s=0){let o=0;const i=[];for(;o+e<=t.size;)i.push(We(t,o,e)),o+=n;if(r)for(;o<t.size;){const a=o+e-t.size,u=un([We(t,o,e-a),bu([a],s)]);i.push(u),o+=n}return i.length===0?Ho([],[0,e]):ee(un(i),[i.length,e])}const tb=F({frame_:uA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(t,e,n,r,s=eb){r==null&&(r=J1(e));const o=tb(t,e,n),i=he(o,s(e));return Gf(i,r)}const lA=F({stft_:cA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(t,e,n,r,s="bilinear",o=0){const i=N(t,"image","cropAndResize"),a=N(e,"boxes","cropAndResize","float32"),u=N(n,"boxInd","cropAndResize","int32"),c=a.shape[0];I(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),I(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),I(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),I(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),I(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const l={image:i,boxes:a,boxInd:u},h={method:s,extrapolationValue:o,cropSize:r};return B.runKernel(Ty,l,h)}const fA=F({cropAndResize_:hA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(t){const e=N(t,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return B.runKernel(zy,n,{})}const pA=F({flipLeftRight_:dA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(t){const e=N(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,ja(e,s)}const gA=F({grayscaleToRGB_:mA});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(t){const e=N(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];I(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),I(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,o=Dt(e,"float32"),i=gn([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Oi("ij,j->i",o,i);break;case 3:a=Oi("ijk,k->ij",o,i);break;case 4:a=Oi("ijkl,l->ijk",o,i);break;case 5:a=Oi("ijklm,m->ijkl",o,i);break;case 6:a=Oi("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=hs(a,-1),Dt(a,s)}const xA=F({rgbToGrayscale_:yA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(t,e,n=0,r=.5){const s=N(t,"image","rotateWithOffset","float32");I(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:n,center:r};return B.runKernel(Ox,o,i)}const vA=F({rotateWithOffset_:bA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sa(t,e,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=t.shape[0];return n=Math.min(n,i),I(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),I(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),I(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),I(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=N(t,"boxes","nonMaxSuppression","float32"),i=N(e,"scores","nonMaxSuppression","float32"),a=sa(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return B.runKernel(N0,{boxes:o,scores:i},u)}const SA=F({nonMaxSuppression_:wA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(t,e,n){const r=$A(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function $A(t,e,n){return NA(t,e,n||TA)}function TA(t,e){return t>e?1:t<e?-1:0}function NA(t,e,n){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(e,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(t,e,n,r,s){return Kf(t,e,n,r,s,0)}function rb(t,e,n,r,s,o){return Kf(t,e,n,r,s,0,!1,o,!0)}function sb(t,e,n,r,s,o){return Kf(t,e,n,r,s,o,!0)}function Kf(t,e,n,r,s,o,i=!1,a=!1,u=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>s&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(Cp);const l=o>0?-.5/o:0,h=[],f=[];for(;h.length<n&&c.length>0;){const g=c.pop(),{score:y,boxIndex:S,suppressBeginIndex:$}=g;if(y<s)break;let C=!1;for(let _=h.length-1;_>=$;--_){const L=EA(t,S,h[_]);if(L>=r){C=!0;break}if(g.score=g.score*_A(r,l,L),g.score<=s)break}g.suppressBeginIndex=h.length,C||(g.score===y?(h.push(S),f.push(g.score)):g.score>s&&CA(c,g,Cp))}const d=h.length,m=n-d;a&&m>0&&(h.push(...new Array(m).fill(0)),f.push(...new Array(m).fill(0)));const x={selectedIndices:h};return i&&(x.selectedScores=f),u&&(x.validOutputs=d),x}function EA(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),d=(a-o)*(u-i),m=(h-c)*(f-l);if(d<=0||m<=0)return 0;const x=Math.max(o,c),g=Math.max(i,l),y=Math.min(a,h),S=Math.min(u,f),$=Math.max(y-x,0)*Math.max(S-g,0);return $/(d+m-$)}function _A(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Cp(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function IA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=N(t,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),a=sa(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),c=u[0],l=u[1],{selectedIndices:h}=nb(c,l,n,r,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),gn(h,"int32")}const kA=IA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=N(t,"boxes","nonMaxSuppression"),a=N(e,"scores","nonMaxSuppression"),u=sa(i,a,n,r,s,o);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const c={boxes:i,scores:a},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},h=B.runKernel(_0,c,l);return{selectedIndices:h[0],selectedScores:h[1]}}const AA=F({nonMaxSuppressionWithScore_:RA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function OA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=N(t,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),u=sa(i,a,n,r,s,o);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const c=await Promise.all([i.data(),a.data()]),l=c[0],h=c[1],{selectedIndices:f,selectedScores:d}=sb(l,h,n,r,s,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:gn(f,"int32"),selectedScores:gn(d)}}const DA=OA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=N(t,"boxes","nonMaxSuppression"),a=N(e,"scores","nonMaxSuppression"),u=sa(i,a,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,h=u.scoreThreshold,f={boxes:i,scores:a},d={maxOutputSize:c,iouThreshold:l,scoreThreshold:h,padToMaxOutputSize:o},m=B.runKernel(E0,f,d);return{selectedIndices:m[0],validOutputs:m[1]}}const FA=F({nonMaxSuppressionPadded_:PA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LA(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=N(t,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),u=sa(i,a,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,h=u.scoreThreshold,[f,d]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:x}=rb(f,d,c,l,h,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:gn(m,"int32"),validOutputs:Ze(x,"int32")}}const BA=LA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(t,e,n=!1,r=!1){const s=N(t,"images","resizeBilinear");I(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ee(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:n,halfPixelCenters:r,size:e},c=B.runKernel(j0,a,u);return i?ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const VA=F({resizeBilinear_:MA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(t,e,n=!1,r=!1){const s=N(t,"images","resizeNearestNeighbor");I(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ee(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:n,halfPixelCenters:r,size:e},c=B.runKernel(G0,a,u);return i?ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const WA=F({resizeNearestNeighbor_:UA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(t,e="binary",n=!1,r=.5){const s=N(t,"image","threshold"),o=.2989,i=.587,a=.114,u=s.shape[0]*s.shape[1];let c=he(gn([r]),255),l,h,f,d;if(I(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),I(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),I(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[l,h,f]=au(s,[1,1,1],-1);const g=he(l,o),y=he(h,i),S=he(f,a);d=Fe(Fe(g,y),S)}else d=t;if(e==="otsu"){const g=b1(Dt(j1(d),"int32"),ms([]),256);c=GA(g,u)}const m=n?Af(d,c):Hc(d,c);return Dt(he(m,255),"int32")}function GA(t,e){let n=gn([-1]),r=gn([0]),s=gn([0]),o,i,a,u,c,l;for(let h=0;h<t.size-1;h++){o=We(t,0,h+1),i=We(t,h+1),c=Xe(Ct(o),e),l=Xe(Ct(i),e);const f=Ct(he(o,ou(0,o.size)));a=Xe(f,Ct(o));const d=bu(i.shape,o.size),m=Fe(ou(0,i.size),d),x=he(i,m);u=Xe(Ct(x),Ct(i));const g=ze(a,u),y=ze(a,u),S=he(c,l);s=he(he(S,g),y);const $=Hc(s,r);r=lo($,s,r),n=lo($,gn([h]),n)}return n}const jA=F({threshold_:zA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(t,e,n="nearest",r="constant",s=0,o){const i=N(t,"image","transform","float32"),a=N(e,"transforms","transform","float32");I(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:i,transforms:a},c={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return B.runKernel(Ex,u,c)}const KA=F({transform_:HA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(t,e,n){const r=N(t,"a","bandPart");I(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,u;typeof e=="number"?(I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=N(e<0?o:e,"numLower","bandPart")):(I(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=lo(Eh(e,0),o,pc(e,o))),typeof n=="number"?(I(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),I(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=N(n<0?i:n,"numUpper","bandPart")):(I(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=lo(Eh(n,0),i,pc(n,i)));const c=ee(ou(0,o,1,"int32"),[-1,1]),l=ou(0,i,1,"int32"),h=ze(c,l),f=fc(Af(h,a),k1(h,gs(u))),d=ei([o,i],r.dtype);return ee(Bs(li(ee(r,[-1,o,i])).map(m=>lo(f,m,d))),s)}const XA=F({bandPart_:qA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(t){let e;if(Array.isArray(t)){e=!1,I(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)I(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else e=!0,t=au(t,t.shape[0],0).map(s=>rn(s,[0]));I(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(B.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=he(Ct(he(n[i],o)),n[i]);o=ze(o,a)}return Xe(o,jc(o,"euclidean"))}));return e?Bs(n,0):n}const QA=F({gramSchmidt_:YA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZA(t,e=!1){if(I(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return $p(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,c)=>u*c),r=li(ee(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];r.forEach(u=>{const[c,l]=$p(u,e);s.push(c),o.push(l)});const i=ee(Bs(s,0),t.shape),a=ee(Bs(o,0),t.shape);return[i,a]}}function $p(t,e=!1){return B.tidy(()=>{I(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=E1(n),o=co(t);const i=Ho([[1]],[1,1]);let a=co(i);const u=n>=r?r:n;for(let c=0;c<u;++c){const l=o,h=a,f=s;[a,o,s]=B.tidy(()=>{const d=We(o,[c,c],[n-c,1]),m=jc(d),x=We(o,[c,c],[1,1]),g=lo(Hc(x,0),Ho([[-1]]),Ho([[1]])),y=ze(x,he(g,m)),S=Xe(d,y);S.shape[0]===1?a=co(i):a=un([i,We(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);const $=gs(Xe(dt(g,y),m)),C=We(o,[c,0],[n-c,r]),_=he($,a),L=_h(a);if(c===0)o=ze(C,dt(_,dt(L,C)));else{const K=ze(C,dt(_,dt(L,C)));o=un([We(o,[0,0],[c,r]),K],0)}const V=_h(_),z=We(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=ze(z,dt(dt(z,a),V));else{const K=ze(z,dt(dt(z,a),V));s=un([We(s,[0,0],[n,c]),K],1)}return[a,o,s]}),Ot([l,h,f])}return!e&&n>r&&(s=We(s,[0,0],[n,r]),o=We(o,[0,0],[r,r])),[s,o]})}const JA=F({qr_:ZA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Gn;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Gn||(Gn={}));function eO(t,e,n=Gn.SUM_BY_NONZERO_WEIGHTS){const r=N(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=N(e,"weights","computeWeightedLoss"));const o=s==null?r:he(r,s);if(n===Gn.NONE)return o;if(n===Gn.SUM)return Ct(o);if(n===Gn.MEAN){if(s==null)return dc(o);{const i=r.size/s.size,a=Xe(Ct(o),Ct(s));return i>1?Xe(a,Ze(i)):a}}if(n===Gn.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Xe(Ct(o),Ze(r.size));{const i=he(s,Uo(r.shape)),a=Dt(Ct(M1(i,Ze(0))),"float32");return Xe(Ct(o),a)}}throw Error(`Unknown reduction: ${n}`)}const Vs=F({computeWeightedLoss_:eO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(t,e,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){const s=N(t,"labels","absoluteDifference"),o=N(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=N(n,"weights","absoluteDifference")),yr(s.shape,o.shape,"Error in absoluteDifference: ");const a=fr(ze(s,o));return Vs(a,i,r)}const nO=F({absoluteDifference_:tO});function rO(t,e,n,r,s=Gn.SUM_BY_NONZERO_WEIGHTS){const o=N(t,"labels","cosineDistance"),i=N(e,"predictions","cosineDistance");let a=null;r!=null&&(a=N(r,"weights","cosineDistance")),yr(o.shape,i.shape,"Error in cosineDistance: ");const u=Ze(1),c=ze(u,Ct(he(o,i),n,!0));return Vs(c,a,s)}const sO=F({cosineDistance_:rO});function oO(t,e,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){let s=N(t,"labels","hingeLoss");const o=N(e,"predictions","hingeLoss");let i=null;n!=null&&(i=N(n,"weights","hingeLoss")),yr(s.shape,o.shape,"Error in hingeLoss: ");const a=Ze(1);s=ze(he(Ze(2),s),a);const u=qc(ze(a,he(s,o)));return Vs(u,i,r)}const iO=F({hingeLoss_:oO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(t,e,n,r=1,s=Gn.SUM_BY_NONZERO_WEIGHTS){const o=N(t,"labels","huberLoss"),i=N(e,"predictions","huberLoss");let a=null;n!=null&&(a=N(n,"weights","huberLoss")),yr(o.shape,i.shape,"Error in huberLoss: ");const u=Ze(r),c=fr(ze(i,o)),l=pc(c,u),h=ze(c,l),f=Fe(he(Ze(.5),Yr(l)),he(u,h));return Vs(f,a,s)}const uO=F({huberLoss_:aO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(t,e,n,r=1e-7,s=Gn.SUM_BY_NONZERO_WEIGHTS){const o=N(t,"labels","logLoss"),i=N(e,"predictions","logLoss");let a=null;n!=null&&(a=N(n,"weights","logLoss")),yr(o.shape,i.shape,"Error in logLoss: ");const u=Ze(1),c=Ze(r),l=gs(he(o,su(Fe(i,c)))),h=he(ze(u,o),su(Fe(ze(u,i),c))),f=ze(l,h);return Vs(f,a,s)}const lO=F({logLoss_:cO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(t,e,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){const s=N(t,"labels","meanSquaredError"),o=N(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=N(n,"weights","meanSquaredError")),yr(s.shape,o.shape,"Error in meanSquaredError: ");const a=K1(s,o);return Vs(a,i,r)}const fO=F({meanSquaredError_:hO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(t,e){const n=N(t,"labels","sigmoidCrossEntropyWithLogits"),r=N(e,"logits","sigmoidCrossEntropyWithLogits");yr(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=qc(r),o=he(r,n),i=A1(Fs(gs(fr(r))));return Fe(ze(s,o),i)}function pO(t,e,n,r=0,s=Gn.SUM_BY_NONZERO_WEIGHTS){let o=N(t,"multiClassLabels","sigmoidCrossEntropy");const i=N(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=N(n,"weights","sigmoidCrossEntropy")),yr(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Ze(r),l=Ze(1),h=Ze(.5);o=Fe(he(o,ze(l,c)),he(h,c))}const u=dO(o,i);return Vs(u,a,s)}const mO=F({sigmoidCrossEntropy_:pO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Ls((s,o,i)=>{const u=D1(o,[n],!0),c=ze(Dt(o,"float32"),u);i([s,c]);const l=gs(he(c,s));return{value:Ct(l,[n]),gradFunc:(d,m)=>{const[x,g]=m,y=vr(d.shape,[n]);return[he(ee(d,y),ze(Dt(x,"float32"),Fs(g))),he(ee(d,y),ze(Fs(g),Dt(x,"float32")))]}}})(t,e)}function yO(t,e,n,r=0,s=Gn.SUM_BY_NONZERO_WEIGHTS){let o=N(t,"onehotLabels","softmaxCrossEntropy");const i=N(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=N(n,"weights","softmaxCrossEntropy")),yr(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Ze(r),l=Ze(1),h=Ze(o.shape[1]);o=Fe(he(o,ze(l,c)),Xe(c,h))}const u=gO(o,i);return Vs(u,a,s)}const xO=F({softmaxCrossEntropy_:yO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(t,e,n,r){const s=N(t,"indices","sparseFillEmptyRows","int32"),o=N(e,"values","sparseFillEmptyRows"),i=N(n,"denseShape","sparseFillEmptyRows","int32"),a=N(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u={indices:s,values:o,denseShape:i,defaultValue:a},c=B.runKernel(fx,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const vO=F({sparseFillEmptyRows_:bO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(t,e,n){const r=N(t,"inputIndices","sparseReshape","int32"),s=N(e,"inputShape","sparseReshape","int32"),o=N(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=B.runKernel(dx,i);return{outputIndices:a[0],outputShape:a[1]}}const SO=F({sparseReshape_:wO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(t,e,n){const r=N(t,"data","sparseSegmentMean"),s=N(e,"indices","sparseSegmentMean","int32"),o=N(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return B.runKernel(px,i)}const $O=F({sparseSegmentMean_:CO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(t,e,n){const r=N(t,"data","sparseSegmentSum"),s=N(e,"indices","sparseSegmentSum","int32"),o=N(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return B.runKernel(mx,i)}const NO=F({sparseSegmentSum_:TO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(t,e,n,r,s,o,i,a){const u=N(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=N(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const l={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:u,dataSplits:c},f=B.runKernel(vx,h,l);return{nGrams:f[0],nGramsSplits:f[1]}}const _O=F({stringNGrams_:EO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(t,e,n=!0){const r=N(t,"input","stringSplit","string"),s=N(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},i={input:r,delimiter:s},a=B.runKernel(wx,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const kO=F({stringSplit_:IO});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(t,e){const n=N(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return B.runKernel(Sx,s,r)}const AO=F({stringToHashBucketFast_:RO});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(t,e,n,r=!0){const s=N(t,"input","staticRegexReplace","string"),o={pattern:e,rewrite:n,replaceGlobal:r};return B.runKernel(xx,{x:s},o)}const DO=F({staticRegexReplace_:OO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PO={fft:zf,ifft:mc,rfft:Gf,irfft:H1},FO={hammingWindow:iA,hannWindow:eb,frame:tb,stft:lA},el={flipLeftRight:pA,grayscaleToRGB:gA,resizeNearestNeighbor:WA,resizeBilinear:VA,rgbToGrayscale:xA,rotateWithOffset:vA,cropAndResize:fA,nonMaxSuppression:SA,nonMaxSuppressionAsync:kA,nonMaxSuppressionWithScore:AA,nonMaxSuppressionWithScoreAsync:DA,nonMaxSuppressionPadded:FA,nonMaxSuppressionPaddedAsync:BA,threshold:jA,transform:KA},LO={bandPart:XA,gramSchmidt:QA,qr:JA},BO={absoluteDifference:nO,computeWeightedLoss:Vs,cosineDistance:sO,hingeLoss:iO,huberLoss:uO,logLoss:lO,meanSquaredError:fO,sigmoidCrossEntropy:mO,softmaxCrossEntropy:xO},MO={sparseFillEmptyRows:vO,sparseReshape:SO,sparseSegmentMean:$O,sparseSegmentSum:NO},VO={stringNGrams:_O,stringSplit:kO,stringToHashBucketFast:AO,staticRegexReplace:DO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UO=new Map,WO=new Map;class zO{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class Fo{constructor(){this.classNameMap={}}static getMap(){return Fo.instance==null&&(Fo.instance=new Fo),Fo.instance}static register(e){Fo.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function GO(t,e,n){I(t.className!=null,()=>"Class being registered does not have the static className property defined."),I(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),I(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return Fo.register(t),UO.set(s,t),WO.set(t,s),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hi extends zO{minimize(e,n=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Ot(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return I_(e,n)}dispose(){this.iterations_!=null&&Ot(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ze(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(hi,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jO extends hi{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=B.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:qe(()=>gr(o).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:qe(()=>gr(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const u=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;qe(()=>{const l=Fe(he(u,this.rho),he(Yr(a),1-this.rho)),h=he(Xe(Ps(Fe(c,this.epsilon)),Ps(Fe(u,this.epsilon))),a),f=Fe(he(c,this.rho),he(Yr(h),1-this.rho));u.assign(l),c.assign(f);const d=Fe(he(h,-this.learningRate),o);o.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ot(this.accumulatedGrads.map(e=>e.variable)),Ot(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HO extends hi{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=B.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:qe(()=>bu(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const a=this.accumulatedGrads[s].variable;qe(()=>{const u=Fe(a,Yr(i));a.assign(u);const c=Fe(he(Xe(i,Ps(Fe(u,B.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ot(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KO extends hi{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],qe(()=>{this.accBeta1=Ze(n).variable(),this.accBeta2=Ze(r).variable()}),s==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);qe(()=>{const r=ze(1,this.accBeta1),s=ze(1,this.accBeta2);n.forEach((o,i)=>{const a=B.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:qe(()=>gr(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:qe(()=>gr(a).variable(u))});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const l=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,f=Fe(he(l,this.beta1),he(c,1-this.beta1)),d=Fe(he(h,this.beta2),he(Yr(c),1-this.beta2)),m=Xe(f,r),x=Xe(d,s);l.assign(f),h.assign(d);const g=Fe(he(Xe(m,Fe(Ps(x),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(he(this.accBeta1,this.beta1)),this.accBeta2.assign(he(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ot(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ot(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),qe(()=>{this.accBeta1.assign(ru(this.beta1,this.iterations_+1)),this.accBeta2.assign(ru(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qO extends hi{static get className(){return"Adamax"}constructor(e,n,r,s=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],qe(()=>{this.iteration=Ze(0).variable(),this.accBeta1=Ze(n).variable()}),s==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);qe(()=>{const r=ze(1,this.accBeta1),s=Xe(-this.learningRate,Fe(he(this.iteration,this.decay),1));n.forEach((o,i)=>{const a=B.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:gr(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:gr(a).variable(u)});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const l=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,f=Fe(he(l,this.beta1),he(c,1-this.beta1)),d=he(h,this.beta2),m=fr(c),x=B1(d,m);l.assign(f),h.assign(x);const g=Fe(he(Xe(s,r),Xe(f,Fe(x,this.epsilon))),a);a.assign(g)}),this.iteration.assign(Fe(this.iteration,1)),this.accBeta1.assign(he(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ot(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ot(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ob extends hi{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=B.registeredVariables[r];qe(()=>{const a=Fe(he(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=fs(Ze(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XO extends ob{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Ze(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=B.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:qe(()=>gr(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&qe(()=>{let u;const c=Fe(he(this.m,i),a);this.useNesterov?u=Fe(he(this.c,Fe(a,he(c,this.m))),o):u=Fe(he(this.c,c),o),i.assign(c),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ot(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YO extends hi{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=B.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=B.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:qe(()=>gr(o).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:qe(()=>gr(o).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:qe(()=>gr(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const u=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;qe(()=>{const l=Fe(he(u,this.decay),he(Yr(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,f=Fe(he(h,this.decay),he(a,1-this.decay)),d=Xe(he(a,this.learningRate),Ps(ze(l,Fe(Yr(f),this.epsilon)))),m=Fe(he(c,this.momentum),d);u.assign(l),h.assign(f),c.assign(m);const x=ze(o,m);o.assign(x)}else{const h=Fe(he(u,this.decay),he(Yr(a),1-this.decay)),f=Fe(he(c,this.momentum),Xe(he(a,this.learningRate),Ps(Fe(h,this.epsilon))));u.assign(h),c.assign(f);const d=ze(o,f);o.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ot(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ot(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ot(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QO=[jO,HO,KO,qO,XO,YO,ob];function ZO(){for(const t of QO)GO(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JO="model",eD=".json",tD=".weights.bin";function Tp(t){return new Promise(e=>setTimeout(e)).then(t)}class ni{constructor(e){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ni.URL_SCHEME)&&(e=e.slice(ni.URL_SCHEME.length)),(e==null||e.length===0)&&(e=JO),this.modelJsonFileName=e+eD,this.weightDataFileName=e+tD}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=ns.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=o1(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await Tp(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=r,await Tp(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:gu(e)}}}}ni.URL_SCHEME="downloads://";class nD{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const u=Ef(o,c=>this.loadWeights(c));e(u)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const i of e)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(o=>Sp(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=Sp(i);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const rD=t=>G().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ni.URL_SCHEME)?sD(t.slice(ni.URL_SCHEME.length)):null;At.registerSaveRouter(rD);function sD(t="model"){return new ni(t)}function oD(t){return new nD(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(t,e,n,r){i(t),n=n??0,r=r??1,a(n,r);let s=0;const o=u=>(u.then(c=>{const l=n+ ++s/t.length*(r-n);return e(l),c}),u);function i(u){I(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,c){I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),I(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),I(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ib(t,e){e==null&&(e={});const n=e.fetchFunc==null?G().platform.fetch:e.fetchFunc,r=t.map(h=>n(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await Np(r,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await Np(a,e.onProgress,.5,1)}function iD(t,e){var n;const r=e.fetchFunc==null?G().platform.fetch:e.fetchFunc;let s=0,o;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var a;s<t.length;){o||(o=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=await o.read();if(u){s++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/t.length);continue}i.enqueue(c);return}i.close()}})}async function aD(t,e="",n,r){return ab(i=>ib(i,{requestInit:r}))(t,e,n)}function ab(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,m)=>{let x=0;d.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,S=Yo[y]*ae(g.shape),$=()=>{s[m]=!0,o[m]==null&&(o[m]=[]),o[m].push({manifestEntry:g,groupOffset:x,sizeBytes:S})};r!=null?r.forEach((C,_)=>{C===g.name&&($(),i[_]=!0)}):$(),a.push(g.name),x+=S})}),!i.every(d=>d)){const d=r.filter((m,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const u=s.reduce((d,m,x)=>(m&&d.push(x),d),[]),c=[];u.forEach(d=>{e[d].paths.forEach(m=>{const x=n+(n.endsWith("/")?"":"/")+m;c.push(x)})});const l=await t(c),h={};let f=0;return u.forEach(d=>{const m=e[d].paths.length,x=new ns(l.slice(f,f+m));o[d].forEach(y=>{const S=x.slice(y.groupOffset,y.groupOffset+y.sizeBytes),$=n1(S,[y.manifestEntry]);for(const C in $)h[C]=$[C]}),f+=m}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD="application/octet-stream",cD="application/json";class qf{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(I(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=G().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=o1(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:cD}),"model.json"),e.weightData!=null){const i=ns.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:uD}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:gu(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Ef(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=vh(e.weightsManifest),s=()=>iD(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=lD(n),o=this.weightPathPrefix||r,i=[],a=[];for(const u of e)for(const c of u.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):i.push(o+c+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const n=await this.getWeightUrls(e),r=vh(e),s=await ib(n,this.loadOptions);return[r,s]}}qf.URL_SCHEME_REGEX=/^https?:\/\//;function lD(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Ih(t){return t.match(qf.URL_SCHEME_REGEX)!=null}const ub=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Ih(r)):n=Ih(t),n)return Xf(t,e)}return null};At.registerSaveRouter(ub);At.registerLoadRouter(ub);function Xf(t,e){return new qf(t,e)}function hD(t,e){return Xf(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _l{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class cb{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class fD{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function dD(t,e,n,r){const s=arguments;return new fD(lb(...s))}function lb(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new _l(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _l({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _l({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function pD(t){return new cb(t)}function mD(t){return new cb(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:ns,browserFiles:oD,browserHTTPRequest:hD,concatenateArrayBuffers:m2,copyModel:L2,decodeWeights:n1,decodeWeightsStream:s1,encodeWeights:c2,fromMemory:dD,fromMemorySync:lb,getLoadHandlers:C2,getModelArtifactsForJSON:Ef,getModelArtifactsForJSONSync:i1,getModelArtifactsInfoForJSON:gu,getSaveHandlers:S2,getWeightSpecs:vh,http:Xf,isHTTPScheme:Ih,listModels:P2,loadWeights:aD,moveModel:B2,registerLoadRouter:w2,registerSaveRouter:v2,removeModel:F2,weightsLoaderFactory:ab,withSaveHandler:pD,withSaveHandlerSync:mD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ro;function gD(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(dh(ch,B.backendName)!=null){const m={pixels:t},x={numChannels:e};return B.runKernel(ch,m,x)}const[c,l]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let h;if(i)h=t.getContext("2d").getImageData(0,0,c,l).data;else if(r||n)h=t.data;else if(o||s||a){if(Ro==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ro=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ro=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ro.canvas.width=c,Ro.canvas.height=l,Ro.drawImage(t,0,0,c,l),h=Ro.getImageData(0,0,c,l).data}let f;if(e===4)f=new Int32Array(h);else{const m=c*l;f=new Int32Array(m*e);for(let x=0;x<m;x++)for(let g=0;g<e;++g)f[x*e+g]=h[x*4+g]}return X1(f,[l,c,e],"int32")}function yD(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function xD(t,e){let n=N(t,"img","toPixels");if(!(t instanceof Yt)){const c=n;n=Dt(c,"int32"),c.dispose()}yD(n);const[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2],i=await n.data(),a=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const l=[0,0,0,255];for(let f=0;f<o;f++){const d=i[c*o+f];if(n.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(n.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);o===1?(l[0]=d*a,l[1]=d*a,l[2]=d*a):l[f]=d*a}const h=c*4;u[h+0]=Math.round(l[0]),u[h+1]=Math.round(l[1]),u[h+2]=Math.round(l[2]),u[h+3]=Math.round(l[3])}return n!==t&&n.dispose(),u}const bD=F({fromPixels_:gD});function fb(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(ae(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const a=t.shape,u=s.slice();u.pop();let c=1;for(let h=o;h<n;++h)c*=a[h],u.push(a[h]);const l=[...an(t.shape).map(h=>h/c),1].slice(0,o);return[u,i,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kh=-2,vD=-1;function db(t,e,n){const r=t.shape.length;I(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),I(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)I(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function wD(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function pb(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function mb(t,e,n,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function gb(t,e,n){return n<=t?n:n-(e-1)}function yb(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function SD(t,e,n,r,s,o,i,a,u){const c=t.length;let l=new Array(c),h=new Array(c),f=new Array(c);if(e.length&&n>0){const d=e[0],m=n+1;l=xb(i,d,m,r,t),h=bb(a,d,m,s,t),f=mb(o,d,m,t)}else for(let d=0;d<c;d++)l[d]=wb(i,r,o,t,d,u),h[d]=Sb(a,s,o,t,d,u),f[d]=vb(o,d,u);return{begin:l,end:h,strides:f}}function xb(t,e,n,r,s){const o=[...s],i=yb(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const u=gb(e,n,a);let c=r[u];t&1<<u&&(c=0),o[a]=c}return o}function bb(t,e,n,r,s){const o=[...s],i=yb(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const u=gb(e,n,a);let c=r[u];t&1<<u&&(c=Number.MAX_SAFE_INTEGER),o[a]=c}for(let a=0;a<o.length;a++){const u=s[a];o[a]<0&&(o[a]+=u),o[a]=oc(0,o[a],s[a])}return o}function vb(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function wb(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=oc(0,i,u-1),i}function Sb(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),a>0?i=oc(0,i,u):i=oc(-1,i,u-1),i}function Yf(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function Qf(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Cb(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{I(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((i,a)=>i>=0?i:(I(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function $b(t,e,n,r,s,o,i,a,u){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let $=0;$<h.dims;$++)l&&1<<$&a&&h.numAddAxisAfterEllipsis++,1<<$&i&&(l=!0);l||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};CD(h,f);let d=!0,m=!0,x=!0;const g=[],y=[];for(let $=0;$<t.length;++$){if(f.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const C=!!(f.shrinkAxisMask&1<<$),_=t[$];if(_===-1){g.push(C?1:-1);continue}const L=[f.beginMask&1<<$,f.endMask&1<<$],V=[f.strides[$]>0?0:-1,f.strides[$]>0?_:_-1];if(C&&f.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&f.strides[$]===1;const z=!!(f.beginMask&1<<$&&f.endMask&1<<$);if(f.beginValid&&f.endValid){if(C){const fe=f.begin[$]<0?_+f.begin[$]:f.begin[$];if(f.begin[$]=fe,f.end[$]=f.begin[$]+1,fe<0||fe>=_)throw Error(`slice index ${f.begin[$]} of dimension ${$} out of bounds.`)}else f.begin[$]=Ep(f.begin[$],0,f.strides[$],_,L,V),f.end[$]=Ep(f.end[$],1,f.strides[$],_,L,V);const Z=f.strides[$]===1&&f.begin[$]===0&&f.end[$]===_;d=d&&Z,m=m&&($===0&&f.strides[$]===1||Z)}else d=d&&f.strides[$]===1&&z,m=m&&($===0&&f.strides[$]===1||z);let K,q=!1;if(f.beginValid&&f.endValid?(K=f.end[$]-f.begin[$],q=!0):C?(K=1,q=!0):z&&_>=0&&(f.strides[$]<0?K=-_:K=_,q=!0),q){let Z;K===0||K<0!=f.strides[$]<0?Z=0:Z=Math.trunc(K/f.strides[$])+(K%f.strides[$]!==0?1:0),g.push(Z)}else g.push(-1)}for(let $=0;$<f.finalShapeGatherIndices.length;++$){const C=f.finalShapeGatherIndices[$];C>=0?y.push(g[C]):C===kh&&y.push(1)}return{finalShapeSparse:y.filter(($,C)=>f.finalShapeGatherIndices[C]!==kh),finalShape:y,isIdentity:d,sliceDim0:m,isSimpleSlice:x,begin:f.begin,end:f.end,strides:f.strides}}function CD(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(kh),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(vD),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function Ep(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const $D=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:db,computeFlatOffset:Qf,computeOutShape:pb,getNormalizedAxes:SD,isSliceContinous:Yf,maskToAxes:wD,parseSliceParams:Cb,sliceInfo:$b,startForAxis:wb,startIndicesWithElidedDims:xb,stopForAxis:Sb,stopIndicesWithElidedDims:bb,stridesForAxis:vb,stridesWithElidedDims:mb},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TD=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function ND(){return new Promise(t=>TD(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(t,e){const n=t[0].length;t.forEach((s,o)=>{I(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),I(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<n;i++)I(i===e||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ri(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Gr;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Gr||(Gr={}));function Nb(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const o=n[s],i=r[r.length-n.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function Eb(t){const e={FIRST_DIM_SIZE:Gr.FIRST_DIM_SIZE,VALUE_ROWIDS:Gr.VALUE_ROWIDS,ROW_LENGTHS:Gr.ROW_LENGTHS,ROW_SPLITS:Gr.ROW_SPLITS,ROW_LIMITS:Gr.ROW_LIMITS,ROW_STARTS:Gr.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function _b(t){return t.length===0?0:t[0]===Gr.FIRST_DIM_SIZE?t.length-1:t.length}function Ib(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const o=t[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zf=30;function tl(t){return t<=Zf?t:ih(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kb(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jf(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/e[i],e[i]]);s=s.concat(t.slice(o+1))}return s}function ed(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function td(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?r?s.push(e[o-1]*t[o]):s.push(t[o]/e[o-1]):s.push(t[o]);return s}function Rb(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Ab(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ob=1.7580993408473768,Db=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb=.3275911,Fb=.254829592,Lb=-.284496736,Bb=1.421413741,Mb=-1.453152027,Vb=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rh(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function ED(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function _D(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function ID(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function kD(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function RD(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function AD(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function OD(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Il="->",DD=/->/g,_p=",",Ip="...";function Ub(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(DD,"").length)/Il.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Il}").`);const[r,s]=t.split(Il);I(r.indexOf(Ip)===-1,()=>`The ellipsis notation ("${Ip}") is not supported yet.`);const o=r.split(_p),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<s.length;++f){const d=s[f];if(!o.some(m=>m.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){const d=r[f];a.indexOf(d)===-1&&d!==_p&&a.push(d)}const u=new Array(o.length);for(let f=0;f<i;++f){if(new Set(o[f].split("")).size!==o[f].length)throw new Error(`Found duplicate axes in input component ${o[f]}. Support for duplicate axes in input is not implemented yet.`);u[f]=[];for(let d=0;d<o[f].length;++d)u[f].push(a.indexOf(o[f][d]))}const c=a.length,l=s.length,h=[];for(let f=l;f<c;++f)h.push(f);return{allDims:a,summedDims:h,idDims:u}}function Wb(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function zb(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const o=n[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:I(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Gb(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const a=n[i],u=PD(e,a);for(const c of u)o.indexOf(c)===-1&&(r[i].push(c),o.push(c))}return{path:n,steps:r}}function jb(t){return t.every((e,n)=>e===n)}function PD(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function Hb(t,e,n=0){let r=[];if(typeof e=="number")I(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);I(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,u)=>u>0?a+u:a);e[o]=t.shape[n]-i}I(t.shape[n]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function qb(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function Xb(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function Qb(t,e){return`size ${t} must be non-negative, not ${e}`}function Zb(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Jb(t,e){const n=ae(t),r=ae(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function ev(t,e){const n=ae(t),r=ae(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ah(){return"segment ids must be >= 0"}function tv(){return"segment ids are not increasing"}function nv(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function rv(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(t,e){let n=!1,r;for(t<=Zf?(r=t,n=!0):r=ih(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=ih(t,r+1);return r}function ov(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function iv(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=t.shape[n],a=[];let u=1,c=1,l=1;for(let h=0;h<r;++h)a.push(t.shape[h]),u*=t.shape[h];for(let h=r;h<n;h++)a.push(t.shape[h]),c*=t.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=n+1;h<o;h++)a.push(t.shape[h]),l*=t.shape[h];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:i,outputShape:a}}const FD=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:iv,computeOutShape:ov,segOpComputeOptimalWindowSize:sv},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(t){try{return t.map(e=>qi(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function av(t){return t.map(e=>Go(e))}const LD=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Fb,ERF_A2:Lb,ERF_A3:Bb,ERF_A4:Mb,ERF_A5:Vb,ERF_P:Pb,PARALLELIZE_THRESHOLD:Zf,get RowPartitionType(){return Gr},SELU_SCALE:Db,SELU_SCALEALPHA:Ob,applyActivation:Zc,assertAndGetBroadcastShape:nt,assertAxesAreInnerMostDims:rs,assertParamsConsistent:Tb,assignToTypedArray:RD,axesAreInnerMostDims:kf,calculateShapes:Xc,checkEinsumDimSizes:zb,checkPadOnDimRoundingMode:Dr,combineLocations:T1,combineRaggedTensorToTensorShapes:Nb,complexWithEvenIndex:_D,complexWithOddIndex:ID,computeConv2DInfo:br,computeConv3DInfo:xu,computeDefaultPad:_f,computeDilation2DInfo:g1,computeOptimalWindowSize:tl,computeOutAndReduceShapes:bs,computeOutShape:ri,computePool2DInfo:ui,computePool3DInfo:yu,convertConv2DDataFormat:ra,decodeEinsumEquation:Ub,eitherStridesOrDilationsAreOne:ir,expandShapeToKeepDim:vr,exponent:OD,exponents:AD,fromStringArrayToUint8:av,fromUint8ToStringArray:Qi,getAxesPermutation:Pr,getBroadcastDims:hc,getComplexWithIndex:kD,getEinsumComputePath:Gb,getEinsumPermutation:Wb,getFusedBiasGradient:Qc,getFusedDyActivation:Yc,getImageCenter:kb,getInnerMostAxes:Fr,getPermuted:ed,getRaggedRank:_b,getReductionAxes:S1,getReshaped:Jf,getReshapedPermuted:td,getRowPartitionTypesHelper:Eb,getSliceBeginCoords:Rb,getSliceSize:Ab,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Kb,getSparseFillEmptyRowsNegativeIndexErrorMessage:qb,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Xb,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Zb,getSparseReshapeInputOutputMismatchErrorMessage:ev,getSparseReshapeInputOutputMultipleErrorMessage:Jb,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Yb,getSparseReshapeNegativeOutputDimErrorMessage:Qb,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:rv,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Ah,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:tv,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:nv,getUndoAxesPermutation:Rf,isIdentityPermutation:jb,log:RT,mergeRealAndImagArrays:Rh,prepareAndValidate:fb,prepareSplitSize:Hb,segment_util:FD,shouldFuse:Jc,slice_util:$D,splitRealAndImagArrays:ED,stridesOrDilationsArePositive:Jo,tupleValuesAreOne:nu,upcastType:xs,validateDefaultValueShape:Ib,validateInput:jf,validateUpdateShape:Y1,warn:Hr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ZO();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lo={},Du={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function BD(t,e){Lo[t]=e}function es(t,e){if(!(t in Lo)||e!=null){const r=VD(t,e);if(r!==null)Lo[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=Lo[t];return n==null||n.isContextLost()?(delete Lo[t],es(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Lo[t])}function MD(t){if(!G().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function VD(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??MD(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Lo[t]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(Du.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",Du)||n.getContext("experimental-webgl",Du):n.getContext("webgl2",Du)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var uu;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(uu||(uu={}));var mr;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(mr||(mr={}));var sn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(sn||(sn={}));function wu(t,e){return[e,t]}function UD(t,e){return t*e}function Pu(t){const e=ae(t),n=Math.ceil(e/4);return sh(n)}function oa(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function WD(t,e){const[n,r]=oa(t,e);return n*r*4}function nd(t,e){const n=t;let r,s,o,i,a,u,c,l,h,f;return G().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,c=4,l=1,h=n.HALF_FLOAT,f=n.FLOAT,u=n.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=n.RGBA,a=t.RGBA,c=4,l=4,h=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT,u=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(t,e){const n=e();return G().getBool("DEBUG")&&zD(t),n}function zD(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+KD(t,e))}const GD=596e-10,jD=65504;function HD(t){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||GD<Math.abs(t)&&Math.abs(t)<jD)}function KD(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Fu(t,e){return Us(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function qD(t,e){const n=Us(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ve(t,()=>t.shaderSource(n,e)),ve(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function XD(t,e){const n=Us(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ve(t,()=>t.shaderSource(n,e)),ve(t,()=>t.compileShader(n)),G().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw uv(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const YD=/ERROR: [0-9]+:([0-9]+):/g;function uv(t,e){const n=YD.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),o=s.length.toString().length+2,i=s.map((h,f)=>Mi((f+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,r-1),c=i.slice(r-1,r),l=i.slice(r);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Mi(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function QD(t){return Us(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function ZD(t,e){if(ve(t,()=>t.linkProgram(e)),!G().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function kl(t,e){if(ve(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function JD(t,e){const n=Us(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ve(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),ve(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function eP(t,e){const n=Us(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ve(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),ve(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function tP(t){return Us(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function nP(t,e){const n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function rP(t){return Us(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function kp(t,e,n,r,s,o,i){const a=t.getAttribLocation(e,n);return a===-1?!1:(ve(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),ve(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),ve(t,()=>t.enableVertexAttribArray(a)),!0)}function sP(t,e,n){cP(t,n),ve(t,()=>t.activeTexture(t.TEXTURE0+n)),ve(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function oP(t,e,n){return Us(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function iP(t,e,n){return t.getUniformLocation(e,n)}function aP(t,e,n,r){ve(t,()=>sP(t,e,r)),ve(t,()=>t.uniform1i(n,r))}function Rl(t,e,n){ve(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),ve(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function Rp(t,e){ve(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),ve(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Lu(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+uP(t,e))}function uP(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Us(t,e,n){const r=ve(t,()=>e());if(r==null)throw new Error(n);return r}function cP(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Zi(t,e=2){return ae(t.slice(0,t.length-e))}function Ji(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Bu(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[Zi(t),...Ji(t)]),e}function lP(t,e=!1){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,u)=>u>=t.length-2?yf(t[u]):t[u]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=xo(t).newShape);let s=ae(t),o=null;t.length<=1&&s<=n?o=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const i=o!=null&&Math.max(...o)>r&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=Zi(t);let u=2,c=2;t.length&&([u,c]=Ji(t)),s=a*(u/2)*(c/2),o=sh(s).map(l=>l*2)}else o=sh(s);return o}function Mu(t){return t%2===0}function gc(t,e){if(t=t.slice(-2),e=e.slice(-2),Pt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||Mu(n)&&Mu(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&Mu(t[0])&&Mu(e[0])}let Al,Ol;function hP(t){if(Al==null){const e=es(t);Al=e.getParameter(e.MAX_TEXTURE_SIZE)}return Al}function fP(t){if(Ol==null){const e=es(t);Ol=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ol)}function dP(t){if(t===0)return 0;let e;const n=es(t);return kr(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:kr(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function kr(t,e){return t.getExtension(e)!=null}function Ap(t){try{if(es(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function pP(t){if(t===0)return!1;const e=es(t);if(t===1){if(!kr(e,"OES_texture_float"))return!1}else if(!kr(e,"EXT_color_buffer_float"))return!1;return Oh(e)}function mP(t){if(t===0)return!1;const e=es(t);if(t===1){if(!kr(e,"OES_texture_float")||!kr(e,"WEBGL_color_buffer_float"))return!1}else{if(kr(e,"EXT_color_buffer_float"))return Oh(e);const r="EXT_color_buffer_half_float";if(kr(e,r)){const s=e.getExtension(r);return gP(e,s)}return!1}return Oh(e)}function Oh(t){const e=nd(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),i}function gP(t,e){const n=nd(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function yP(t){return t!==2?!1:es(t).fenceSync!=null}function Su(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&I(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ne=G();Ne.registerFlag("HAS_WEBGL",()=>Ne.getNumber("WEBGL_VERSION")>0);Ne.registerFlag("WEBGL_VERSION",()=>Ap(2)?2:Ap(1)?1:0);Ne.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ne.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ne.get("WEBGL_VERSION")===2);Ne.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ne.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ne.registerFlag("WEBGL_PACK",()=>Ne.getBool("HAS_WEBGL"));Ne.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CLIP",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_REDUCE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_CONV_IM2COL",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>hP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>fP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Ne.getNumber("WEBGL_VERSION");return t===0?0:dP(t)});Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ne.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Zx());Ne.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>pP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ne.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ne.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ne.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>mP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_FENCE_API_ENABLED",()=>yP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ne.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ne.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Ne.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Zx()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Ne.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ne.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ne.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_EXP_CONV",()=>!1);Ne.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ne.getBool("IS_TEST"));Ne.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ne.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ne.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ne.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function On(){let t,e,n,r,s,o,i,a,u,c;return G().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=G().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fi(t,e,n="index"){const r=an(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / ${s}`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`;return`${i}; ${a};`}).join("")}function nl(t,e,n="index"){const r=an(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function xP(t,e){const n=t.length,r=t.map(o=>`${e}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function bP(t,e,n="index"){const r=t.map((o,i)=>i),s=xP(r,e);return s.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${s[i]}`,u=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`;return`${a}; ${u};`}).join("")}function rd(t){const e=an(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function sd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const cv=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:lv}=LD;function vP(t,e,n){const r=[];if(t.forEach(d=>{const m=ae(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){const{uniformShape:x}=od(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),o=t.map(d=>wP(d,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,a=On(),u=$P(a);let c,l,h=EP(a);return e.isPacked?(c=SP(e.logicalShape,i,n.enableShapeUniforms),l=NP(a)):(c=CP(e.logicalShape,i,n.enableShapeUniforms),l=TP(a)),n.packedInputs&&(h+=RP),[h,u,l,s,c,o,n.userCode].join(`
`)}function ia(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return zP(t,e);case 1:return jP(t,e);case 2:return KP(t,e);case 3:return XP(t,e);case 4:return QP(t,e);case 5:return ZP(t);case 6:return JP(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function hv(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return WP(t);case 1:return GP(t,e);case 2:return HP(t,e);case 3:return qP(t,e);default:return YP(t,e)}}function wP(t,e,n=!1,r){let s="";n?s+=hv(t,r):s+=ia(t,r);const o=t.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(n?s+=eF(t,e):s+=tF(t,e)),s}function SP(t,e,n){switch(t.length){case 0:return fv();case 1:return AP(t,e,n);case 2:return VP(t,e,n);case 3:return DP(t,e,n);default:return FP(t,e,n)}}function CP(t,e,n){switch(t.length){case 0:return fv();case 1:return OP(t,e,n);case 2:return UP(t,e,n);case 3:return PP(t,e,n);case 4:return LP(t,e,n);case 5:return BP(t,e);case 6:return MP(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function $P(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function TP(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function NP(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function EP(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${_P}
    ${IP}
    ${kP}
  `}const _P=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,IP=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,kP=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,RP=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function fv(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function AP(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function OP(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function DP(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function PP(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${nl(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=fi(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function FP(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",u="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+a,u=`b${c}, `+u;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${u});
    }
  `}function LP(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${nl(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=fi(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function BP(t,e){const n=fi(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function MP(t,e){const n=fi(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function VP(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Pt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function UP(t,e,n){return Pt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function di(t){return`offset${t}`}function WP(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=On();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function zP(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,o]=t.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=di(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[a,u]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function GP(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=On();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function jP(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${aa(t)}
      }
    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=di(n);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function HP(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],u=On();if(o!=null&&Pt(n,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function KP(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(o!=null&&Pt(n,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=o[0],d=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=xo(n),u=i;if(u.length<n.length){const f=ua(t,u),d=["row","col"];return`
      ${ia(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${ca(d,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${aa(t)}
      }
    `;const c=o[0],l=o[1],h=di(r);return l===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function qP(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const f=n.slice(1),d=[1,2],m=ua(t,f),x=["b","row","col"];return`
        ${hv(m,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${ca(x,d)});
        }
      `}const a=On();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const u=i[0],c=i[1],l=Math.ceil(n[2]/2),h=l*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${h}, ${l}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function XP(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:a,keptDims:u}=xo(n),c=a;if(c.length<n.length){const x=ua(t,c),g=["row","col","depth"];return`
        ${ia(x,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${ca(g,u)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${aa(t)}
      }
    `;const l=t.shapeInfo.texShape,h=l[0],f=l[1],d=t.shapeInfo.flatOffset;if(f===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const m=di(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function YP(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=On();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],l=u[1],h=Math.ceil(o[i-1]/2);let f=h*Math.ceil(o[i-2]/2),d="int b, int row, int col",m=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let x=2;x<i-1;x++)d=`int b${x}, `+d,f*=o[i-x-1],m=`b${x} * ${f} + `+m;return`
    vec4 ${r}(${d}) {
      int index = ${m};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function QP(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,a=n[1]*i,{newShape:u,keptDims:c}=xo(n);if(u.length<n.length){const S=ua(t,u),$=["row","col","depth","depth2"];return`
      ${ia(S,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${ca($,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${aa(t)}
      }
    `;const l=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],d=h[1],m=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&l==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===o&&l==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=di(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${x}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function ZP(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:u,keptDims:c}=xo(e);if(u.length<e.length){const x=ua(t,u),g=["row","col","depth","depth2","depth3"];return`
      ${ia(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${ca(g,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${aa(t)}
      }
    `;const l=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],d=h[1];if(d===a&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(d===s&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=di(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${n}, uv);
    }
  `}function JP(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=xo(e);if(s.length<e.length){const g=ua(t,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${ia(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${ca(y,o)});
      }
    `}const i=e[5],a=e[4]*i,u=e[3]*a,c=e[2]*u,l=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${c}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${aa(t)}
      }
    `;const h=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],m=f[1];if(m===l&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=di(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${c} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${d}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function aa(t){const e=t.name,n=ae(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function eF(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=lv(t.shapeInfo.logicalShape,e.logicalShape),u=pt(i),c=i-o;let l;const h=["x","y","z","w","u","v"];o===0?l="":i<2&&a.length>=1?l="coords = 0;":l=a.map(S=>`coords.${h[S+c]} = 0;`).join(`
`);let f="";i<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((S,$)=>`coords.${h[$+c]}`).join(", ");let d="return outputValue;";const x=ae(t.shapeInfo.logicalShape)===1,y=ae(e.logicalShape)===1;if(o===1&&!x&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!y)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const S=o-2,$=o-1;a.indexOf(S)>-1&&a.indexOf($)>-1?d="return vec4(outputValue.x);":a.indexOf(S)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf($)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function tF(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===u&&t.shapeInfo.flatOffset==null&&Pt(i,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=pt(u),l=lv(t.shapeInfo.logicalShape,e.logicalShape),h=u-a;let f;const d=["x","y","z","w","u","v"];a===0?f="":u<2&&l.length>=1?f="coords = 0;":f=l.map(x=>`coords.${d[x+h]} = 0;`).join(`
`);let m="";return u<2&&a>0?m="coords":m=t.shapeInfo.logicalShape.map((x,g)=>`coords.${d[g+h]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${m});
    }
  `}function pt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function od(t,e,n){const{newShape:r,keptDims:s}=xo(e),o=e.length,i=t&&o===3&&e[0]===1,a=i?e.slice(1):r,u=!t&&o>1&&!Pt(e,n)&&r.length<o||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:s}}function ua(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function ca(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(t,e,n,r){const s=n.map((l,h)=>{const f={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(f.flatOffset=l.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),o=s.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=vP(s,i,e),u=XD(t.gl,a),c=t.createProgram(u);return G().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},dv(t,e,c)))}function dv(t,e,n){const r=[],s=[];let o,i,a,u=null,c=null;c=t.getUniformLocation(n,"NAN",!1),G().getNumber("WEBGL_VERSION")===1&&(u=t.getUniformLocation(n,"INFINITY",!1));const l=!1;for(const h of e.variableNames){const f={name:h,uniform:t.getUniformLocation(n,h,l),offset:t.getUniformLocation(n,`offset${h}`,l)};e.enableShapeUniforms&&(f.shape=t.getUniformLocation(n,`${h}Shape`,l),f.texShape=t.getUniformLocation(n,`${h}TexShape`,l)),r.push(f)}if(e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",l),a=t.getUniformLocation(n,"outShapeStrides",l),i=t.getUniformLocation(n,"outTexShape",l)),e.customUniforms)for(const h of e.customUniforms)s.push(t.getUniformLocation(n,h.name,l));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function Op(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,o=e[r],i=o.shape;if(!Pt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&o.isUniform)return;const a=n.texShape,u=o.isUniform?null:o.texData.texShape;if(!Pt(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function rF(t,e,n,r,s){e.program.enableShapeUniforms||(Op(e.inShapeInfos,n),Op([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),G().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<n.length;++u){const c=n[u],{uniform:l,offset:h,shape:f,texShape:d}=e.variablesLocations[u];if(f){const{uniformShape:m}=od(e.program.packedInputs,c.shape,c.texData.texShape);switch(m.length){case 1:t.gl.uniform1iv(f,new Int32Array(m));break;case 2:t.gl.uniform2iv(f,new Int32Array(m));break;case 3:t.gl.uniform3iv(f,new Int32Array(m));break;case 4:t.gl.uniform4iv(f,new Int32Array(m));break}}if(d&&t.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),l!=null){if(c.isUniform){if(ae(c.shape)<2)t.gl.uniform1f(l,c.uniformValues[0]);else{let m=c.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),t.gl.uniform1fv(l,m)}continue}c.texData.slice!=null&&h!=null&&t.gl.uniform1i(h,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,l,u)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const u=an(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let u=0;u<e.program.customUniforms.length;++u){const c=e.program.customUniforms[u],l=e.customUniformLocations[u],h=s[u];if(c.type==="float")t.gl.uniform1fv(l,h);else if(c.type==="vec2")t.gl.uniform2fv(l,h);else if(c.type==="vec3")t.gl.uniform3fv(l,h);else if(c.type==="vec4")t.gl.uniform4fv(l,h);else if(c.type==="int")t.gl.uniform1iv(l,h);else if(c.type==="ivec2")t.gl.uniform2iv(l,h);else if(c.type==="ivec3")t.gl.uniform3iv(l,h);else if(c.type==="ivec4")t.gl.uniform4iv(l,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function sF(t,e,n){let r="";e.concat(n).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:h}=od(t.packedInputs,i.shape,u);let f="",d="",m="";if(l.length===1&&t.packedInputs){const _=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];f=`${_[0]>1}_${_[1]>1}`}else if(l.length===2&&!t.packedInputs)d=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!t.packedInputs){const _=an(l);m=`${_[0]===u[1]}_${_[_.length-1]===u[1]}`}const x=i.shape.length,g=l.length===2&&Pt(i.shape,u),y=ae(i.shape)===1,S=hc(i.shape,n.shape),$=!t.packedInputs&&x===n.shape.length&&Pt(u,n.texData.texShape),C=t.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${x}_${$}_${c?h:""}_${l.length}_${y}_${S}_${g}_${f}_${d}_${m}_${C}_${a}`}else{const u=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${u}_${a}`}});const s=t.userCode;let o=t.constructor.name;return o+="_"+r+"_"+s+`${G().getNumber("WEBGL_VERSION")}`,o}function yn(t){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=uu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=On();this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?nl(["r","c","d"],e):fi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=uu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=On();this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?nl(["r","c","d"],e):fi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aF{constructor(e){this.variableNames=["A"],this.outTexUsage=mr.DOWNLOAD;const n=On();this.outputShape=e,this.userCode=`
      ${cv}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=mr.DOWNLOAD;const n=On();this.outputShape=e,this.userCode=`
      ${cv}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF={R:0,G:1,B:2,A:3};class Dp{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=On();this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){const u=r[a];i+=`
          if(offset == ${a}) {
            result = values[${cF[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?sd():rd(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lF{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=On();this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const u=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?sd():rd(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(t){const e=On(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return qD(t,n)}function fF(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return JD(t,e)}function dF(t){const e=new Uint16Array([0,1,2,2,1,3]);return eP(t,e)}function Cu(t,e,n,r,s,o){nP(e,n);const i=tP(t),a=t.TEXTURE_2D;return ve(t,()=>t.bindTexture(a,i)),ve(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),ve(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),ve(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),ve(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),G().getNumber("WEBGL_VERSION")===1?ve(t,()=>t.texImage2D(a,0,r,e,n,0,s,o,null)):ve(t,()=>t.texStorage2D(a,1,r,e,n)),ve(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function pv(t){return t.internalFormatFloat}function pF(t,e,n,r){const[s,o]=wu(e,n);return Cu(t,s,o,pv(r),r.textureFormatFloat,t.FLOAT)}function mv(t){return t.internalFormatHalfFloat}function mF(t,e,n,r){const[s,o]=wu(e,n);return Cu(t,s,o,mv(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function gv(t){return t.downloadTextureFormat}function gF(t,e,n,r){const[s,o]=wu(e,n);return Cu(t,s,o,gv(r),t.RGBA,t.UNSIGNED_BYTE)}function yv(t){return t.internalFormatPackedFloat}function yF(t,e,n,r){const[s,o]=oa(e,n);return Cu(t,s,o,yv(r),t.RGBA,t.FLOAT)}function xv(t){return t.internalFormatPackedHalfFloat}function xF(t,e,n,r){const[s,o]=oa(e,n);return Cu(t,s,o,xv(r),t.RGBA,r.textureTypeHalfFloat)}function bF(t,e,n){return ve(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),kp(t,e,"clipSpacePos",n,3,20,0)&&kp(t,e,"uv",n,2,20,12)}function vF(t,e,n,r,s,o){ve(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,a,u;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,u=t.RGBA):(i=new Float32Array(n*r*4),a=t.FLOAT,u=o.internalFormatPackedFloat),i.set(s),G().getNumber("WEBGL_VERSION")===2?ve(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,i)):ve(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,n,r,0,t.RGBA,a,i)),ve(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function wF(t,e,n){ve(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?G().getNumber("WEBGL_VERSION")===2?ve(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):ve(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):G().getNumber("WEBGL_VERSION")===2?ve(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):ve(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),ve(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function SF(t,e,n,r){const s=t.createBuffer();ve(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return ve(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),ve(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),ve(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function CF(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function $F(t,e,n,r){const[s,o]=wu(e,n),i=4,a=new Uint8Array(UD(e*n,i));return ve(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function TF(t,e,n,r,s,o,i,a){const u=t,c=new Float32Array(WD(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function NF(t,e,n){const r=new Float32Array(e*n*4);return ve(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dl{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=G().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,BD(n,e)):this.gl=es(n),e=this.gl,G().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>ve(o,()=>o.createVertexArray()),this.bindVertexArray=i=>ve(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>ve(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>ve(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ve(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>ve(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ve(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>ve(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),G().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Fu(this.gl,o),kr(this.gl,i))this.textureHalfFloatExtension=Fu(this.gl,i);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),kr(this.gl,s))this.colorBufferHalfFloatExtension=Fu(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",kr(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(kr(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=fF(this.gl),this.indexBuffer=dF(this.gl),this.framebuffer=rP(this.gl),this.textureConfig=nd(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ve(e,()=>e.finish()),ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ve(e,()=>e.deleteFramebuffer(this.framebuffer)),ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ve(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ve(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),pF(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),mF(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),gF(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),wF(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),vF(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),xF(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),yF(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Rp(this.gl,this.framebuffer),this.outputTexture=null),ve(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>$F(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,o,i){return TF(this.gl,e,n,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return CF(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=SF(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(G().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=o}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>NF(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=hF(n));const r=QD(n);ve(n,()=>n.attachShader(r,this.vertexShader)),ve(n,()=>n.attachShader(r,e)),ZD(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&kl(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;ve(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),bF(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ve(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&kl(this.gl,this.program),ve(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?oP(this.gl,e,n):iP(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),ve(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),aP(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,o]=oa(n,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&kl(this.gl,this.program),Lu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ve(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ve(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Fu(this.gl,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ip(()=>this.disposed||this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=EF(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in G().platform&&(r=G().platform.setTimeoutCustom.bind(G().platform)),ip(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Rl(this.gl,e,this.framebuffer),this.debug&&Lu(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Rl(this.gl,this.outputTexture,this.framebuffer),this.debug&&Lu(this.gl)):Rp(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;Rl(s,e,this.framebuffer),this.debug&&Lu(s),this.outputTexture=e,ve(s,()=>s.viewport(0,0,n,r)),ve(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),ve(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function EF(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kn(t){return(e,n,r,s,o)=>{const i=nt(e,n),a=i.length,u=an(i),c=ae(i),l=ho(o,c),h=e.length,f=n.length,d=an(e),m=an(n),x=hc(e,i),g=hc(n,i);if(x.length+g.length===0)for(let y=0;y<l.length;++y)l[y]=t(r[y%r.length],s[y%s.length]);else for(let y=0;y<l.length;++y){const S=xf(y,a,u),$=S.slice(-h);x.forEach(V=>$[V]=0);const C=uh($,h,d),_=S.slice(-f);g.forEach(V=>_[V]=0);const L=uh(_,f,m);l[y]=t(r[C],s[L])}return[l,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=Wc([0],n),[o,i]=Kn((a,u)=>a!==u?1:0)(e,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kF=Kn((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(t,e,n,r,s){const o=ae(r),i=fo(s,n);for(let a=0;a<t.length;a++){const u=t[a];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?i[u]+=e[a]:i[u]+=1)}return i}function AF(t,e,n,r=!1){const s=t.shape[0],o=t.shape[1],i=Ft([s,n],e.dtype);for(let a=0;a<s;a++)for(let u=0;u<o;u++){const c=t.get(a,u);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,a,c):e.size>0?i.set(i.get(a,c)+e.get(a,u),a,c):i.set(i.get(a,c)+1,a,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=Kn((t,e)=>t&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(t){return(e,n,r)=>{const s=Jt(n,e.length);for(let o=0;o<e.length;++o)s[o]=t(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=Ws(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(t,e,n,r){const s=Jt(n,ae(e));if(r&&n!=="string"){let o=0;t.forEach(i=>{const a=ae(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a=n==="string"?Qi(i.vals):i.vals;let u=0;for(let c=0;c<i.shape[0];++c){const l=c*e[1]+o;for(let h=0;h<i.shape[1];++h)s[l+h]=a[u++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FF=Kn((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=Ws(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BF=Ws(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF=Ws(t=>Math.floor(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=Kn((t,e)=>Math.floor(t/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(t,e,n,r,s,o,i,a,u){const c=Ft([r,o],n);for(let l=0;l<r;l++){const h=[];let f=0;for(let d=0;d<s;d++){const m=t[l*s+d];f+=m*i[d],h.push(m)}if(f<0||f>=u/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<o;d++)c.values[l*o+d]=e.get(...e.indexToLoc(f*o+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(t,e,n){const r=Ft(n,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],u=i[2],c=e.locToIndex([a,u]);i[2]=e.values[c];const l=t.locToIndex(i);0<=l&&l<t.values.length&&(r.values[s]=t.values[l])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=Kn((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF=Kn((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=Kn((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=Kn((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KF(t,e,n){const r=(e-t)/(n-1),s=fo(n,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qF=Ws(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(t,e,n,r){const s=ho(r,ae(n));for(let o=0;o<s.length;++o){const i=o*e;let a=t[i];for(let u=0;u<e;++u){const c=t[i+u];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=Kn((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QF=Kn((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bv=Kn((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(t,e,n){const r=na(-1,n);return bv([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JF=Kn((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(t,e,n,r,s){const o=e.length,i=ae(e),a=an(e),u=an(s),c=ho(n,ae(s));for(let l=0;l<i;++l){const h=xf(l,o,a),f=new Array(h.length);for(let m=0;m<f.length;m++)f[m]=h[r[m]];const d=uh(f,o,u);c[d]=t[l]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(t,e,n,r){const[s,o]=bs(t,r),i=xs(e,"int32"),a=fo(ae(s),i),u=ae(o);for(let c=0;c<a.length;++c){const l=c*u;let h=1;for(let f=0;f<u;++f)h*=n[l+f];a[c]=h}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nL(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const o=xf(s,e.length,an(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${n})`)}})}function rL(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function sL(t,e,n,r){const s=[];let o=0;const i=e.length-1+n.length,a=new Array(i).fill(null).map(()=>[0]);rL(n,r);let u=1;for(let c=0;c<e.length-1;++c){u*=e[c];const l=e[c+1];for(let h=1;h<u+1;++h)a[c].push(h*l)}for(let c=0;c<t.length;++c){let l=t[c],h=t[c]+1;for(let f=0;f<n.length;++f){const d=n[f],m=f+e.length-1;if(m>=0){const x=a[m],g=x[x.length-1]-d[l];for(let y=l;y<h;++y)a[m].push(d[y+1]+g)}l=d[l],h=d[h]}h!==l&&(s.push([l,h]),o+=h-l)}return{outSplits:a,valueSlices:s,numValues:o}}function oL(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=Jt("int32",r);e.push(s),t[n].forEach((o,i)=>s[i]=o)}return e}function Pp(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function iL(t,e,n,r,s,o){const i=Pp(e,2)[1],a=Pp(o,2)[1];let u=0;for(const c of n)for(let l=c[0];l<c[1];++l){for(let h=0;h<r;++h)s[u*a+h]=t[l*i+h];++u}}function aL(t,e,n,r,s){const o=e.slice();o[0]=s;const i=Jt(n,ae(o)),a=t.length,u=a===0?0:a/e[0];return iL(t,e,r,u,i,o),[i,o]}function uL(t,e,n,r,s,o,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(nL(o,i,u),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:l,valueSlices:h,numValues:f}=sL(o,i,t,c),d=oL(l),m=aL(n,r,s,h,f);return[d,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fp=2147483647;function cL(t,e,n,r,s,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,u=s.length===0,c=i.length===0,l=[];a||l.push(e[0]),u||l.push(s[0]),c||l.push(i[0]);for(let g=1;g<l.length;++g)if(l[g]!==l[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=l.length===0?1:l[0],f=Jt("int32",h+1);f[0]=0;for(let g=0;g<h;++g){const y=a?t[0]:t[g],S=u?r[0]:r[g],$=c?o[0]:o[g];if($===0)throw new Error("Requires delta != 0");let C;if($>0&&S<y||$<0&&S>y)C=0;else if(C=Math.ceil(Math.abs((S-y)/$)),C>Fp)throw new Error(`Requires ((limit - start) / delta) <= ${Fp}`);f[g+1]=f[g]+C}const d=f[h],m=Jt(n,d);let x=0;for(let g=0;g<h;++g){const y=f[g+1]-f[g];let S=a?t[0]:t[g];const $=c?o[0]:o[g];for(let C=0;C<y;++C)m[x++]=S,S+=$}return[f,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tr=Gr;class yc{constructor(e,n,r,s,o,i,a,u,c,l){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Eb(l),this.raggedRank=_b(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Tr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Tr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Tr.VALUE_ROWIDS:return yc.getMaxWidthValueRowID(n);case Tr.ROW_SPLITS:return yc.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Tr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<n;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(n-r,o)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Bp(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;Ib(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=Nb(this.raggedRank,s,n);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=n)o.push(i);for(let a=s;a<e;++a)o.push(-1);return I(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const u=e[a+1]-e[a];let c=Math.min(s,u),l=n[a];l===-1&&(c=0);for(let h=0;h<c;++h)i.push(l),l+=r;for(let h=0;h<u-c;++h)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,u=e[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let c=n[u];i.push(c);for(let l=1;l<o;++l){const h=e[l];if(h===u)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,u=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);c=n[h]}i.push(c)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Tr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,r,s);case Tr.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,r,s);default:throw new Error(`Unsupported partition type: ${Tr[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Tr.FIRST_DIM_SIZE:return e[0];case Tr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Tr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Tr[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const o=Bp(r,!1),i=Jt(this.valuesDType,ae(o));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,s[c],r[c]);this.setOutput(this.raggedRank,u,i,o)}return[o,i]}setOutput(e,n,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const u=ae(a),c=n.length;let l=this.defaultValue;if(l.length!==u&&l.length!==1){const m=this.defaultValueShape;qe(()=>{const x=ee(l,m);l=Ga(x,a).dataSync()})}let h=0,f=0,d=0;for(let m=0;m<=c;++m){let x=m<c?n[m]:-1;if(x===d){++d;continue}if(f<d){const g=o.subarray(h*u),y=i.subarray(f*u),S=(d-f)*u;Lp(y,g,S)}if(m>=c){const g=r.length;x=Math.floor(g/u)}if(x>d)if(this.defaultValue.length===1)i.subarray(d*u,x*u).fill(this.defaultValue[0]),d=x;else for(;x>d;){const g=i.slice(d*u);Lp(g,l,u),++d}x<0?(h=m+1,f=d):(h=m,f=d,d=f+1)}}}function Lp(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function Bp(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function lL(t,e,n,r,s,o,i,a,u,c){return new yc(t,e,n,r,s,o,i,a,u,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hL(t,e,n,r){const s=t===e,o=t<e&&n<0,i=e<t&&n>1;if(s||o||i)return fo(0,r);const a=Math.abs(Math.ceil((e-t)/n)),u=fo(a,r);e<t&&n===1&&(n=-1),u[0]=t;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL=Ws(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(t,e,n,r,s,o,i,a,u,c){const l=[r/s,s],h=t.values,f=e.values;if(r===0)return Ft(n,e.dtype);const d=u instanceof Xi?u:Ft(l,e.dtype);typeof u=="string"||typeof u=="number"?d.values.fill(u):typeof u=="boolean"&&d.values.fill(+u);for(let m=0;m<o;m++){const x=[];let g=0;for(let y=0;y<i;y++){const S=h[m*i+y];x.push(S),g+=S*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let y=0;y<s;y++)c?d.values[g*s+y]+=f[m*s+y]:d.values[g*s+y]=e.rank===0?f[0]:f[m*s+y]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pL=Ws(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mL(t,e,n,r,s){const o=Yf(r,e,n),i=ae(n),a=an(r);if(o){const h=Qf(e,a);return s==="string"?t.slice(h,h+i):t.subarray(h,h+i)}const u=s==="string"?Qi(t):t,c=Ft(r,s,u),l=Ft(n,s);for(let h=0;h<l.size;++h){const f=l.indexToLoc(h),d=f.map((m,x)=>m+e[x]);l.set(c.get(...d),...f)}return s==="string"?av(l.values):l.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(t,e,n,r,s,o,i){const a=e[0],u=o[0],c=new Array(u),l=new Array(a),h=e[1];if(u===0){if(a!==0)throw new Error(Kb(a));const g=Jt(n,0),y=Jt(s,0);return[g,[0,h],y,c,l]}let f=!0,d=0;const m=new Array(u).fill(0);for(let g=0;g<a;++g){const y=t[g*h];if(y<0)throw new Error(qb(g,y));if(y>=u)throw new Error(Xb(g,y,u));++m[y],f=f&&y>=d,d=y}let x=!0;for(let g=0;g<u;++g){const y=m[g]===0;c[g]=y,x=x&&!y,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(x&&f){const g=t,y=r;for(let S=0;S<a;++S)l[S]=S;return[g,[a,h],y,c,l]}else{const g=m[u-1],y=Jt(n,g*h),S=Jt(s,g),$=new Array(u).fill(0);for(let C=0;C<a;++C){const _=t[C*h],L=$[_],V=(_===0?0:m[_-1])+L;$[_]++;for(let z=0;z<h;++z)y[V*h+z]=t[C*h+z];S[V]=r[C],l[C]=V}for(let C=0;C<u;++C)if($[C]===0){const L=C===0?0:m[C-1];y[L*h+0]=C;for(let V=1;V<h;++V)y[L*h+V]=0;S[L]=i}return[y,[g,h],S,c,l]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(t,e,n,r,s){const o=ae(r),i=e[0],a=s.length,u=[];let c=1,l=-1;for(let g=0;g<a;++g){const y=s[g];if(y===-1){if(l!==-1)throw new Error(Yb(l,g));l=g,u.push(1)}else{if(y<0)throw new Error(Qb(g,y));c*=y,u.push(y)}}if(l!==-1){if(c<=0)throw new Error(Zb());const g=Math.trunc(o/c);if(c*g!==o)throw new Error(Jb(r,u));u[l]=g}if(ae(u)!==o)throw new Error(ev(r,u));const f=r.length,d=[];if(f>0){d[f-1]=1;for(let g=f-2;g>=0;--g)d[g]=d[g+1]*r[g+1]}const m=[];if(a>0){m[a-1]=1;for(let g=a-2;g>=0;--g)m[g]=m[g+1]*u[g+1]}const x=Jt(n,i*a);for(let g=0;g<i;++g){let y=0;for(let S=0;S<f;++S)y+=t[g*f+S]*d[S];for(let S=0;S<a;++S)x[g*a+S]=Math.trunc(y/m[S]),y%=m[S]}return[x,[i,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL(t,e,n,r,s,o=!1,i=0){const a=r.length,u=[e[0],t.length/e[0]],c=u[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(Ah());const f=e.slice();f[0]=h;const d=f.reduce(($,C)=>$*C,1),m=Jt(n,d);if(a===0)return h>0&&m.fill(i),[m,f];if(h<=0)throw new Error(Ah());let x=0,g=1,y=0,S=s[x];for(;;){let $=0;if(g<a){if($=s[g],S===$){++g;continue}if(S>=$)throw new Error(tv())}if(S<0||S>=h)throw new Error(nv(S,h));S>y&&m.fill(i,y*c,S*c);for(let C=x;C<g;++C){const _=r[C];if(_<0||_>=u[0])throw new Error(rv(C,r[C],u[0]));for(let L=0;L<c;L++)m[S*c+L]+=t[_*c+L]}if(o)for(let C=0;C<c;C++)m[S*c+C]/=g-x;if(x=g,++g,y=S+1,S=$,g>a)break}return y<h&&m.fill(i,y*c,h*c),[m,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bL=Ws(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vL=Kn((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wL=Ws((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SL(t,e,n,r){const s=Ft(t,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*n[u]+r[u];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CL{constructor(e,n,r,s,o,i){this.separator=Go(e),this.nGramWidths=n,this.leftPad=Go(r),this.rightPad=Go(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),c=Math.max(0,u-a),l=Math.max(0,u-(o-(a+1))),h=i-(c+l),f=n+(c>0?0:a-u);let d=0;d+=c*this.leftPad.length;for(let S=0;S<h;++S)d+=e[f+S].length;d+=l*this.rightPad.length;const m=c+l+h-1;d+=m*this.separator.length,r[s+a]=new Uint8Array(d);const x=r[s+a];let g=0;const y=S=>S.forEach($=>x[g++]=$);for(let S=0;S<c;++S)y(this.leftPad),y(this.separator);for(let S=0;S<h-1;++S)y(e[f+S]),y(this.separator);if(h>0){y(e[f+h-1]);for(let S=0;S<l;++S)y(this.separator),y(this.rightPad)}else{for(let S=0;S<l-1;++S)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let u=n[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<s;++c){let l=n[c]>=u;if(l=l&&n[c]<=r,!l)throw new Error(`Invalid split value ${n[c]}, must be in [${u}, ${r}]`);u=n[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const o=s-1,i=Jt("int32",s);if(r===0||s===0){const u=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const c=n[u]-n[u-1];let l=0;this.nGramWidths.forEach(h=>{l+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&l===0&&(l=1),i[u]=i[u-1]+l}const a=new Array(i[o]);for(let u=0;u<o;++u){const c=n[u];let l=i[u];if(this.nGramWidths.forEach(h=>{const f=n[u+1]-n[u],d=this.getNumNGrams(f,h);this.createNGrams(e,c,a,l,d,h),l+=d}),this.preserveShort&&l===i[u]){const h=n[u+1]-n[u];if(h===0)continue;const f=h+2*this.padWidth;this.createNGrams(e,c,a,l,1,f)}}return[a,i]}}function $L(t,e,n,r,s,o,i,a){return new CL(n,r,s,o,i,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TL(t,e,n,r){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=t.indexOf(o);for(;i!==-1;){const a=t.subarray(0,i);(!n||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(o)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const i=t.subarray(s,o);(!n||i.length!==0)&&r.push(i),s=o+1}}function NL(t,e,n){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let f=0;f<r;++f){const d=s.length;TL(t[f],e,n,s);const m=s.length-d;a[f]=m,o+=m,i=Math.max(i,m)}const u=Jt("int32",o*2),c=new Array(o),l=[r,i];let h=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)u[h*2]=f,u[h*2+1]=d,c[h]=s[h],++h;return[u,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EL(t,e){const n=Jt("int32",t.length);for(let r=0;r<t.length;++r)n[r]=UT(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _L=Kn((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IL(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Ft(n,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%t.shape[u];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aa=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function vv(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,u=e-n+1,c=Math.log(a),l=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*l*(a-l)/a)*Math.sign(u-a/2),f=Math.max(n,Math.floor(e-u*l/a+h)),d=Math.min(r,Math.floor(e+(a-u)*l/a+h));vv(t,e,f,d)}const s=t[e];let o=n,i=r;for(Na(t,n,e),Aa(t[r],s)>0&&Na(t,n,r);o<i;){for(Na(t,o,i),o++,i--;Aa(t[o],s)<0;)o=o+1;for(;Aa(t[i],s)>0;)i=i-1}Aa(t[n],s)===0?Na(t,n,i):(i=i+1,Na(t,i,r)),i<=e&&(n=i+1),e<=i&&(r=i-1)}}function kL(t,e,n,r,s){const o=e[e.length-1],[i,a]=[t.length/o,o],u=ho(n,i*r),c=ho("int32",i*r);for(let h=0;h<i;h++){const f=h*a,d=t.subarray(f,f+a);let m=new Array(d.length);d.forEach((S,$)=>m[$]={value:S,index:$}),r<m.length&&(vv(m,r),m=m.slice(0,r)),s&&m.sort(Aa);const x=h*r,g=u.subarray(x,x+r),y=c.subarray(x,x+r);for(let S=0;S<r;S++)g[S]=m[S].value,y[S]=m[S].index}const l=e.slice();return l[l.length-1]=r,[Ft(l,n,u),Ft(l,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(t,e,n,r){const s=en(e,n)[0],o=[1,n[0],1];for(let m=0;m<s;m++)o[0]*=n[m];o[1]=n[s];for(let m=s+1;m<n.length;m++)o[2]*=n[m];const i=new Map,a=new Int32Array(n[s]),u=new Xi(o,r,t),c=[],l=o[0]===1&&o[2]===1;for(let m=0;m<n[s];m++){let x;if(l)x=t[m].toString();else{const y=[];for(let S=0;S<o[0];S++)for(let $=0;$<o[2];$++)y.push(u.get(S,m,$));x=y.join(",")}const g=i.get(x);if(g!=null)a[m]=g;else{const y=i.size;i.set(x,y),a[m]=y,c.push(m)}}const h=o.slice();h[1]=i.size;const f=new Xi(h,r);c.forEach((m,x)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)f.set(u.get(g,m,y),g,x,y)});const d=n.slice();return d[s]=h[1],{outputValues:f.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AL=Object.freeze(Object.defineProperty({__proto__:null,addImpl:kF,bincountImpl:RF,bincountReduceImpl:AF,bitwiseAndImpl:OF,castImpl:IF,ceilImpl:DF,concatImpl:PF,equalImpl:FF,expImpl:LF,expm1Impl:BF,floorDivImpl:VF,floorImpl:MF,gatherNdImpl:UF,gatherV2Impl:WF,greaterEqualImpl:GF,greaterImpl:zF,lessEqualImpl:HF,lessImpl:jF,linSpaceImpl:KF,logImpl:qF,maxImpl:XF,maximumImpl:YF,minimumImpl:QF,multiplyImpl:bv,negImpl:ZF,notEqualImpl:JF,prodImpl:tL,raggedGatherImpl:uL,raggedRangeImpl:cL,raggedTensorToTensorImpl:lL,rangeImpl:hL,rsqrtImpl:fL,scatterImpl:dL,sigmoidImpl:pL,simpleAbsImpl:_F,sliceImpl:mL,sparseFillEmptyRowsImpl:gL,sparseReshapeImpl:yL,sparseSegmentReductionImpl:xL,sqrtImpl:bL,squaredDifferenceImpl:vL,staticRegexReplaceImpl:wL,stridedSliceImpl:SL,stringNGramsImpl:$L,stringSplitImpl:NL,stringToHashBucketFastImpl:EL,subImpl:_L,tileImpl:IL,topKImpl:kL,transposeImpl:eL,uniqueImpl:RL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:OL,bincountImpl:wv,bincountReduceImpl:DL,bitwiseAndImpl:PL,castImpl:FL,ceilImpl:LL,concatImpl:BL,equalImpl:ML,expImpl:VL,expm1Impl:UL,floorImpl:WL,gatherNdImpl:zL,gatherV2Impl:GL,greaterImpl:jL,greaterEqualImpl:HL,lessImpl:KL,lessEqualImpl:qL,linSpaceImpl:XL,logImpl:YL,maxImpl:QL,maximumImpl:ZL,minimumImpl:JL,multiplyImpl:e3,negImpl:t3,notEqualImpl:n3,prodImpl:r3,raggedGatherImpl:s3,raggedRangeImpl:o3,raggedTensorToTensorImpl:i3,rangeImpl:a3,rsqrtImpl:u3,scatterImpl:c3,sigmoidImpl:l3,simpleAbsImpl:Sv,sliceImpl:h3,sparseFillEmptyRowsImpl:f3,sparseReshapeImpl:d3,sparseSegmentReductionImpl:Cv,sqrtImpl:p3,staticRegexReplaceImpl:m3,stridedSliceImpl:g3,stringNGramsImpl:y3,stringSplitImpl:x3,stringToHashBucketFastImpl:b3,subImpl:v3,tileImpl:w3,topKImpl:S3,transposeImpl:id,uniqueImpl:C3}=AL;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function kn(t,e){return e===1?[t]:$v(t,e)}function $3(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T3{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=yn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=kn("rc",this.rank),r=pt(this.rank),s=this.getOutOfBoundsCondition(n),o=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tv{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${N3(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?sd():rd(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function N3(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?bP(["r","c","d"],"inputShape"):fi(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E3{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const s=Vp(n,r),o=Up(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=Mp(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[o].pop();return this.usedTextures[o].push(u),u}let a;return s===sn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===sn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===sn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===sn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===sn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const o=Vp(r,s),i=Up(n,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=Mp(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=G().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],l=c&&c.indexOf(e);if(l==null||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function _3(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Mp(t,e,n,r,s){const o=I3(e,r);let i;if(s){const[u,c]=oa(t[0],t[1]);i=u*c}else{const[u,c]=wu(t[0],t[1]);i=u*c}const a=_3(n,o);return i*a}function I3(t,e){switch(t){case sn.PACKED_2X2_FLOAT32:return yv(e);case sn.PACKED_2X2_FLOAT16:return xv(e);case sn.UNPACKED_FLOAT32:return pv(e);case sn.UNPACKED_FLOAT16:return mv(e);case sn.PACKED_4X1_UNSIGNED_BYTE:return gv(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function k3(t){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?sn.PACKED_2X2_FLOAT32:sn.UNPACKED_FLOAT32:t?sn.PACKED_2X2_FLOAT16:sn.UNPACKED_FLOAT16}function Vp(t,e){if(t===mr.UPLOAD)return sn.PACKED_2X2_FLOAT32;if(t===mr.RENDER||t==null)return k3(e);if(t===mr.DOWNLOAD||t===mr.PIXELS)return sn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Up(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ds{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Lr="if (isnan(x)) return x;",R3="return x;",Wp="return abs(x);",A3="return (x >= 0.0) ? x : (exp(x) - 1.0);",O3=Lr+`
  return (x < 0.0) ? 0.0 : x;
`,D3=Lr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,so="return x;",P3="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3="return x;",L3=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,B3=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,M3=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,V3="return 1.0 / (1.0 + exp(-1.0 * x));";class io{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U3{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length);const n=e.length,r=kn("rc",n),s=pt(n),o=$3(n,r),i=r.slice(-2),a=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W3=Q1,z3=1e-7,G3=1e-4,Vu={};function j3(t){return t in Vu||(Vu[t]={}),Vu[t]}const H3=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),K3=600;function q3(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*K3/1024/1024}class rl extends Vg{nextDataId(){return rl.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Dl)n=e;else{const r=es(G().getNumber("WEBGL_VERSION"),e);n=new Dl(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=es(G().getNumber("WEBGL_VERSION"));n=new Dl(r),this.binaryCache=j3(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new E3(this.gpgpu),this.numMBBeforeWarning=q3(),this.texData=new oT(this,eo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,o,i){const a=this.makeTensorInfo(n,r),u=this.texData.get(a.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[s,o]},u.texShape=[s,o];const c=Bu(n),l=new Dp(c,!1,i),h=this.runWebGLProgram(l,[a],r,[[s,o]]);return h.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,n,r){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:mr.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,o){if(G().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:mr.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:u}=n;if(i!=null){let f;u?f=new io(a,so):f=new ds(a,so);const d=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:s}],s),m=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),m}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let l;c&&(l=Wr());let h;if(s==="complex64"){const f=this.readSync(o.real.dataId),d=this.readSync(o.imag.dataId);h=Rh(f,d)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Wr()-l),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const m=this.pendingRead.get(e);return new Promise(x=>m.push(x))}const n=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=n;if(o!=null){let m;u?m=new io(s,so):m=new ds(s,so);const x=this.runWebGLProgram(m,[{dataId:e,shape:s,dtype:i}],i),g=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&G().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,l;if(i!=="complex64"&&G().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const m=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(m.texture.texture,...Pu(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const m=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=m[0],g=m[1];h=Rh(x,g)}else if(c==null)h=this.getValuesFromTexture(e);else{const m=ae(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,m)}if(l!=null&&this.disposeIntermediateTensorInfo(l),c!=null){const m=this.gpgpu.gl;ve(m,()=>m.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(m=>m(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&eo().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:u,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let d;u?d=new io(o,so):d=new ds(o,so);const m=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:a}],a),x=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),x}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,n.customTexShape),h=eo().makeTensorFromTensorInfo(l),f=this.texData.get(l.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>qi(s));return Ft(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ft(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!HD(r))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),o=ae(n);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),d=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Pu(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),m}const i=G().getBool("WEBGL_PACK")&&s===!0,a=i?Bu(n):n,u=i?new uF(a):new aF(a),c=this.runWebGLProgram(u,[{shape:a,dtype:r,dataId:e}],"float32"),l=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=Xo(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=Xo(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);a.kernelMs=iT(u),a.getExtraProfileInfo=()=>u.map((c,l)=>({name:i[l],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Wr(),endMs:null}}endTimer(e){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Wr(),e)}async getQueryTime(e){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,i)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=H3){return G().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&ae(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Hr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return W3(e.shape,n)}packedUnaryOp(e,n,r){const s=new io(e.shape,n),o=this.compileAndRun(s,[e],r);return eo().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=Sv(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Wp,e.dtype);const n=new ds(e.shape,Wp),r=this.compileAndRun(n,[e]);return eo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Vc(r[0])){const o=r.map(i=>Go(i));s=this.write(o,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return eo().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new U3(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new T3(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[Zi(e.shape),...Ji(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Zi(n),...Ji(n)],i=new Tv(o,r),a=!0,u=[r],c=this.runWebGLProgram(i,[s],e.dtype,u,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(n!=null){const f=ae(o),d=n[0]*n[1]*4;I(f<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Bu(o);let u;s?u=new iF(a):u=new oF(a);const c=!0,l=[n??Pu(a)],h=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:e}],i,l,c,n);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,n,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===uu.DENSE){const y=i??Pu(e.outputShape);u.texShape=y.map(S=>S*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),ae(a.shape)===0)return u.values=ho(a.dtype,0),a;const c=[],l=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(y.dataId);if(S.texture==null){if(!e.packedInputs&&ae(y.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:S.values};e.packedInputs&&(S.isPacked=!0,S.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!S.isPacked!=!!e.packedInputs)y=S.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),S=this.texData.get(y.dataId);else if(S.isPacked&&!gc(S.shape,y.shape)){const $=y,C=y.shape;y.shape=S.shape,y=this.packedReshape(y,C),c.push(y),S=this.texData.get(y.dataId),$.shape=C}return{shape:y.shape,texData:S,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:u,isUniform:!1},f=sF(e,l,h),d=this.getAndSaveBinary(f,()=>nF(this.gpgpu,e,l,h)),m=this.activeTimers!=null;let x;m&&(x=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||rF(this.gpgpu,d,l,h,s),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),m&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const g=G().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Wr();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=qe(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=G().getBool("DEBUG");G().set("DEBUG",!1);const n=this.abs(Ze(1e-8)).dataSync()[0];if(G().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?z3:G3}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:u}=n;if(i!=null)return;const c=this.activeTimers!=null;let l;c&&(l=Wr());let h=n.texShape;if(h==null&&(h=lP(r,u),n.texShape=h),o!=null){const f=Bu(r);let d,m=h[1],x=h[0];const g=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!g)&&([m,x]=oa(h[0],h[1])),u?d=new lF(f,g):d=new Dp(f,g);const y=g?[x,m]:h,S=this.makeTensorInfo(y,s),$=this.texData.get(S.dataId);g?$.usage=mr.PIXELS:$.usage=mr.UPLOAD,$.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),m,x,o);const C=[[x,m]],L=this.runWebGLProgram(d,[S],s,C,!0),V=this.texData.get(L.dataId);n.texShape=V.texShape,n.isPacked=V.isPacked,n.usage=V.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(L.dataId):(n.texture=V.texture,n.values=null,this.texData.delete(L.dataId)),this.disposeIntermediateTensorInfo(S),c&&(this.uploadWaitMs+=Wr()-l)}else{const f=this.acquireTexture(h,a,s,u);n.texture=f}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=X3(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*ic(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ND(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(uv(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:u}=dv(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=u}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:a}=e,u=eo().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(s,n,r,o,i,a);return eo().makeTensorFromDataId(c,n,r,u)}}rl.nextDataId=0;function X3(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Jx()&&a2("webgl",()=>new rl,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ad=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class si{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=nt(n,r),this.enableShapeUniforms=yn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pi=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class la{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nt(n,r);const o=this.outputShape.length;this.enableShapeUniforms=yn(o);let i="";if(s)if(o===0||ae(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${pt(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=kn("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sr(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Y3={kernelName:Sf,backendName:"webgl",kernelFunc:sr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=sr({inputs:{x:r},backend:n}),u=sr({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:u},o}const Q3={kernelName:dy,backendName:"webgl",kernelFunc:wo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nv="return (a < 0.) ? b * a : a;",Ev=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Z3(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=n.makeTensorInfo([],"float32",na(o,"float32")),a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(Ev,s.shape,i.shape):new si(Nv,s.shape,i.shape),u=n.runWebGLProgram(a,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),u}const J3={kernelName:n0,backendName:"webgl",kernelFunc:Z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _v="return (a < 0.) ? b * a : a;",Iv=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function eB(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(Iv,r.shape,s.shape):new si(_v,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],"float32")}const tB={kernelName:D0,backendName:"webgl",kernelFunc:eB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ha="if (isnan(x)) return x;";function et({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,u=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&n!=null){const h=a.texData.get(i.dataId),f=n(h.values,u);return a.makeTensorInfo(i.shape,u,f)}const c=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let l;return c?l=new io(i.shape,e):l=new ds(i.shape,t),a.runWebGLProgram(l,[i],u)}}function hn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:c}=i,l=a;if(r&&u.dtype==="complex64"){const m=l.texData.get(u.dataId),x=l.texData.get(c.dataId),[g,y]=[[m.complexTensorInfos.real,x.complexTensorInfos.real],[m.complexTensorInfos.imag,x.complexTensorInfos.imag]].map($=>{const[C,_]=$,L={dataId:C.dataId,dtype:C.dtype,shape:u.shape},V={dataId:_.dataId,dtype:_.dtype,shape:c.shape},z=new si(t,u.shape,c.shape);return l.runWebGLProgram(z,[L,V],xs(C.dtype,_.dtype))}),S=wo({inputs:{real:g,imag:y},backend:l});return l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(y),S}const h=o||xs(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||l.shouldExecuteOnCPU([u,c]))&&s!=null){const m=l.texData.get(u.dataId).values,x=l.texData.get(c.dataId).values,g=u.dtype==="string"?Qi(m):m,y=u.dtype==="string"?Qi(x):x,[S,$]=s(u.shape,c.shape,g,y,h),C=l.makeTensorInfo($,h),_=l.texData.get(C.dataId);return _.values=S,C}const f=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return f?d=new la(e,u.shape,c.shape,n):d=new si(t,u.shape,c.shape),l.runWebGLProgram(d,[u,c],h)}}function cu(t,e=!1){if(t==="linear")return e?F3:R3;if(t==="relu")return e?B3:O3;if(t==="elu")return e?L3:A3;if(t==="relu6")return e?M3:D3;if(t==="prelu")return e?Iv:_v;if(t==="leakyrelu")return e?Ev:Nv;if(t==="sigmoid")return e?V3:P3;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kv{constructor(e,n,r,s=!1,o=!1,i=!1,a=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=yn(this.outputShape.length);const l=s?e[1]:e[2],h=Math.ceil(l/2),f=s?"i * 2, rc.y":"rc.y, i * 2",d=o?"rc.z, i * 2":"i * 2, rc.z",m=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const S=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let $="rc.x",C="rc.x";e[0]<n[0]?$=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(C=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${C};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${x[0]});
          result += (${m[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${S}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zp={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Gp{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=nt(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jp="return a * b;";function ud(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=xs(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),u=n.texData.get(s.dataId),c=new Gp(zp.REAL,r.shape,s.shape),l=new Gp(zp.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],f=n.runWebGLProgram(c,h,"float32"),d=n.runWebGLProgram(l,h,"float32"),m=wo({inputs:{real:f,imag:d},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),m}if(n.shouldExecuteOnCPU([r,s])){const a=n.texData.get(r.dataId),u=n.texData.get(s.dataId),[c,l]=e3(r.shape,s.shape,a.values,u.values,o),h=n.makeTensorInfo(l,o),f=n.texData.get(h.dataId);return f.values=c,h}let i;return G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new la(jp,r.shape,s.shape):i=new si(jp,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const nB={kernelName:C0,backendName:"webgl",kernelFunc:ud};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(t,e,n){const r=[Zi(t.shape),...Ji(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Zi(e),...Ji(e)],i=new Tv(o,r),a=!0,u=[r],c=n.runWebGLProgram(i,[s],t.dtype,u,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,i=n,a=ae(s.shape),u=uT(o,a),c=ae(u);I(a===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const l=i.texData.get(s.dataId);return l.isPacked&&!gc(s.shape,u)&&!(l.texture!==null&&gc(l.shape,u))?rB(s,u,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}const sB={kernelName:z0,backendName:"webgl",kernelFunc:pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hp{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,u=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const h=1/n;c=`sumValue += dot(values * ${Hi(h)?h.toPrecision(2):h}, ones);`}let l="";o%r>0&&(l=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oB{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",u="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",u="min"):n==="max"&&(a="-1.0 / 1e-20",u="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const l=Math.floor(r/4)*4,h=r%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";n==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):n==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let m="";o%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${l};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=tl(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function mi(t,e,n,r){const s=iB(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:u,outSize:c}=s[i];let l,h;n==="mean"?l=i===0?new Hp({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},a):new Hp({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c}):l=new oB({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},n),h=o,o=r.runWebGLProgram(l,[o],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aB{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[n[i]];this.outputShape=r,this.rank=r.length;const s=pt(this.rank),o=uB(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function uB(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cB{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let l=0;l<r.length;l++)r[l]=e[n[l]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=pt(this.rank),o=$v("rc",this.rank),i=new Array(this.rank);for(let l=0;l<n.length;l++)i[n[l]]=o[l];const a=`vec2(${i.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(t,e,n){const r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cB(t.shape,e):new aB(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(t,e,n,r){const s=e,o=t.shape.length,i=en(s,t.shape);let a=i;const u=Pr(a,o),c=u!=null;let l=t;c&&(l=sl(t,u,r),a=Fr(a.length,o)),rs("sum",a,o);const[h,f]=bs(l.shape,a);let d=h;n&&(d=vr(h,i));const m=ae(f),g=ae(t.shape)/m,y=pe({inputs:{x:l},attrs:{shape:[g,m]},backend:r}),S=Tf(t.dtype),$=mi(y,S,"sum",r),C=pe({inputs:{x:$},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo($),c&&r.disposeIntermediateTensorInfo(l),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return lB(s,o,i,n)}const hB={kernelName:ux,backendName:"webgl",kernelFunc:ol};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function An(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,u=new Array(a);for(let l=0;l<u.length;l++)u[l]=s.shape[o[l]];let c;if(i.shouldExecuteOnCPU([s])){const h=i.texData.get(s.dataId).values,f=id(h,s.shape,s.dtype,o,u);c=i.makeTensorInfo(u,s.dtype);const d=i.texData.get(c.dataId);d.values=f}else c=sl(s,o,i);return c}const fB={kernelName:Ku,backendName:"webgl",kernelFunc:An};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rv=1e3;function xc({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const c=t.shape.length,l=e.shape.length,h=n?t.shape[c-2]:t.shape[c-1],f=r?e.shape[l-1]:e.shape[l-2],d=n?t.shape[c-1]:t.shape[c-2],m=r?e.shape[l-2]:e.shape[l-1],x=t.shape.slice(0,-2),g=e.shape.slice(0,-2),y=ae(x),S=ae(g),C=nt(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,m]);I(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[y,h,d]:[y,d,h],L=r?[S,m,f]:[S,f,m],V=pe({inputs:{x:t},backend:s,attrs:{shape:_}}),z=pe({inputs:{x:e},backend:s,attrs:{shape:L}}),K=[V,z],q=Math.max(y,S),Z=n?V.shape[1]:V.shape[2],fe=o!=null,xe=i!=null,$e=u==="leakyrelu",Te=u!=null?cu(u,!0):null,ke=fe||xe||$e||Te!=null;let Ee;if((d===1||m===1)&&Z>Rv&&ke===!1){let Je=V,Lt=z;n&&(Je=An({inputs:{x:V},backend:s,attrs:{perm:[0,2,1]}}),K.push(Je)),r&&(Lt=An({inputs:{x:z},backend:s,attrs:{perm:[0,2,1]}}),K.push(Lt));const Bt=m!==1,vt=m===1;let tn=Je;Bt&&(tn=pe({inputs:{x:Je},backend:s,attrs:{shape:[q,Z,1]}}),K.push(tn));const Dn=m===1?2:1;let Pn=Lt;vt&&(Pn=pe({inputs:{x:Lt},backend:s,attrs:{shape:[q,1,Z]}}),K.push(Pn));const Wt=ud({inputs:{a:tn,b:Pn},backend:s});Ee=ol({inputs:{x:Wt},backend:s,attrs:{axis:Dn,keepDims:!0}}),K.push(Wt)}else{const Je=xs(t.dtype,e.dtype),Lt=new kv(_,L,[q,d,m],n,r,fe,Te,xe,$e),Bt=[V,z];if(o!=null&&Bt.push(o),xe&&Bt.push(i),$e){const vt=s.makeTensorInfo([],"float32",na(a,"float32"));Bt.push(vt),K.push(vt)}Ee=s.runWebGLProgram(Lt,Bt,Je)}const Ie=pe({inputs:{x:Ee},backend:s,attrs:{shape:C}});K.push(Ee);for(const Je of K)s.disposeIntermediateTensorInfo(Je);return Ie}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:h}=r;return xc({a:s,b:o,transposeA:u,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:l})}const pB={kernelName:lh,backendName:"webgl",kernelFunc:dB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kp="return abs(x);";function mB(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=n.texData.get(r.dataId),i=Sv(o.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new io(r.shape,Kp):s=new ds(r.shape,Kp),n.runWebGLProgram(s,[r],r.dtype)}const gB={kernelName:jg,backendName:"webgl",kernelFunc:mB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yB=Lr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,xB=et({opSnippet:yB}),bB={kernelName:Hg,backendName:"webgl",kernelFunc:xB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vB=Lr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,wB=et({opSnippet:vB}),SB={kernelName:Kg,backendName:"webgl",kernelFunc:wB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qp="return a + b;",CB=hn({opSnippet:qp,packedOpSnippet:qp,supportsComplex:!0,cpuKernelImpl:OL}),$B={kernelName:vf,backendName:"webgl",kernelFunc:CB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TB{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NB{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return sr({inputs:{x:r[0]},backend:n});if(r.length>G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=Yu({inputs:r.slice(0,u),backend:n}),l=Yu({inputs:r.slice(u),backend:n});return Yu({inputs:[c,l],backend:n})}const s=r.map(u=>u.dtype).reduce((u,c)=>xs(u,c)),o=r.map(u=>u.shape),a=G().getBool("WEBGL_PACK")?new NB(r[0].shape,o):new TB(r[0].shape,o);return n.runWebGLProgram(a,r,s)}const EB={kernelName:qg,backendName:"webgl",kernelFunc:Yu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=en(o,s.shape);let c=u;const l=Pr(c,a);let h=s;l!=null&&(h=An({inputs:{x:s},backend:n,attrs:{perm:l}}),c=Fr(c.length,a)),rs("all",c,a);const[f,d]=bs(h.shape,c),m=ae(d),x=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=mi(x,x.dtype,"all",n);let y;if(i){const S=vr(f,u);y=pe({inputs:{x:g},backend:n,attrs:{shape:S}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(h),y}const IB={kernelName:Xg,backendName:"webgl",kernelFunc:_B};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=en(o,s.shape);let c=u;const l=Pr(c,a);let h=s;l!=null&&(h=An({inputs:{x:s},backend:n,attrs:{perm:l}}),c=Fr(c.length,a)),rs("any",c,a);const[f,d]=bs(h.shape,c),m=ae(d),x=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=mi(x,x.dtype,"any",n);let y;if(i){const S=vr(f,u);y=pe({inputs:{x:g},backend:n,attrs:{shape:S}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(h),y}const RB={kernelName:Yg,backendName:"webgl",kernelFunc:kB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AB{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=n==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OB{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,c=pt(u),l=kn("coords",u);let h,f;if(i===1){f=u+1;const z=pt(f);h=`
        ${z} sourceLocR = ${z}(${l.join()}, 0);
        ++${l[u-1]};
        ${z} sourceLocG = ${z}(${l.join()}, 0);
        ++${l[u-2]};
        ${z} sourceLocA = ${z}(${l.join()}, 0);
        --${l[u-1]};
        ${z} sourceLocB = ${z}(${l.join()}, 0);
        --${l[u-2]};`}else f=u,h=`
        ${c} sourceLocR = coords;
        ++${l[u-1]};
        ${c} sourceLocG = coords;
        ++${l[u-2]};
        ${c} sourceLocA = coords;
        --${l[u-1]};
        ${c} sourceLocB = coords;
        --${l[u-2]};`;const d=["x","y","z","w","u","v"].slice(0,f),m="."+d[f-1],x=d.map(z=>"int "+z),g=kn("sourceLocR",f-1).concat("inIdx.r"),y=kn("sourceLocG",f-1).concat("inIdx.g"),S=kn("sourceLocB",f-1).concat("inIdx.b"),$=kn("sourceLocA",f-1).concat("inIdx.a"),C=r==="max"?"greaterThan":"lessThan",_=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${$.join()})));`,L=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${S.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,V=s?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${V}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${l[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${l[u-2]} < ${a[u-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${L};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${L};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(t,e,n,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=tl(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},u=new AB(a,n,r==null),c=[e];r!=null&&c.push(r);const l=t.runWebGLProgram(u,c,"int32");if(l.shape[1]===1)return l;const h=Av(t,e,n,l);return t.disposeIntermediateTensorInfo(l),h}function Ov(t,e,n,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=tl(o),a=new OB(s,i,n,r==null),u=r==null?[e]:[e,r],c=t.runWebGLProgram(a,u,"int32");if(c.shape.length===e.shape.length){const l=Ov(t,e,n,c);return t.disposeIntermediateTensorInfo(c),l}return c}function Dv(t,e,n,r){const s=[n];if(rs("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=t.texData.get(e.dataId),a=i!==null&&i.isPacked;let u=e;a&&(u=t.unpackTensor(e),o.push(u));const[c,l]=bs(u.shape,s),h=ae(l),f=pe({inputs:{x:u},backend:t,attrs:{shape:[-1,h]}});o.push(f);const d=Av(t,f,r);o.push(d);const m=pe({inputs:{x:d},backend:t,attrs:{shape:c}});return o.forEach(x=>t.disposeIntermediateTensorInfo(x)),m}return Ov(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=en(o,s.shape);const a=Pr(i,s.shape.length);let u=s;const c=[];a!=null&&(u=An({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(u),i=Fr(i.length,u.shape.length)),rs("argMax",[i[0]],u.shape.length);const l=Dv(n,u,i[0],"max");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),l}const PB={kernelName:Qg,backendName:"webgl",kernelFunc:DB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=en(o,s.shape);const a=Pr(i,s.shape.length);let u=s;const c=[];a!=null&&(u=An({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(u),i=Fr(i.length,u.shape.length)),rs("argMin",[i[0]],u.shape.length);const l=Dv(n,u,i[0],"min");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),l}const LB={kernelName:Zg,backendName:"webgl",kernelFunc:FB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BB=Lr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,MB=et({opSnippet:BB}),VB={kernelName:Jg,backendName:"webgl",kernelFunc:MB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UB=Lr+"return log(x + sqrt(x * x + 1.0));",WB=et({opSnippet:UB}),zB={kernelName:ey,backendName:"webgl",kernelFunc:WB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GB=Lr+`
  return atan(x);
`,jB=et({opSnippet:GB}),HB={kernelName:ty,backendName:"webgl",kernelFunc:jB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KB=ad+`
  return atan(a, b);
`,qB=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pi+`
  return result;
`,XB=hn({opSnippet:KB,packedOpSnippet:qB}),YB={kernelName:ry,backendName:"webgl",kernelFunc:XB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QB=Lr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ZB=et({opSnippet:QB}),JB={kernelName:ny,backendName:"webgl",kernelFunc:ZB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lu{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let S="0.0";if(x||(S="-1.0 / 1e-20"),r){const z=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${d}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${z} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let C=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(C="avgValue / max(count, 1.0)");const _=Math.floor(i/4)*4,L=i%4,V=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${d}, ${m});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${V}
          }

          int xC = xCCorner + ${_};
          if (${L===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${V}
          } else if (${L===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${V}
          } else if (${L===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${V}
          }
        }
        setOutput(${C});
      }
    `}}class cd{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,d=e.effectiveFilterDepth,m=e.effectiveFilterHeight,x=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,S=e.padInfo.left;this.outputShape=e.outShape;const $=n==="avg";let C="0.0";if($||(C="-1.0 / 1e-20"),r){const q=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${S});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${q} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let L=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(L="avgValue / max(count, 1.0)");const V=Math.floor(i/4)*4,z=i%4,K=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${S});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${V}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${K}
            }

            int xC = xCCorner + ${V};
            if (${z===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${K}
            } else if (${z===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${K}
            } else if (${z===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${K}
            }
          }
        }
        setOutput(${L});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Su(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,c=1;I(ir(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=ui(s.shape,o,i,c,a,u);if(l.filterWidth===1&&l.filterHeight===1&&Pt(l.inShape,l.outShape))return sr({inputs:{x:s},backend:n});const h=new lu(l,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const t4={kernelName:sy,backendName:"webgl",kernelFunc:e4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:c}=r,l=[1,1,1],h=yu(s.shape,o,i,l,a,u,c),f=new cd(h,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const r4={kernelName:oy,backendName:"webgl",kernelFunc:n4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s4{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=u-1-e.padInfo.top,h=c-1-e.padInfo.left,f=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class o4{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,m=h-1-e.padInfo.front,x=f-1-e.padInfo.top,g=d-1-e.padInfo.left,y=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${x}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:c,dimRoundingMode:l}=r,h=[1,1,1],f=yu(i.shape,a,u,h,c,l),d=new o4(f);return n.runWebGLProgram(d,[s],i.dtype)}const a4={kernelName:ST,backendName:"webgl",kernelFunc:i4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;Su([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,l=ui(i.shape,a,u,1,c),h=new s4(l);return n.runWebGLProgram(h,[s],i.dtype)}const c4={kernelName:wT,backendName:"webgl",kernelFunc:u4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return xc({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const h4={kernelName:iy,backendName:"webgl",kernelFunc:l4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f4{constructor(e,n,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],nt(e,n),nt(e,r);let a="0.0";s!=null&&(nt(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";o!=null&&(nt(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d4{constructor(e,n,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],nt(e,n),nt(e,r);let a="vec4(0.0)";s!=null&&(nt(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(nt(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p4=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;I(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);const c=[r,s,o];let l=null;i!=null&&(l=i.shape,c.push(i));let h=null;a!=null&&(h=a.shape,c.push(a));const f=G().getBool("WEBGL_PACK_NORMALIZATION")?new d4(r.shape,s.shape,o.shape,l,h,u):new f4(r.shape,s.shape,o.shape,l,h,u);return e.runWebGLProgram(f,c,c[0].dtype)},m4={kernelName:Hy,backendName:"webgl",kernelFunc:p4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g4{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=pt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=y4(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${Dh[a]} = start[${a}] + coords.${Dh[a]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const Dh=["x","y","z","w","u","v"];function y4(t){if(t===1)return"sourceLoc";if(t<=6)return Dh.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x4{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=pt(this.rank),r=kn("coords",this.rank),s=kn("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((l,h)=>`start[${h}]`).join()});`:e.map((l,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=t.dtype;let a=Qf(e,an(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}function fa(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,u]=Cb(s,o,i);if(db(s,a,u),ae(u)===0)return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=n.texData.get(s.dataId),f=h3(h.values,a,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,f)}const{isPacked:c}=n.texData.get(s.dataId),l=Yf(s.shape,a,u);if(c||!l){const h=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x4(u):new g4(u),f=[a];return n.runWebGLProgram(h,[s],s.dtype,f)}return n.uploadToGPU(s.dataId),b4(s,a,u,n)}const v4={kernelName:tx,backendName:"webgl",kernelFunc:fa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w4=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;I(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((S,$)=>S*$),u=Jf(s.shape,o,a),c=ed(u.length,o.length),l=td(s.shape,o,a),h=Rb(i,o.length),f=Ab(l,i,o.length),d=[],m=pe({inputs:{x:s},backend:n,attrs:{shape:u}}),x=An({inputs:{x:m},backend:n,attrs:{perm:c}}),g=pe({inputs:{x},backend:n,attrs:{shape:l}}),y=fa({inputs:{x:g},backend:n,attrs:{begin:h,size:f}});return d.push(m),d.push(x),d.push(g),d.forEach(S=>n.disposeIntermediateTensorInfo(S)),y},S4={kernelName:ay,backendName:"webgl",kernelFunc:w4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=n.readSync(s.dataId),u=n.readSync(o.dataId),c=wv(a,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}const $4={kernelName:uy,backendName:"webgl",kernelFunc:C4};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T4=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,N4=`
  return float(int(a.r) & int(b.r));
`;function E4(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=G().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const u=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[l,h]=PL(r.shape,s.shape,u,c,r.dtype),f=n.makeTensorInfo(h,r.dtype),d=n.texData.get(f.dataId);return d.values=l,f}let a;return o?a=new la(T4,r.shape,s.shape,!1):a=new si(N4,r.shape,s.shape),n.runWebGLProgram(a,[r,s],r.dtype)}const _4={kernelName:cy,backendName:"webgl",kernelFunc:E4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.readSync(r.dataId),i=n.readSync(s.dataId),a=nt(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const k4={kernelName:ly,backendName:"webgl",kernelFunc:I4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R4="return float(a != b);",Pv=hn({opSnippet:R4,cpuKernelImpl:n3,dtype:"bool"}),A4={kernelName:T0,backendName:"webgl",kernelFunc:Pv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return sr({inputs:{x:s.complexTensorInfos.real},backend:n})}const O4={kernelName:V0,backendName:"webgl",kernelFunc:$u};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4="return float(int(x));";function P4(t,e){const n=new ds(t.shape,D4),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return sr({inputs:{x:s},backend:n});const i=ei(s.shape),a=Ph({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=wo({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(a),u}if(s.dtype==="complex64"){const i=$u({inputs:{input:s},backend:n}),a=Ph({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(i),a}if(!hT(s.dtype,o)){const i=sr({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[a,u,c]=FL(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,u,c)}if(o==="int32")return P4(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",ho("bool",1)),u=Pv({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const F4={kernelName:wf,backendName:"webgl",kernelFunc:Ph};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xp="return ceil(x);",L4=et({opSnippet:Xp,packedOpSnippet:Xp,cpuKernelImpl:LL}),B4={kernelName:hy,backendName:"webgl",kernelFunc:L4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M4{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V4{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;G().getBool("WEBGL_PACK_CLIP")?a=new V4(s.shape):a=new M4(s.shape);const u=[[o],[i]];return n.runWebGLProgram(a,[s],s.dtype,u)}const W4={kernelName:fy,backendName:"webgl",kernelFunc:U4};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z4{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yp(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function G4(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),o=new z4(r.shape),i=[Yp(r,s.complexTensorInfos.real),Yp(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}const j4={kernelName:py,backendName:"webgl",kernelFunc:G4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H4{constructor(e){this.outputShape=[],this.outputShape=ri(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const a=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K4{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ri(e,n);const r=this.outputShape,s=r.length,o=pt(s),i=kn("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((x,g)=>`T${g}`);const u=new Array(e.length-1);u[0]=e[0][n];for(let x=1;x<u.length;x++)u[x]=u[x-1]+e[x][n];const c=a[n],l=a.slice(-2),h=a.join();let f=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${h}), vec2(${l.join()}));
        }`;for(let x=1;x<u.length;x++){const g=u[x-1];f+=`
        if (${c} < ${u[x]}  && ${c} >= ${u[x-1]}) {
          return getChannel(
            getT${x}(${Uu(a,c,g)}),
            vec2(${Uu(l,c,g)}));
        }`}const d=u.length,m=u[u.length-1];f+=`
        return getChannel(
          getT${d}(${Uu(a,c,m)}),
          vec2(${Uu(l,c,m)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${f}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Uu(t,e,n){const r=t.indexOf(e);return t.map((o,i)=>i===r?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return sr({inputs:{x:s.complexTensorInfos.imag},backend:n})}const q4={kernelName:Zy,backendName:"webgl",kernelFunc:il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(t,e,n){const r=t[0].dtype;if(r==="complex64"){const d=t.map(S=>$u({inputs:{input:S},backend:n})),m=t.map(S=>il({inputs:{input:S},backend:n})),x=Oa(d,e,n),g=Oa(m,e,n),y=wo({inputs:{real:x,imag:g},backend:n});return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),m.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),y}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const d=t.map(C=>{const L=[-1,ae(C.shape.slice(e))];return pe({inputs:{x:C},backend:n,attrs:{shape:L}})}),m=d.map(C=>({vals:n.readSync(C.dataId),shape:C.shape})),x=ri(d.map(C=>C.shape),1),g=d[0].shape[0]===1,y=BL(m,x,r,g),S=ri(t.map(C=>C.shape),e),$=n.makeTensorInfo(S,r,y);return d.forEach(C=>n.disposeIntermediateTensorInfo(C)),$}const o=t.filter(d=>ae(d.shape)>0),i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const d=i?new ds(t[0].shape,so):new io(t[0].shape,so);return n.runWebGLProgram(d,t,r)}const a=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const d=[];for(let x=0;x<o.length;x+=a){const g=o.slice(x,x+a);d.push(Oa(g,e,n))}const m=Oa(d,e,n);for(const x of d)n.disposeIntermediateTensorInfo(x);return m}if(i){const d=new K4(o.map(m=>m.shape),e);return n.runWebGLProgram(d,o,r)}const{tensors2D:u,outShape:c}=X4(o,e,n),l=new H4(u.map(d=>d.shape)),h=n.runWebGLProgram(l,u,r);u.forEach(d=>n.disposeIntermediateTensorInfo(d));const f=pe({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),f}function X4(t,e,n){const r=ri(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>pe({inputs:{x:o},attrs:{shape:[-1,ae(o.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fv(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=en(s,e[0].shape)[0],i=e.map(c=>c.shape);Tb(i,o);const a=ri(e.map(c=>c.shape),o);if(ae(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(c=>ae(c.shape)>0);return u.length===1?sr({inputs:{x:u[0]},backend:n}):Oa(u,o,n)}const Y4={kernelName:my,backendName:"webgl",kernelFunc:Fv};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lv{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,d=e.filterWidth,m=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,S=g?2:3,$=g?3:1;let C="",_="";r&&(s?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:C=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");const L=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${S}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${L}
        ${_}
        setOutput(result);
      }
    `}}class Q4{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,d=e.filterWidth,m=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bv{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=yn(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,h=l;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<l;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<l;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*u};
           `,a===1){if(y<l&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<l)){const S=i%2===0?yf(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${S};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):S===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${S};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<l&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<l&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<l&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<l&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<l&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",m="";r&&(s?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:o?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z4{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=yn(this.outputShape.length);const{dataFormat:r}=n,s=On(),o=r==="channelsLast",i=o?1:2,a=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let l=0;l<=1;l++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${l};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bc(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function Mv({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=t.shape,c=r.texData.get(t.dataId),l=n.inChannels,h=u[0]*u[1]*u[2],f=n.outChannels,d=n.dataFormat==="channelsLast",m=!1,x=!1;let g;const y=[];if(o!=null){const C=bc(o.shape,d);C!=null&&(o=pe({inputs:{x:o},backend:r,attrs:{shape:C}}),y.push(o))}if(s!=null){const C=bc(s.shape,d);C!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:C}}),y.push(s))}if(!((h===1||f===1)&&l>Rv)&&c.isPacked&&d&&c.texture!=null&&u[2]%2!==0&&Pt(c.shape.slice(-3),u.slice(-3))){const C=u[0]*u[1]*(u[2]+1),_={dataId:t.dataId,shape:[1,C,n.inChannels],dtype:t.dtype},L=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,I(gc(c.shape,_.shape),()=>`packed reshape ${c.shape} to ${_.shape} isn't free`);const V=pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(V);const z=xc({a:_,b:V,backend:r,transposeA:m,transposeB:x,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),K=r.texData.get(z.dataId);I(K.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=L,K.shape=n.outShape,g=sr({inputs:{x:z},backend:r}),g.shape=n.outShape,y.push(z)}else{const C=n.outHeight*n.outWidth,_=pe({inputs:{x:t},backend:r,attrs:{shape:d?[n.batchSize,C,n.inChannels]:[n.batchSize,n.inChannels,C]}}),L=pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),V=xc({a:d?_:L,b:d?L:_,transposeA:!d,transposeB:x,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=pe({inputs:{x:V},backend:r,attrs:{shape:n.outShape}}),y.push(_),y.push(L),y.push(V)}for(const C of y)r.disposeIntermediateTensorInfo(C);return g}function Vv({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:c,inChannels:l,outWidth:h,outHeight:f,dataFormat:d}=n,m=d==="channelsLast",x=u*c*l,g=f*h,y=[n.batchSize,x,g],S=!0,$=!1,C=[];if(o!=null){const Ie=bc(o.shape,m);Ie!=null&&(o=pe({inputs:{x:o},backend:r,attrs:{shape:Ie}}),C.push(o))}if(s!=null){const Ie=bc(s.shape,m);Ie!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:Ie}}),C.push(s))}const _=pe({inputs:{x:e},backend:r,attrs:{shape:[1,x,ae(e.shape)/x]}});C.push(_);const L=new Z4(y,n),V=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],z=r.runWebGLProgram(L,[t],"float32",V),K=pe({inputs:{x:z},backend:r,attrs:{shape:y}});C.push(z),C.push(K);const q=s!=null,Z=o!=null,fe=a==="leakyrelu",xe=a?cu(a,!0):null,$e=new kv(m?K.shape:_.shape,m?_.shape:K.shape,m?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],S,$,q,xe,Z,fe),Te=m?[K,_]:[_,K];if(s&&Te.push(s),Z&&Te.push(o),fe){const Ie=r.makeTensorInfo([],"float32",na(i,"float32"));Te.push(Ie),C.push(Ie)}const ke=r.runWebGLProgram($e,Te,"float32"),Ee=pe({inputs:{x:ke},backend:r,attrs:{shape:n.outShape}});C.push(ke);for(const Ie of C)r.disposeIntermediateTensorInfo(Ie);return Ee}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:c,dimRoundingMode:l}=r,h=ra(u),f=br(s.shape,o.shape,i,c,a,l,!1,h);let d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=Mv({x:s,filter:o,convInfo:f,backend:n});else if(f.strideWidth<=2&&h==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){const x=new Bv(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=n.runWebGLProgram(x,[s,o],"float32",g)}else if(G().getBool("WEBGL_CONV_IM2COL"))d=Vv({x:s,filter:o,convInfo:f,backend:n});else{const x=new Lv(f);d=n.runWebGLProgram(x,[s,o],"float32")}const m=pe({inputs:{x:d},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(d),m}const eM={kernelName:gy,backendName:"webgl",kernelFunc:J4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tM{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nM{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,u=r-1-e.padInfo.left,c=i?1:2,l=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class rM{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class sM{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=n-1-e.padInfo.front,c=r-1-e.padInfo.top,l=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,h=ra(u),f=br(s.shape,l,i,1,a,c,!1,h),d=new tM(f);return n.runWebGLProgram(d,[s,o],"float32")}const iM={kernelName:yy,backendName:"webgl",kernelFunc:oM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aM{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=yn(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,o=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:c,dimRoundingMode:l}=r,h=ra(c),f=br(i,o.shape,a,1,u,l,!1,h);if(G().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const d=[[f.strideHeight,f.strideWidth]],m=new aM(f);return n.runWebGLProgram(m,[s,o],"float32",d)}else{const d=new nM(f);return n.runWebGLProgram(d,[s,o],"float32")}}const cM={kernelName:xy,backendName:"webgl",kernelFunc:uM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,c=xu(s.shape,o.shape,i,u,a),l=new Q4(c);return n.runWebGLProgram(l,[s,o],"float32")}const hM={kernelName:by,backendName:"webgl",kernelFunc:lM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:u}=r,c=xu(s.shape,u,i,1,a),l=new rM(c);return n.runWebGLProgram(l,[s,o],"float32")}const dM={kernelName:CT,backendName:"webgl",kernelFunc:fM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:u}=r,c=xu(u,o.shape,a,1,i),l=new sM(c);return n.runWebGLProgram(l,[s,o],"float32")}const mM={kernelName:vy,backendName:"webgl",kernelFunc:pM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM=ha+`
  return cos(x);
`,yM=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${pi}
  return result;
`,xM=et({opSnippet:gM,packedOpSnippet:yM}),bM={kernelName:wy,backendName:"webgl",kernelFunc:xM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,wM=et({opSnippet:vM}),SM={kernelName:Sy,backendName:"webgl",kernelFunc:wM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CM{constructor(e,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,u,c]=e,[l]=n,[h,f]=r;this.outputShape=[l,h,f,c];const d=s==="bilinear"?1:0,[m,x]=[`${a-1}.0`,`${u-1}.0`],[g,y,S]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[$,C,_]=f>1?[`${(u-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${C};

        float in_y = ${S};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $M=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:c}=r,l=new CM(s.shape,o.shape,a,u,c);return n.runWebGLProgram(l,[s,o,i],"float32")},TM={kernelName:Ty,backendName:"webgl",kernelFunc:$M};var hu;(function(t){t.Prod="*",t.Sum="+"})(hu||(hu={}));class Qp{constructor(e,n,r,s){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===hu.Prod?"1.0":"0.0",a=r?i:`getX(${Zp(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",l="";r?(c=s?`end != ${u-1}`:"end != 0",l=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${u}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${pt(o)} coords = getOutputCoords();
        int end = ${Jp(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${l};
          ${Jp(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${Zp(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Zp(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function Jp(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(t,e,n,r,s,o){const i=e.shape.length,a=Pr([r],i);let u=e;a!=null&&(u=An({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=Fr(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const l=u.shape[c];let h=sr({inputs:{x:u},backend:n});for(let f=0;f<=Math.ceil(Math.log2(l))-1;f++){const d=new Qp(t,u.shape,!1,o),m=[[f]],x=h;h=n.runWebGLProgram(d,[h],h.dtype,m),n.disposeIntermediateTensorInfo(x)}if(s){const f=new Qp(t,u.shape,s,o),d=h;h=n.runWebGLProgram(f,[h],h.dtype),n.disposeIntermediateTensorInfo(d)}if(a!=null){const f=Rf(a),d=An({inputs:{x:h},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Uv(hu.Prod,s,n,o,i,a)}const EM={kernelName:Cy,backendName:"webgl",kernelFunc:NM};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _M(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Uv(hu.Sum,s,n,o,i,a)}const IM={kernelName:$y,backendName:"webgl",kernelFunc:_M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const u=n.readSync(s.dataId),c=n.readSync(o.dataId),l=wv(u,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}else if(s.shape.length===2){const u=n.bufferSync(s),c=n.bufferSync(o),l=DL(u,c,i,a);return n.makeTensorInfo(l.shape,o.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const RM={kernelName:Ny,backendName:"webgl",kernelFunc:kM};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AM{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],h=u*o,f=c*o,d=l/(o*o),m=i==="NHWC"?[a,h,f,d]:[a,d,h,f],x=new AM(m,o,i);return n.runWebGLProgram(x,[s],s.dtype)}const DM={kernelName:Ey,backendName:"webgl",kernelFunc:OM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wv{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=yn(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels;let c="",l="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,l="result = activation(result);");const h=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zv{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=yn(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,h=e.filterWidth,f=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let y=0;y<h;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const S=y*2;if(d+=`
          xC = xCCorner + ${S*c};
          `,u===1){if(S<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }
              `,c===1&&S>0?d+=`
                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                  } else {
                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xC${S} = xTexelC${S};
                `,S+1<h)){const $=a%2===0?yf(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${S+1}.zw = vec2(0.0);
                    }
                    xTexelC${S+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                    } else {
                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                    }
                    `:d+=`
                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                    `):$===1?d+=`
                    xC${S+1} = xTexelC${S};
                    `:d+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${S+1}.zw = vec2(0.0);
                      }
                      xTexelC${S+1}Ready = 1;
                    }

                    xC${S+1} = xTexelC${S+1};
                    `}}else S<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.0);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
              `,S+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(
                  xTexelC${S}.xy, xTexelC${S+1}.xy);
              `,S+1<h&&(d+=`
                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                `)));S<h&&(d+=`
            wTexel = getW(r, ${S}, d1, q);
            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);
          `,S+1<h&&(d+=`
              wTexel = getW(r, ${S+1}, d1, q);
              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let m="",x="";r&&(s?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:c}=r;let l=u;l==null&&(l=[1,1]),I(ir(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const h=br(s.shape,o.shape,i,l,a,c,!0);let f;G().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new zv(h):f=new Wv(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(f,[s,o],"float32",d)}const FM={kernelName:_y,backendName:"webgl",kernelFunc:PM};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LM{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class BM{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=n-1-e.padInfo.top,a=r-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:c,filterShape:l}=r,h=br(s.shape,l,i,a,u,c,!0),f=new LM(h);return n.runWebGLProgram(f,[s,o],"float32")}const VM={kernelName:Iy,backendName:"webgl",kernelFunc:MM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UM(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:c,inputShape:l}=r,h=br(l,o.shape,i,a,u,c,!0),f=new BM(h);return n.runWebGLProgram(f,[s,o],"float32")}const WM={kernelName:ky,backendName:"webgl",kernelFunc:UM};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zM{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=ae(r.shape),i=pe({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new zM(o),u=n.runWebGLProgram(a,[i],i.dtype),c=pe({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}const jM={kernelName:Ry,backendName:"webgl",kernelFunc:GM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HM{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:c,dilationWidth:l}=e,{top:h,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,c=g1(s.shape,o.shape,i,a,"NHWC",u);let l;const h=new HM(c);l=n.runWebGLProgram(h,[s,o],"float32");const f=pe({inputs:{x:l},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(l),f}const qM={kernelName:Ay,backendName:"webgl",kernelFunc:KM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:u}=Ub(s,o.length);zb(i.length,u,o);const{path:c,steps:l}=Gb(a,u),h=l.length;let f=null,d=i.length;const m=[];for(let x=0;x<h;++x){for(const g of l[x]){const{permutationIndices:y,expandDims:S}=Wb(d,u[g]);let $;jb(y)?$=o[g]:($=An({inputs:{x:o[g]},backend:n,attrs:{perm:y}}),m.push($));const C=$.shape.slice();for(let _=0;_<S.length;++_)C.splice(S[_],0,1);Pt($.shape,C)||($=pe({inputs:{x:$},backend:n,attrs:{shape:C}}),m.push($)),f===null?f=$:(f=ud({inputs:{a:$,b:f},backend:n}),m.push(f))}x<h-1&&(c[x]>=0&&(f=ol({inputs:{x:f},backend:n,attrs:{axis:c[x]-(i.length-d),keepDims:!1}}),m.push(f)),d--)}for(const x of m)x!==f&&n.disposeIntermediateTensorInfo(x);return f}const YM={kernelName:Dy,backendName:"webgl",kernelFunc:XM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QM="return (x >= 0.0) ? x : (exp(x) - 1.0);",ZM=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,JM=et({opSnippet:QM,packedOpSnippet:ZM}),eV={kernelName:Py,backendName:"webgl",kernelFunc:JM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tV="return (b >= 0.0) ? a : a * (b + 1.0);",nV=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,rV=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(nV,r.shape,s.shape):new si(tV,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},sV={kernelName:$T,backendName:"webgl",kernelFunc:rV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oV=`
  return vec4(equal(a, b));
`,iV="return float(a == b);",aV=hn({opSnippet:iV,packedOpSnippet:oV,dtype:"bool",cpuKernelImpl:ML}),uV={kernelName:Ly,backendName:"webgl",kernelFunc:aV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cV=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Pb};
  float a1 = ${Fb};
  float a2 = ${Lb};
  float a3 = ${Bb};
  float a4 = ${Mb};
  float a5 = ${Vb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,lV=et({opSnippet:cV}),hV={kernelName:Fy,backendName:"webgl",kernelFunc:lV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fV=ha+`
  return exp(x);
`,dV=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gv=et({opSnippet:fV,packedOpSnippet:dV,cpuKernelImpl:VL,dtype:"float32"}),pV={kernelName:By,backendName:"webgl",kernelFunc:Gv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fh(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(I(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),pe({inputs:{x:o},backend:r,attrs:{shape:a}})}const mV={kernelName:My,backendName:"webgl",kernelFunc:Fh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const em="return exp(x) - 1.0;",gV=et({opSnippet:em,packedOpSnippet:em,cpuKernelImpl:UL}),yV={kernelName:Vy,backendName:"webgl",kernelFunc:gV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tm{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(t,e,n){const r=n.texData.get(t.dataId),s=ae(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=pe({inputs:{x:t},backend:n,attrs:{shape:[i,o]}}),u=a.shape,c=new tm("real",u,e),l=new tm("imag",u,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],f=n.runWebGLProgram(c,h,"float32"),d=n.runWebGLProgram(l,h,"float32"),m=wo({inputs:{real:f,imag:d},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d);const x=pe({inputs:{x:m},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(m),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(t){const{inputs:e,backend:n}=t,{input:r}=e;return jv(r,!1,n)}const bV={kernelName:Uy,backendName:"webgl",kernelFunc:xV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vV{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||mu(s),o==="string"){const i=Jt(o,ae(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new vV(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const wV={kernelName:Wy,backendName:"webgl",kernelFunc:Tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SV{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CV={kernelName:zy,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new SV(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nm="return floor(x);",$V=et({opSnippet:nm,packedOpSnippet:nm,cpuKernelImpl:WL}),TV={kernelName:Gy,backendName:"webgl",kernelFunc:$V};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,EV=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,_V=hn({opSnippet:NV,packedOpSnippet:EV,dtype:"int32"}),IV={kernelName:jy,backendName:"webgl",kernelFunc:_V};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kV{constructor(e){this.variableNames=["A"];const n=On(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RV{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=On(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AV={kernelName:ch,backendName:"webgl",kernelFunc:OV};let _i,Pl=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function OV(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[c,u],h=[c,u,o];if(a||i){const x=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(_i==null||x!==Pl)&&(Pl=x,_i=document.createElement("canvas").getContext("2d",{willReadFrequently:Pl})),_i.canvas.width=u,_i.canvas.height=c,_i.drawImage(s,0,0,u,c),s=_i.canvas}const f=n.makeTensorInfo(l,"int32");n.texData.get(f.dataId).usage=mr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const d=G().getBool("WEBGL_PACK")?new RV(h):new kV(h),m=n.runWebGLProgram(d,[f],"int32");return n.disposeData(f.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:m}=r,x=ra(l),g=br(s.shape,o.shape,u,h,c,f,!1,x);let y;const S=[],$=i!=null,C=a!=null,_=d==="leakyrelu",L=()=>{const z=[s,o],K=(q,Z)=>{if(Z==="NCHW"&&q.shape.length===1&&q.shape[0]!==1){const fe=pe({inputs:{x:q},backend:n,attrs:{shape:[q.shape[0],1,1]}});return S.push(fe),fe}return q};if($&&z.push(K(i,l)),C&&z.push(K(a,l)),_){const q=n.makeTensorInfo([],"float32",na(m,"float32"));z.push(q),S.push(q)}return z};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Mv({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:m});else if(g.strideWidth<=2&&x==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){const z=d?cu(d,!0):null,K=new Bv(g,$,z,C,_),q=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],Z=L();y=n.runWebGLProgram(K,Z,"float32",q)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=Vv({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:m});else{const z=d?cu(d,!1):null,K=new Lv(g,$,z,C,_),q=L();y=n.runWebGLProgram(K,q,"float32")}const V=pe({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return S.push(y),S.forEach(z=>n.disposeIntermediateTensorInfo(z)),V}const PV={kernelName:hh,backendName:"webgl",kernelFunc:DV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:c,dilations:l,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r,m=[];let x=l;x==null&&(x=[1,1]),I(ir(u,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${x}'`);const g=br(s.shape,o.shape,u,x,c,h,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,S=f?cu(f,y):null,$=[s,o],C=i!=null,_=a!=null,L=f==="leakyrelu";if(C&&$.push(i),_&&$.push(a),L){const q=n.makeTensorInfo([],"float32",na(d,"float32"));$.push(q),m.push(q)}let V;y?V=new zv(g,C,S,_,L):V=new Wv(g,C,S,_,L);const z=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],K=n.runWebGLProgram(V,$,"float32",z);return m.forEach(q=>n.disposeIntermediateTensorInfo(q)),K}const LV={kernelName:fh,backendName:"webgl",kernelFunc:FV};class BV{constructor(e,n,r,s){this.sliceDim=e,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=pt(r.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MV(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=ae(r.shape),[u,c,l,h]=fb(r,s),f=pe({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),d=pe({inputs:{x:r},backend:n,attrs:{shape:[ae(r.shape)/l,l]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=n.readSync(s.dataId),S=n.bufferSync(r),$=zL(y,S,r.dtype,c,i,l,h,r.shape,a);return n.makeTensorInfo(u,r.dtype,$.values)}const m=new BV(i,h,[c,l],r.shape),x=n.runWebGLProgram(m,[d,f],d.dtype),g=pe({inputs:{x},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(x),g}const VV={kernelName:qy,backendName:"webgl",kernelFunc:MV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UV{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=pt(this.rank),s=WV(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function WV(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,u=en(i,s.shape)[0];if(G().get("DEBUG")){const S=n.readSync(o.dataId),$=s.shape[u];for(let C=0;C<S.length;++C){const _=S[C];I(_<=$-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${$-1}]`)}}const c=iv(s,o,u,a),l=ae(o.shape),h=[],f=pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=pe({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});h.push(f),h.push(d);const m=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const S=n.bufferSync(d),$=n.bufferSync(f),C=GL($,S,m);return h.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.makeTensorInfo(c.outputShape,C.dtype,C.values)}const x=new UV(f.shape,m),g=n.runWebGLProgram(x,[f,d],f.dtype);h.push(g);const y=pe({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return h.forEach(S=>n.disposeIntermediateTensorInfo(S)),y}const zV={kernelName:Ky,backendName:"webgl",kernelFunc:Hv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GV="return float(a > b);",jV=`
  return vec4(greaterThan(a, b));
`,HV=hn({opSnippet:GV,packedOpSnippet:jV,cpuKernelImpl:jL,dtype:"bool"}),KV={kernelName:Xy,backendName:"webgl",kernelFunc:HV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qV="return float(a >= b);",XV=`
  return vec4(greaterThanEqual(a, b));
`,YV=hn({opSnippet:qV,packedOpSnippet:XV,dtype:"bool",cpuKernelImpl:HL}),QV={kernelName:Yy,backendName:"webgl",kernelFunc:YV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(t){const{inputs:e,backend:n}=t,{input:r}=e;return jv(r,!0,n)}const JV={kernelName:Qy,backendName:"webgl",kernelFunc:ZV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eU="return float(!isnan(x) && !isinf(x));",tU=et({opSnippet:eU,dtype:"bool"}),nU={kernelName:Jy,backendName:"webgl",kernelFunc:tU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rU="return float(isinf(x));",sU=et({opSnippet:rU,dtype:"bool"}),oU={kernelName:e0,backendName:"webgl",kernelFunc:sU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iU="return float(isnan(x));",aU=et({opSnippet:iU,dtype:"bool"}),uU={kernelName:t0,backendName:"webgl",kernelFunc:aU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cU="return float(a < b);",lU=`
  return vec4(lessThan(a, b));
`,hU=hn({opSnippet:cU,packedOpSnippet:lU,cpuKernelImpl:KL,dtype:"bool"}),fU={kernelName:r0,backendName:"webgl",kernelFunc:hU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dU="return float(a <= b);",pU=`
  return vec4(lessThanEqual(a, b));
`,mU=hn({opSnippet:dU,packedOpSnippet:pU,cpuKernelImpl:qL,dtype:"bool"}),gU={kernelName:s0,backendName:"webgl",kernelFunc:mU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=XL(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const xU={kernelName:o0,backendName:"webgl",kernelFunc:yU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bU=ha+`
  return x < 0.0 ? 0./0. : log(x);
`,vU=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,wU=et({opSnippet:bU,packedOpSnippet:vU,cpuKernelImpl:YL}),SU={kernelName:i0,backendName:"webgl",kernelFunc:wU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CU=ha+`
  return log(1.0 + x);
`,$U=et({opSnippet:CU}),TU={kernelName:a0,backendName:"webgl",kernelFunc:$U};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NU="return float(a >= 1.0 && b >= 1.0);",EU=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,_U=hn({opSnippet:NU,packedOpSnippet:EU,dtype:"bool"}),IU={kernelName:u0,backendName:"webgl",kernelFunc:_U};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU="return float(!(x >= 1.0));",RU=et({opSnippet:kU}),AU={kernelName:c0,backendName:"webgl",kernelFunc:RU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OU="return float(a >= 1.0 || b >= 1.0);",DU=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,PU=hn({opSnippet:OU,packedOpSnippet:DU,dtype:"bool"}),FU={kernelName:l0,backendName:"webgl",kernelFunc:PU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LU{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;this.outputShape=e;let u;const c=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BU{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;this.outputShape=e;let u;const c=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MU=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=r,c=G().getBool("WEBGL_PACK_NORMALIZATION")?new BU(s.shape,o,i,a,u):new LU(s.shape,o,i,a,u);return n.runWebGLProgram(c,[s],s.dtype)},VU={kernelName:h0,backendName:"webgl",kernelFunc:MU};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UU{constructor(e,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WU=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:c,beta:l}=r,h=new UU(s.shape,a,u,c,l);return n.runWebGLProgram(h,[s,o,i],s.dtype)},zU={kernelName:TT,backendName:"webgl",kernelFunc:WU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(t,e,n,r){const s=ae(e),i=ae(t.shape)/s,a=pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),u=mi(a,t.dtype,"max",r),c=pe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,u=en(o,s.shape);let c=u;const l=Pr(c,a),h=l!=null,f=n.shouldExecuteOnCPU([s]);let d=s;if(h){if(f){const $=n.texData.get(d.dataId).values,C=new Array(a);for(let V=0;V<C.length;V++)C[V]=s.shape[l[V]];const _=id($,s.shape,s.dtype,l,C);d=n.makeTensorInfo(C,s.dtype);const L=n.texData.get(d.dataId);L.values=_}else d=sl(s,l,n);c=Fr(c.length,a)}rs("max",c,a);const[m,x]=bs(d.shape,c);let g=m;i&&(g=vr(m,u));let y;if(f){const $=n.texData.get(d.dataId).values,C=QL($,ae(x),g,s.dtype);y=n.makeTensorInfo(g,s.dtype);const _=n.texData.get(y.dataId);_.values=C}else y=GU(d,x,g,n);return h&&n.disposeIntermediateTensorInfo(d),y}const jU={kernelName:f0,backendName:"webgl",kernelFunc:Kv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU=ad+`
  return max(a, b);
`,KU=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pi+`
  return result;
`,qU=hn({opSnippet:HU,packedOpSnippet:KU,cpuKernelImpl:ZL}),XU={kernelName:d0,backendName:"webgl",kernelFunc:qU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;Su(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,c=1;I(ir(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=ui(s.shape,o,i,c,a,u);if(l.filterWidth===1&&l.filterHeight===1&&Pt(l.inShape,l.outShape))return sr({inputs:{x:s},backend:n});const h=new lu(l,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const QU={kernelName:p0,backendName:"webgl",kernelFunc:YU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:c}=r,l=[1,1,1],h=yu(s.shape,o,i,l,a,c,u),f=new cd(h,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const JU={kernelName:m0,backendName:"webgl",kernelFunc:ZU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,u=i-1-e.padInfo.left,c=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class tW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,h=u-1-e.padInfo.front,f=c-1-e.padInfo.top,d=l-1-e.padInfo.left,m=u*c*l-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:c,dimRoundingMode:l}=r,h=[1,1,1],f=yu(i.shape,a,u,h,c,l),d=new cd(f,"max",!0),m=n.runWebGLProgram(d,[i],i.dtype),x=new tW(f),g=n.runWebGLProgram(x,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),g}const rW={kernelName:ET,backendName:"webgl",kernelFunc:nW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;Su([o,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:h}=r,f=ui(a.shape,u,c,1,l,h),d=!0,m=new lu(f,"max",d),x=n.runWebGLProgram(m,[a],a.dtype),g=new eW(f),y=n.runWebGLProgram(g,[s,x],a.dtype);return n.disposeIntermediateTensorInfo(x),y}const oW={kernelName:NT,backendName:"webgl",kernelFunc:sW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iW(t,e,n,r){let s=new lu(n,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");s=new lu(n,"max",!0,!0,e);const i=r.runWebGLProgram(s,[t],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aW={kernelName:g0,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,u=n;I(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];I(ir(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const l=ui(r.shape,s,o,c,i),[h,f]=iW(r,a,l,u);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uW(t,e,n,r){const s=ae(e),i=ae(t.shape)/s,a=pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),u=mi(a,"float32","mean",r),c=pe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cW={kernelName:y0,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,i=n,a=r.shape.length,u=en(o,r.shape);let c=u;const l=Pr(c,a),h=l!=null,f=i.shouldExecuteOnCPU([r]),d=[];let m=r;if(h){if(f){const C=i.texData.get(m.dataId).values,_=new Array(a);for(let z=0;z<_.length;z++)_[z]=r.shape[l[z]];const L=id(C,r.shape,r.dtype,l,_);m=i.makeTensorInfo(_,r.dtype);const V=i.texData.get(m.dataId);V.values=L}else m=sl(r,l,i);d.push(m),c=Fr(c.length,a)}rs("sum",c,a);const[x,g]=bs(m.shape,c);let y=x;s&&(y=vr(x,u));const S=uW(m,g,y,i);for(const $ of d)i.disposeIntermediateTensorInfo($);return S}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lW(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=en(o,s.shape);let c=u;const l=Pr(c,a);let h=s;l!=null&&(h=An({inputs:{x:s},backend:n,attrs:{perm:l}}),c=Fr(c.length,s.shape.length)),rs("min",c,a);const[f,d]=bs(h.shape,c),m=ae(d),x=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=mi(x,x.dtype,"min",n);let y;if(i){const S=vr(f,u);y=pe({inputs:{x:g},backend:n,attrs:{shape:S}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(h),y}const hW={kernelName:x0,backendName:"webgl",kernelFunc:lW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fW=ad+`
  return min(a, b);
`,dW=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pi+`
  return result;
`,pW=hn({opSnippet:fW,packedOpSnippet:dW,cpuKernelImpl:JL}),mW={kernelName:b0,backendName:"webgl",kernelFunc:pW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gW{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((l,h)=>l[0]+e[h]+l[1]);const s=e.length,o=pt(s),i=n.map(l=>l[0]).join(","),a=n.map((l,h)=>l[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yW{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((m,x)=>m[0]+e[x]+m[1]);const s=e.length,o=pt(s),i=n.map(m=>m[0]).join(","),a=n.map((m,x)=>m[0]+e[x]).join(","),u=kn("rc",s),c=kn("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let d="";if(s===1){const m=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${u[s-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const m=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${u[s-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${m}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${u[s-1]} += 1;
          if(${l}) {
            ${m}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xW=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:o}=n,i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yW(r.shape,s,o):new gW(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},bW={kernelName:v0,backendName:"webgl",kernelFunc:xW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=`if (b == 0.0) return NAN;
  return mod(a, b);`,wW=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+pi+`
  return result;
`,SW=hn({opSnippet:vW,packedOpSnippet:wW}),CW={kernelName:w0,backendName:"webgl",kernelFunc:SW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $W{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TW=`
if (a == b) {
  return 1.0;
};
return a / b;`,NW=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,qv=hn({opSnippet:TW,packedOpSnippet:NW,checkOutOfBounds:!0}),EW={kernelName:Oy,backendName:"webgl",kernelFunc:qv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rm="return a - b;",Xv=hn({opSnippet:rm,packedOpSnippet:rm,supportsComplex:!0,cpuKernelImpl:v3}),_W={kernelName:Cx,backendName:"webgl",kernelFunc:Xv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=en([o],s.shape),a=Kv({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=vr(a.shape,i),c=pe({inputs:{x:a},backend:n,attrs:{shape:u}}),l=Xv({inputs:{a:s,b:c},backend:n}),h=Gv({inputs:{x:l},backend:n}),f=ol({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),d=pe({inputs:{x:f},backend:n,attrs:{shape:u}}),m=qv({inputs:{a:h,b:d},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),m}const IW={kernelName:hx,backendName:"webgl",kernelFunc:Yv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,u=a?s:Yv({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=u.shape[0],l=u.shape[1],h=new $W(c,l,o),f=[[i]],d=n.runWebGLProgram(h,[u],"int32",f);return a||n.disposeIntermediateTensorInfo(u),d}const RW={kernelName:S0,backendName:"webgl",kernelFunc:kW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AW=Lr+`
  return -x;
`,OW=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function DW(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId),[i,a]=t3(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}let s;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new io(r.shape,OW):s=new ds(r.shape,AW),n.runWebGLProgram(s,[r],r.dtype)}const PW={kernelName:$0,backendName:"webgl",kernelFunc:DW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FW=nb;function LW(t){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,c=n.readSync(s.dataId),l=n.readSync(o.dataId),{selectedIndices:h}=FW(c,l,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const BW={kernelName:N0,backendName:"webgl",kernelFunc:LW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MW=rb;function VW(t){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r,l=n.readSync(s.dataId),h=n.readSync(o.dataId),{selectedIndices:f,validOutputs:d}=MW(l,h,i,a,u,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([d]))]}const UW={kernelName:E0,backendName:"webgl",kernelFunc:VW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=sb;function zW(t){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r,l=n.readSync(s.dataId),h=n.readSync(o.dataId),f=i,d=a,m=u,x=c,{selectedIndices:g,selectedScores:y}=WW(l,h,f,d,m,x);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const GW={kernelName:_0,backendName:"webgl",kernelFunc:zW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jW{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HW=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:u}=r,c=ae(s.shape),l=new jW(c,i,a,u),h=pe({inputs:{x:s},backend:n,attrs:{shape:[c]}}),f=n.runWebGLProgram(l,[h],o);n.disposeIntermediateTensorInfo(h);const d=[...s.shape,i],m=pe({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),m},KW={kernelName:k0,backendName:"webgl",kernelFunc:HW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vc(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=$u({inputs:{input:r},backend:n}),o=vc({inputs:{x:s},backend:n}),i=il({inputs:{input:r},backend:n}),a=vc({inputs:{x:i},backend:n}),u=wo({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return Tu({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const qW={kernelName:Rx,backendName:"webgl",kernelFunc:vc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=$u({inputs:{input:r},backend:n}),o=Qv({inputs:{x:s},backend:n}),i=il({inputs:{input:r},backend:n}),a=vc({inputs:{x:i},backend:n}),u=wo({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return Tu({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const XW={kernelName:I0,backendName:"webgl",kernelFunc:Qv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Fh({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(l=>{yr(o,l.shape,"All tensors passed to stack must have matching shapes"),I(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(l=>{const h=Fh({inputs:{input:l},backend:n,attrs:{dim:s}});return a.push(h),h}),c=Fv({inputs:u,backend:n,attrs:{axis:s}});return a.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}const QW={kernelName:R0,backendName:"webgl",kernelFunc:YW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZW{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,l)=>c[0]+e[l]+c[1]);const s=e.length,o=pt(s),i=n.map(c=>c[0]).join(","),a=n.map((c,l)=>c[0]+e[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JW{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,g)=>x[0]+e[g]+x[1]);const s=e.length,o=pt(s),i=n.map(x=>x[0]).join(","),a=n.map((x,g)=>x[0]+e[g]).join(","),u=kn("rc",s),c=kn("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${o} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${l}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${l}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let x=0,g=s===1?2:4;x<g;x++)m+=`
        ${f[x]}
        if (${d}) {
          result[${x}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${h});
        }
      `;m+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zv=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(ae(s.shape)===0){const c=o.map((l,h)=>l[0]+s.shape[h]+l[1]);return Tu({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JW(s.shape,o,i):new ZW(s.shape,o,i),u=[[i]];return n.runWebGLProgram(a,[s],s.dtype,u)},ez={kernelName:A0,backendName:"webgl",kernelFunc:Zv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tz=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,nz=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+pi+`
  return result;
`,rz=hn({opSnippet:tz,packedOpSnippet:nz}),sz={kernelName:O0,backendName:"webgl",kernelFunc:rz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oz(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=[],c=en(o,s.shape);let l=c;const h=Pr(l,a);let f=s;h!=null&&(f=An({inputs:{x:s},backend:n,attrs:{perm:h}}),l=Fr(l.length,a),u.push(f)),rs("prod",l,a);let d;if(n.shouldExecuteOnCPU([f])){const m=n.texData.get(f.dataId).values,{outVals:x,outShape:g,outDtype:y}=r3(f.shape,f.dtype,m,l);d=n.makeTensorInfo(g,y,x)}else{const[m,x]=bs(f.shape,l),g=ae(x),y=pe({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}}),S=Tf(s.dtype),$=mi(y,S,"prod",n);d=pe({inputs:{x:$},backend:n,attrs:{shape:m}}),u.push(y),u.push($)}if(i){u.push(d);const m=vr(d.shape,c);d=pe({inputs:{x:d},backend:n,attrs:{shape:m}})}return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),d}const iz={kernelName:P0,backendName:"webgl",kernelFunc:oz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function az(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=r,u=s.map(y=>n.readSync(y.dataId)),c=s.map(y=>y.shape),l=n.readSync(o.dataId),h=n.readSync(i.dataId),[f,d,m]=s3(u,c,l,o.shape,o.dtype,h,i.shape,a),x=f.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(m,o.dtype,d);return x.concat([g])}const uz={kernelName:F0,backendName:"webgl",kernelFunc:az};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cz(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:o}=e,i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[c,l]=o3(i,r.shape,r.dtype,a,s.shape,u,o.shape),h=n.makeTensorInfo([c.length],"int32",c),f=n.makeTensorInfo([l.length],r.dtype,l);return[h,f]}const lz={kernelName:L0,backendName:"webgl",kernelFunc:cz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=r,c=n.readSync(s.dataId),l=n.readSync(o.dataId),h=n.readSync(i.dataId),f=a.map(g=>n.readSync(g.dataId)),d=a.map(g=>g.shape),[m,x]=i3(c,s.shape,l,o.shape,o.dtype,h,i.shape,f,d,u);return n.makeTensorInfo(m,o.dtype,x)}const fz={kernelName:B0,backendName:"webgl",kernelFunc:hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jv=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=a3(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},dz={kernelName:M0,backendName:"webgl",kernelFunc:Jv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pz="return 1.0 / x;",mz=et({opSnippet:pz}),gz={kernelName:U0,backendName:"webgl",kernelFunc:mz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yz=Lr+`
  return (x < 0.0) ? 0.0 : x;
`,xz=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bz=et({opSnippet:yz,packedOpSnippet:xz}),vz={kernelName:W0,backendName:"webgl",kernelFunc:bz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wz=Lr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Sz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Cz=et({opSnippet:wz,packedOpSnippet:Sz}),$z={kernelName:H0,backendName:"webgl",kernelFunc:Cz};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tz{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,c]=e;this.outputShape=[i,n,r,c];const l=[s&&n>1?a-1:a,s&&r>1?u-1:u],h=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;o?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/h[0]},
          ${l[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nz{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,c]=e;this.outputShape=[i,n,r,c];const l=[s&&n>1?a-1:a,s&&r>1?u-1:u],h=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;o?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/h[0]},
          ${l[1]/h[1]},
          ${l[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ez(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,c]=a,l=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Nz(s.shape,u,c,o,i):new Tz(s.shape,u,c,o,i);return n.runWebGLProgram(l,[s],"float32")}const _z={kernelName:j0,backendName:"webgl",kernelFunc:Ez};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iz{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=u[0]/c[0],h=u[1]/c[1],f=1/l,d=1/h,m=Math.ceil(f)*2+2,x=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${m});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kz(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new Iz(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const Rz={kernelName:IT,backendName:"webgl",kernelFunc:kz};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Az{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,c]=e;this.outputShape=[i,n,r,c];const l=[s&&n>1?a-1:a,s&&r>1?u-1:u],h=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;o?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/h[0]},
          ${l[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oz{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,c]=e;this.outputShape=[i,n,r,c];const l=[s&&n>1?a-1:a,s&&r>1?u-1:u],h=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;o?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/h[0]},
          ${l[1]/h[1]},
          ${l[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,c]=a,l=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Oz(s.shape,u,c,o,i):new Az(s.shape,u,c,o,i);return n.runWebGLProgram(l,[s],s.dtype)}const Pz={kernelName:G0,backendName:"webgl",kernelFunc:Dz};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fz{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=u[0]/c[0],h=u[1]/c[1],f=1/l,d=1/h,m=Math.ceil(f)*2+2,x=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${m});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new Fz(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const Bz={kernelName:_T,backendName:"webgl",kernelFunc:Lz};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mz{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,u)=>s(u)).join(","),i=pt(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vz{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=kn("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=pt(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${i}) {
            result.b = ${l(s.slice())};
            if(${o}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(m){return f(m)}function c(m){return m[r-1]="("+m[r-1]+" + 1)",f(m)}function l(m){return m[r-2]="("+m[r-2]+" + 1)",f(m)}function h(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",f(m)}function f(m){const x=e.map((S,$)=>d($,m)),g=x.join(","),y=x.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function d(m,x){return n.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${x[m]} - 1`:`${x[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length,a=en(o,s.shape);if(i===0)return sr({inputs:{x:s},backend:n});const u=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vz(s.shape,a):new Mz(s.shape,a);return n.runWebGLProgram(u,[s],s.dtype)}const Wz={kernelName:K0,backendName:"webgl",kernelFunc:Uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zz{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gz={kernelName:Ox,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,u=new zz(r.shape,o),[c,l]=kb(i,r.shape[1],r.shape[2]),h=[[c,l,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(u,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jz=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Hz=et({opSnippet:jz}),Kz={kernelName:q0,backendName:"webgl",kernelFunc:Hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qz="return inversesqrt(x);",Xz=et({opSnippet:qz,cpuKernelImpl:u3}),Yz={kernelName:X0,backendName:"webgl",kernelFunc:Xz};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ld{constructor(e,n,r,s,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=pt(o.length),l=pt(i.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const m=`getUpdates(${d})`;let x="";u&&(x="coords[0], coords[1]");const g=`getDefaultValue(${x})`,y=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qz{constructor(e,n,r,s,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=pt(o.length),l=pt(i.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const m=`getUpdates(${d})`;let x="";u&&(x="coords[0], coords[1]");const g=`getDefaultValue(${x})`,y=n>1?"strides[j]":"strides",S=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${S};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=Xc(o,s,i),f=[h/c,c];if(h===0)return n.makeTensorInfo(i,s.dtype);const d=pe({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),m=pe({inputs:{x:o},backend:n,attrs:{shape:[u,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;G().getBool("WEBGL_PACK")?g=new Qz(u,a,d.shape.length,m.shape.length,l,f):g=new ld(u,a,d.shape.length,m.shape.length,l,f);const y=n.runWebGLProgram(g,[m,d,x],m.dtype),S=pe({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),S}const Jz={kernelName:Y0,backendName:"webgl",kernelFunc:Zz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eG{constructor(e,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=G().getNumber("WEBGL_VERSION")===2?o:i,u=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tG(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new eG(s.shape[0],s.shape[1],o.shape[1],i),u=[[s.shape[1]]];return n.runWebGLProgram(a,[s,o],"int32",u)}const nG={kernelName:Z0,backendName:"webgl",kernelFunc:tG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rG{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let l=0;l<n.length;l++)c.push(`${a[l]}`),l<e&&u.push(`${a[l]}`);s=u.join(),o=c.join()}const i=pt(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new rG(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],xs(s.dtype,o.dtype))}const oG={kernelName:J0,backendName:"webgl",kernelFunc:sG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iG=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Ob};
  float scale = ${Db};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,aG=et({opSnippet:iG}),uG={kernelName:ex,backendName:"webgl",kernelFunc:aG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cG=ha+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,lG=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hG=et({opSnippet:cG,packedOpSnippet:lG,cpuKernelImpl:l3}),fG={kernelName:ox,backendName:"webgl",kernelFunc:hG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,pG=et({opSnippet:dG}),mG={kernelName:sx,backendName:"webgl",kernelFunc:pG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gG=ha+`
  return sin(x);
`,yG=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${pi}
  return result;
`,xG=et({opSnippet:gG,packedOpSnippet:yG}),bG={kernelName:nx,backendName:"webgl",kernelFunc:xG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vG=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,wG=et({opSnippet:vG}),SG={kernelName:rx,backendName:"webgl",kernelFunc:wG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,$G=et({opSnippet:CG}),TG={kernelName:ix,backendName:"webgl",kernelFunc:$G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;I(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,S)=>y*S),u=[[0,0]];u.push(...i);for(let y=1+o.length;y<s.shape.length;++y)u.push([0,0]);const c=[],l=Zv({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=Jf(l.shape,o,a,!1),f=ed(h.length,o.length,!1),d=td(l.shape,o,a,!1),m=pe({inputs:{x:l},backend:n,attrs:{shape:h}}),x=An({inputs:{x:m},backend:n,attrs:{perm:f}}),g=pe({inputs:{x},backend:n,attrs:{shape:d}});return c.push(l),c.push(m),c.push(x),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},EG={kernelName:cx,backendName:"webgl",kernelFunc:NG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(o.dataId),l=n.readSync(i.dataId)[0],[h,f,d,m,x]=f3(a,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(f,r.dtype,h),n.makeTensorInfo([f[0]],s.dtype,d),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const IG={kernelName:fx,backendName:"webgl",kernelFunc:_G};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kG(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),u=Array.from(n.readSync(o.dataId)),[c,l,h]=d3(a,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const RG={kernelName:dx,backendName:"webgl",kernelFunc:kG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[c,l]=Cv(i,r.shape,r.dtype,a,u,!0);return n.makeTensorInfo(l,r.dtype,c)}const OG={kernelName:px,backendName:"webgl",kernelFunc:AG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DG(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[c,l]=Cv(i,r.shape,r.dtype,a,u);return n.makeTensorInfo(l,r.dtype,c)}const PG={kernelName:mx,backendName:"webgl",kernelFunc:DG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FG(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:h,outputSize:f}=Xc(o,s,a),d=!1;if(o.dtype==="string"){const y=n.bufferSync(s),S=n.bufferSync(o),$=qi(n.readSync(i.dataId)[0]),C=c3(y,S,a,f,l,c,u,h,$,d);return n.makeTensorInfo(a,C.dtype,C.values)}const m=new ld(c,u,s.shape.length,o.shape.length,h,[f,1],d),x=n.runWebGLProgram(m,[o,s,i],o.dtype),g=pe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(x),g}const LG={kernelName:gx,backendName:"webgl",kernelFunc:FG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=en(i,s.shape)[0],u=Hb(s,o,a),c=s.shape.length,l=new Array(c).fill(0),h=s.shape.slice();return u.map(f=>{const d=[...h];d[a]=f;const m=fa({inputs:{x:s},backend:n,attrs:{begin:l,size:d}});return l[a]+=f,m})}const MG={kernelName:lx,backendName:"webgl",kernelFunc:BG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sm="return sqrt(x);",VG=et({opSnippet:sm,packedOpSnippet:sm,cpuKernelImpl:p3}),UG={kernelName:ax,backendName:"webgl",kernelFunc:VG};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WG="return x * x;",zG=et({opSnippet:WG}),GG={kernelName:kT,backendName:"webgl",kernelFunc:zG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const om="return (a - b) * (a - b);",jG=hn({opSnippet:om,packedOpSnippet:om}),HG={kernelName:yx,backendName:"webgl",kernelFunc:jG};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const o=n.readSync(s.dataId),i=Qi(o),a=m3(i,"string",r);return n.makeTensorInfo(s.shape,"string",a)}const qG={kernelName:xx,backendName:"webgl",kernelFunc:KG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=Lr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new ds(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const YG={kernelName:Ax,backendName:"webgl",kernelFunc:XG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QG{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=pt(r.length),i=pt(r.length);let a="";if(s===1)a="coords * strides + begin";else{let u=0;a=r.map((c,l)=>(u++,r.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${u-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:m,isIdentity:x,sliceDim0:g,isSimpleSlice:y,begin:S,end:$,strides:C}=$b(s.shape,o,i,a,u,c,l,h,f);let _;if(x)_=pe({inputs:{x:s},backend:n,attrs:{shape:m}});else if(g||y){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const V=pb(S,$,C),z=fa({inputs:{x:s},backend:n,attrs:{begin:S,size:V}});_=pe({inputs:{x:z},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(z)}else if(n.shouldExecuteOnCPU([s])){const z=n.readSync(s.dataId),K=Ft(s.shape,s.dtype,z),q=g3(d,K,C,S);_=n.makeTensorInfo(m,s.dtype,q.values)}else{const z=new QG(S,C,d);_=n.runWebGLProgram(z,[s],s.dtype)}const L=pe({inputs:{x:_},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(_),L}const JG={kernelName:bx,backendName:"webgl",kernelFunc:ZG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ej(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:h}=e,f=n.readSync(l.dataId),d=n.readSync(h.dataId),[m,x]=y3(f,d,s,o,i,a,u,c);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",x)]}const tj={kernelName:vx,backendName:"webgl",kernelFunc:ej};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[c,l,h]=x3(a,u,s),f=l.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const rj={kernelName:wx,backendName:"webgl",kernelFunc:nj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=b3(i,s);return n.makeTensorInfo(o.shape,"int32",a)}const oj={kernelName:Sx,backendName:"webgl",kernelFunc:sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij="return tan(x);",aj=et({opSnippet:ij}),uj={kernelName:$x,backendName:"webgl",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cj=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,lj=et({opSnippet:cj}),hj={kernelName:Tx,backendName:"webgl",kernelFunc:lj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=Xc(i,o,s.shape),f=[h/c,c];if(h===0)return n.makeTensorInfo(s.shape,o.dtype);const d=pe({inputs:{x:o},backend:n,attrs:{shape:[u,a]}}),m=pe({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),x=pe({inputs:{x:s},backend:n,attrs:{shape:f}}),g=new ld(u,a,d.shape.length,m.shape.length,l,f,!1,!0),y=n.runWebGLProgram(g,[m,d,x],x.dtype),S=pe({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),S}const dj={kernelName:Q0,backendName:"webgl",kernelFunc:fj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pj{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*n[i];this.outputShape=r,this.rank=r.length;const s=pt(this.rank),o=mj(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function mj(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const u=n.readSync(s.dataId),c=s.dtype==="string"?u.map(f=>qi(f)):u,l=Ft(s.shape,s.dtype,c),h=w3(l,o);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new pj(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const gj={kernelName:Cf,backendName:"webgl",kernelFunc:ew};class yj{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class xj{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function im(t){let e=1;for(;e<t;)e*=2;return e}function bj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,l=c[c.length-1];if(n.shouldExecuteOnCPU([s])||l<a||o>u){const q=n.readSync(s.dataId),[Z,fe]=S3(q,c,s.dtype,o,i);return[n.makeTensorInfo(Z.shape,Z.dtype,Z.values),n.makeTensorInfo(fe.shape,fe.dtype,fe.values)]}if(o===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(l===1)return[s,Tu({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),f=h!==null&&h.isPacked,d=f?n.unpackTensor(s):s,x=ae(c)/l,g=pe({inputs:{x:d},attrs:{shape:[x,l]},backend:n});f&&Ao(n,d);const y=im(o),S=im(l);let $=null;const C=()=>$===null?[g,g]:[g,$],_=(q,Z,fe)=>{const xe=C(),$e=new yj(fe),ke=[[l],[$===null?1:0],[Number.NEGATIVE_INFINITY],[q],[Z]],Ee=$;$=n.runWebGLProgram($e,xe,"int32",ke),Ao(n,Ee)};for(let q=1;q<y;q*=2){const Z=q*2;for(let fe=q;fe>=1;fe/=2)_(Z,fe,[x,S])}for(let q=S;q>y;q/=2){const Z=C(),fe=new xj([x,q/2]),$e=[[l],[$===null?1:0],[y]],Te=$;$=n.runWebGLProgram(fe,Z,"int32",$e),Ao(n,Te);const ke=y/2,Ee=ke*2;for(let Ie=ke;Ie>=1;Ie/=2)_(Ee,Ie,$.shape)}let L=$;$=fa({inputs:{x:$},backend:n,attrs:{begin:0,size:[x,o]}}),Ao(n,L);let V=Hv({inputs:{x:g,indices:$},backend:n,attrs:{axis:1,batchDims:1}});Ao(n,g);const z=c.slice(0,-1);z.push(o),L=$,$=pe({inputs:{x:$},attrs:{shape:z},backend:n}),Ao(n,L);const K=V;return V=pe({inputs:{x:V},attrs:{shape:z},backend:n}),Ao(n,K),[V,$]}const vj={kernelName:Nx,backendName:"webgl",kernelFunc:bj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wj{constructor(e,n,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:c}=r,[l,h,f,d]=s.shape,[m,x]=c??[h,f],g=[l,m,x,d],y=new wj(h,f,i,a,u,g);return n.runWebGLProgram(y,[s,o],"float32")}const Cj={kernelName:Ex,backendName:"webgl",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;Su(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:u,indices:c}=C3(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const Tj={kernelName:_x,backendName:"webgl",kernelFunc:$j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],c=new Array(a-1);let l=0;for(let x=0;x<a;x++)x!==o&&(c[l++]=i.shape[x]);const h=[],f=new Array(a).fill(0),d=i.shape.slice();d[o]=1;const m=new Array(u);for(let x=0;x<m.length;x++){f[o]=x;const g=fa({inputs:{x:i},backend:n,attrs:{begin:f,size:d}}),y=pe({inputs:{x:g},backend:n,attrs:{shape:c}});m[x]=y,h.push(g)}return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),m}const Ej={kernelName:Ix,backendName:"webgl",kernelFunc:Nj};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _j{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const u="0.0",c="sumValue",l=Math.floor(r/4)*4,h=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let m="";o%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${l};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ij(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,u=[];let c=0;const l=Pr([c],a);let h=s;l!=null&&(h=An({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(h),c=Fr(1,a)[0]);const f=ov(h.shape,c,i),d=ae([h.shape[c]]),m=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,d]}});u.push(m);const x=Tf(s.dtype),g=(C,_,L,V,z)=>{const K=C.shape[0],q=C.shape[1],Z=sv(q,z),fe={windowSize:Z,inSize:q,batchSize:K,numSegments:z},xe=new _j(fe,_),$e=n.compileAndRun(xe,[C,L],V);if(u.push($e),$e.shape[1]===z)return $e;const Te=Jv({backend:n,attrs:{start:0,stop:z,step:1,dtype:"float32"}}),ke=ew({inputs:{x:Te},backend:n,attrs:{reps:[q/Z]}});return u.push(Te),u.push(ke),g($e,_,ke,V,z)},y=g(m,"unsortedSegmentSum",o,x,i),S=pe({inputs:{x:y},backend:n,attrs:{shape:f}});let $=S;if(l!=null){u.push(S);const C=Rf(l);$=An({inputs:{x:$},backend:n,attrs:{perm:C}})}return u.forEach(C=>n.disposeIntermediateTensorInfo(C)),$}const kj={kernelName:kx,backendName:"webgl",kernelFunc:Ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rj=[pB,gB,bB,SB,$B,EB,IB,RB,PB,LB,VB,zB,HB,YB,JB,t4,r4,a4,c4,h4,m4,S4,$4,_4,k4,F4,B4,W4,Q3,j4,Y4,eM,iM,cM,hM,dM,mM,bM,SM,TM,EM,IM,RM,DM,FM,VM,WM,jM,qM,YM,eV,sV,uV,hV,pV,mV,yV,bV,wV,CV,TV,IV,AV,PV,LV,VV,zV,KV,QV,Y3,JV,q4,nU,oU,uU,J3,fU,gU,xU,SU,TU,IU,AU,FU,VU,zU,jU,XU,QU,JU,rW,oW,aW,cW,hW,mW,bW,CW,RW,nB,PW,BW,UW,GW,A4,KW,XW,QW,ez,sz,tB,iz,uz,lz,fz,dz,O4,EW,gz,vz,$z,sB,_z,Rz,Pz,Bz,Wz,Gz,Kz,Yz,Jz,nG,oG,uG,fG,mG,bG,SG,v4,IW,TG,EG,IG,RG,OG,PG,LG,MG,UG,GG,HG,qG,YG,JG,tj,rj,oj,_W,hB,uj,hj,dj,gj,vj,Cj,fB,Tj,Ej,kj,qW];for(const t of Rj)OT(t);var al={};(function(){var t;function e(p){var b=0;return function(){return b<p.length?{done:!1,value:p[b++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(p,b,w){return p==Array.prototype||p==Object.prototype||(p[b]=w.value),p};function r(p){p=[typeof globalThis=="object"&&globalThis,p,typeof window=="object"&&window,typeof self=="object"&&self,typeof Rr=="object"&&Rr];for(var b=0;b<p.length;++b){var w=p[b];if(w&&w.Math==Math)return w}throw Error("Cannot find global object")}var s=r(this);function o(p,b){if(b)e:{var w=s;p=p.split(".");for(var T=0;T<p.length-1;T++){var R=p[T];if(!(R in w))break e;w=w[R]}p=p[p.length-1],T=w[p],b=b(T),b!=T&&b!=null&&n(w,p,{configurable:!0,writable:!0,value:b})}}o("Symbol",function(p){function b(P){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new w(T+(P||"")+"_"+R++,P)}function w(P,O){this.h=P,n(this,"description",{configurable:!0,writable:!0,value:O})}if(p)return p;w.prototype.toString=function(){return this.h};var T="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",R=0;return b}),o("Symbol.iterator",function(p){if(p)return p;p=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),w=0;w<b.length;w++){var T=s[b[w]];typeof T=="function"&&typeof T.prototype[p]!="function"&&n(T.prototype,p,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return p});function i(p){return p={next:p},p[Symbol.iterator]=function(){return this},p}function a(p){var b=typeof Symbol<"u"&&Symbol.iterator&&p[Symbol.iterator];return b?b.call(p):{next:e(p)}}function u(p){if(!(p instanceof Array)){p=a(p);for(var b,w=[];!(b=p.next()).done;)w.push(b.value);p=w}return p}var c=typeof Object.assign=="function"?Object.assign:function(p,b){for(var w=1;w<arguments.length;w++){var T=arguments[w];if(T)for(var R in T)Object.prototype.hasOwnProperty.call(T,R)&&(p[R]=T[R])}return p};o("Object.assign",function(p){return p||c});var l=typeof Object.create=="function"?Object.create:function(p){function b(){}return b.prototype=p,new b},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},m={};try{m.__proto__=d,f=m.a;break e}catch{}f=!1}h=f?function(p,b){if(p.__proto__=b,p.__proto__!==b)throw new TypeError(p+" is not extensible");return p}:null}var x=h;function g(p,b){if(p.prototype=l(b.prototype),p.prototype.constructor=p,x)x(p,b);else for(var w in b)if(w!="prototype")if(Object.defineProperties){var T=Object.getOwnPropertyDescriptor(b,w);T&&Object.defineProperty(p,w,T)}else p[w]=b[w];p.ya=b.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function S(p){if(p.m)throw new TypeError("Generator is already running");p.m=!0}y.prototype.u=function(p){this.i=p};function $(p,b){p.l={ma:b,na:!0},p.h=p.s||p.v}y.prototype.return=function(p){this.l={return:p},this.h=this.v};function C(p,b,w){return p.h=w,{value:b}}function _(p){this.h=new y,this.i=p}function L(p,b){S(p.h);var w=p.h.j;return w?V(p,"return"in w?w.return:function(T){return{value:T,done:!0}},b,p.h.return):(p.h.return(b),z(p))}function V(p,b,w,T){try{var R=b.call(p.h.j,w);if(!(R instanceof Object))throw new TypeError("Iterator result "+R+" is not an object");if(!R.done)return p.h.m=!1,R;var P=R.value}catch(O){return p.h.j=null,$(p.h,O),z(p)}return p.h.j=null,T.call(p.h,P),z(p)}function z(p){for(;p.h.h;)try{var b=p.i(p.h);if(b)return p.h.m=!1,{value:b.value,done:!1}}catch(w){p.h.i=void 0,$(p.h,w)}if(p.h.m=!1,p.h.l){if(b=p.h.l,p.h.l=null,b.na)throw b.ma;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function K(p){this.next=function(b){return S(p.h),p.h.j?b=V(p,p.h.j.next,b,p.h.u):(p.h.u(b),b=z(p)),b},this.throw=function(b){return S(p.h),p.h.j?b=V(p,p.h.j.throw,b,p.h.u):($(p.h,b),b=z(p)),b},this.return=function(b){return L(p,b)},this[Symbol.iterator]=function(){return this}}function q(p){function b(T){return p.next(T)}function w(T){return p.throw(T)}return new Promise(function(T,R){function P(O){O.done?T(O.value):Promise.resolve(O.value).then(b,w).then(P,R)}P(p.next())})}function Z(p){return q(new K(new _(p)))}o("Promise",function(p){function b(O){this.i=0,this.j=void 0,this.h=[],this.u=!1;var M=this.l();try{O(M.resolve,M.reject)}catch(Y){M.reject(Y)}}function w(){this.h=null}function T(O){return O instanceof b?O:new b(function(M){M(O)})}if(p)return p;w.prototype.i=function(O){if(this.h==null){this.h=[];var M=this;this.j(function(){M.m()})}this.h.push(O)};var R=s.setTimeout;w.prototype.j=function(O){R(O,0)},w.prototype.m=function(){for(;this.h&&this.h.length;){var O=this.h;this.h=[];for(var M=0;M<O.length;++M){var Y=O[M];O[M]=null;try{Y()}catch(ie){this.l(ie)}}}this.h=null},w.prototype.l=function(O){this.j(function(){throw O})},b.prototype.l=function(){function O(ie){return function(me){Y||(Y=!0,ie.call(M,me))}}var M=this,Y=!1;return{resolve:O(this.I),reject:O(this.m)}},b.prototype.I=function(O){if(O===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(O instanceof b)this.L(O);else{e:switch(typeof O){case"object":var M=O!=null;break e;case"function":M=!0;break e;default:M=!1}M?this.F(O):this.s(O)}},b.prototype.F=function(O){var M=void 0;try{M=O.then}catch(Y){this.m(Y);return}typeof M=="function"?this.M(M,O):this.s(O)},b.prototype.m=function(O){this.v(2,O)},b.prototype.s=function(O){this.v(1,O)},b.prototype.v=function(O,M){if(this.i!=0)throw Error("Cannot settle("+O+", "+M+"): Promise already settled in state"+this.i);this.i=O,this.j=M,this.i===2&&this.K(),this.H()},b.prototype.K=function(){var O=this;R(function(){if(O.D()){var M=s.console;typeof M<"u"&&M.error(O.j)}},1)},b.prototype.D=function(){if(this.u)return!1;var O=s.CustomEvent,M=s.Event,Y=s.dispatchEvent;return typeof Y>"u"?!0:(typeof O=="function"?O=new O("unhandledrejection",{cancelable:!0}):typeof M=="function"?O=new M("unhandledrejection",{cancelable:!0}):(O=s.document.createEvent("CustomEvent"),O.initCustomEvent("unhandledrejection",!1,!0,O)),O.promise=this,O.reason=this.j,Y(O))},b.prototype.H=function(){if(this.h!=null){for(var O=0;O<this.h.length;++O)P.i(this.h[O]);this.h=null}};var P=new w;return b.prototype.L=function(O){var M=this.l();O.T(M.resolve,M.reject)},b.prototype.M=function(O,M){var Y=this.l();try{O.call(M,Y.resolve,Y.reject)}catch(ie){Y.reject(ie)}},b.prototype.then=function(O,M){function Y(De,we){return typeof De=="function"?function(Me){try{ie(De(Me))}catch(Ke){me(Ke)}}:we}var ie,me,Be=new b(function(De,we){ie=De,me=we});return this.T(Y(O,ie),Y(M,me)),Be},b.prototype.catch=function(O){return this.then(void 0,O)},b.prototype.T=function(O,M){function Y(){switch(ie.i){case 1:O(ie.j);break;case 2:M(ie.j);break;default:throw Error("Unexpected state: "+ie.i)}}var ie=this;this.h==null?P.i(Y):this.h.push(Y),this.u=!0},b.resolve=T,b.reject=function(O){return new b(function(M,Y){Y(O)})},b.race=function(O){return new b(function(M,Y){for(var ie=a(O),me=ie.next();!me.done;me=ie.next())T(me.value).T(M,Y)})},b.all=function(O){var M=a(O),Y=M.next();return Y.done?T([]):new b(function(ie,me){function Be(Me){return function(Ke){De[Me]=Ke,we--,we==0&&ie(De)}}var De=[],we=0;do De.push(void 0),we++,T(Y.value).T(Be(De.length-1),me),Y=M.next();while(!Y.done)})},b});function fe(p,b){p instanceof String&&(p+="");var w=0,T=!1,R={next:function(){if(!T&&w<p.length){var P=w++;return{value:b(P,p[P]),done:!1}}return T=!0,{done:!0,value:void 0}}};return R[Symbol.iterator]=function(){return R},R}o("Array.prototype.keys",function(p){return p||function(){return fe(this,function(b){return b})}}),o("Array.prototype.fill",function(p){return p||function(b,w,T){var R=this.length||0;for(0>w&&(w=Math.max(0,R+w)),(T==null||T>R)&&(T=R),T=Number(T),0>T&&(T=Math.max(0,R+T)),w=Number(w||0);w<T;w++)this[w]=b;return this}});function xe(p){return p||Array.prototype.fill}o("Int8Array.prototype.fill",xe),o("Uint8Array.prototype.fill",xe),o("Uint8ClampedArray.prototype.fill",xe),o("Int16Array.prototype.fill",xe),o("Uint16Array.prototype.fill",xe),o("Int32Array.prototype.fill",xe),o("Uint32Array.prototype.fill",xe),o("Float32Array.prototype.fill",xe),o("Float64Array.prototype.fill",xe),o("Object.is",function(p){return p||function(b,w){return b===w?b!==0||1/b===1/w:b!==b&&w!==w}}),o("Array.prototype.includes",function(p){return p||function(b,w){var T=this;T instanceof String&&(T=String(T));var R=T.length;for(w=w||0,0>w&&(w=Math.max(w+R,0));w<R;w++){var P=T[w];if(P===b||Object.is(P,b))return!0}return!1}}),o("String.prototype.includes",function(p){return p||function(b,w){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(b,w||0)!==-1}});var $e=this||self;function Te(p,b){p=p.split(".");var w=$e;p[0]in w||typeof w.execScript>"u"||w.execScript("var "+p[0]);for(var T;p.length&&(T=p.shift());)p.length||b===void 0?w[T]&&w[T]!==Object.prototype[T]?w=w[T]:w=w[T]={}:w[T]=b}function ke(p){var b;e:{if((b=$e.navigator)&&(b=b.userAgent))break e;b=""}return b.indexOf(p)!=-1}var Ee=Array.prototype.map?function(p,b){return Array.prototype.map.call(p,b,void 0)}:function(p,b){for(var w=p.length,T=Array(w),R=typeof p=="string"?p.split(""):p,P=0;P<w;P++)P in R&&(T[P]=b.call(void 0,R[P],P,p));return T},Ie={},Je=null;function Lt(p){var b=p.length,w=3*b/4;w%3?w=Math.floor(w):"=.".indexOf(p[b-1])!=-1&&(w="=.".indexOf(p[b-2])!=-1?w-2:w-1);var T=new Uint8Array(w),R=0;return Bt(p,function(P){T[R++]=P}),R!==w?T.subarray(0,R):T}function Bt(p,b){function w(Y){for(;T<p.length;){var ie=p.charAt(T++),me=Je[ie];if(me!=null)return me;if(!/^[\s\xa0]*$/.test(ie))throw Error("Unknown base64 encoding at char: "+ie)}return Y}vt();for(var T=0;;){var R=w(-1),P=w(0),O=w(64),M=w(64);if(M===64&&R===-1)break;b(R<<2|P>>4),O!=64&&(b(P<<4&240|O>>2),M!=64&&b(O<<6&192|M))}}function vt(){if(!Je){Je={};for(var p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],w=0;5>w;w++){var T=p.concat(b[w].split(""));Ie[w]=T;for(var R=0;R<T.length;R++){var P=T[R];Je[P]===void 0&&(Je[P]=R)}}}}var tn=typeof Uint8Array<"u",Dn=!(ke("Trident")||ke("MSIE"))&&typeof $e.btoa=="function";function Pn(p){if(!Dn){var b;b===void 0&&(b=0),vt(),b=Ie[b];for(var w=Array(Math.floor(p.length/3)),T=b[64]||"",R=0,P=0;R<p.length-2;R+=3){var O=p[R],M=p[R+1],Y=p[R+2],ie=b[O>>2];O=b[(O&3)<<4|M>>4],M=b[(M&15)<<2|Y>>6],Y=b[Y&63],w[P++]=ie+O+M+Y}switch(ie=0,Y=T,p.length-R){case 2:ie=p[R+1],Y=b[(ie&15)<<2]||T;case 1:p=p[R],w[P]=b[p>>2]+b[(p&3)<<4|ie>>4]+Y+T}return w.join("")}for(b="";10240<p.length;)b+=String.fromCharCode.apply(null,p.subarray(0,10240)),p=p.subarray(10240);return b+=String.fromCharCode.apply(null,p),btoa(b)}var Wt=RegExp("[-_.]","g");function Q(p){switch(p){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function be(p){if(!Dn)return Lt(p);Wt.test(p)&&(p=p.replace(Wt,Q)),p=atob(p);for(var b=new Uint8Array(p.length),w=0;w<p.length;w++)b[w]=p.charCodeAt(w);return b}var ye;function Se(){return ye||(ye=new Uint8Array(0))}var je={},rt=typeof Uint8Array.prototype.slice=="function",k=0,D=0;function H(p){var b=0>p;p=Math.abs(p);var w=p>>>0;p=Math.floor((p-w)/4294967296),b&&(w=a(J(w,p)),b=w.next().value,p=w.next().value,w=b),k=w>>>0,D=p>>>0}var ne=typeof BigInt=="function";function J(p,b){return b=~b,p?p=~p+1:b+=1,[p,b]}function re(p,b){this.i=p>>>0,this.h=b>>>0}function de(p){if(!p)return le||(le=new re(0,0));if(!/^-?\d+$/.test(p))return null;if(16>p.length)H(Number(p));else if(ne)p=BigInt(p),k=Number(p&BigInt(4294967295))>>>0,D=Number(p>>BigInt(32)&BigInt(4294967295));else{var b=+(p[0]==="-");D=k=0;for(var w=p.length,T=b,R=(w-b)%6+b;R<=w;T=R,R+=6)T=Number(p.slice(T,R)),D*=1e6,k=1e6*k+T,4294967296<=k&&(D+=k/4294967296|0,k%=4294967296);b&&(b=a(J(k,D)),p=b.next().value,b=b.next().value,k=p,D=b)}return new re(k,D)}var le;function ue(p,b){return Error("Invalid wire type: "+p+" (at position "+b+")")}function se(){return Error("Failed to read varint, encoding is invalid.")}function Oe(p,b){return Error("Tried to read past the end of the data "+b+" > "+p)}function ce(){throw Error("Invalid UTF8")}function Ce(p,b){return b=String.fromCharCode.apply(null,b),p==null?b:p+b}var Re=void 0,Le,tt=typeof TextDecoder<"u",Ve,Xt=typeof TextEncoder<"u",Mt;function zt(p){if(p!==je)throw Error("illegal external caller")}function kt(p,b){if(zt(b),this.V=p,p!=null&&p.length===0)throw Error("ByteString should be constructed with non-empty values")}function qn(){return Mt||(Mt=new kt(null,je))}function Br(p){zt(je);var b=p.V;return b=b==null||tn&&b!=null&&b instanceof Uint8Array?b:typeof b=="string"?be(b):null,b==null?b:p.V=b}function Gt(p){if(typeof p=="string")return{buffer:be(p),C:!1};if(Array.isArray(p))return{buffer:new Uint8Array(p),C:!1};if(p.constructor===Uint8Array)return{buffer:p,C:!1};if(p.constructor===ArrayBuffer)return{buffer:new Uint8Array(p),C:!1};if(p.constructor===kt)return{buffer:Br(p)||Se(),C:!0};if(p instanceof Uint8Array)return{buffer:new Uint8Array(p.buffer,p.byteOffset,p.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function jt(p,b){this.i=null,this.m=!1,this.h=this.j=this.l=0,xn(this,p,b)}function xn(p,b,w){w=w===void 0?{}:w,p.S=w.S===void 0?!1:w.S,b&&(b=Gt(b),p.i=b.buffer,p.m=b.C,p.l=0,p.j=p.i.length,p.h=p.l)}jt.prototype.reset=function(){this.h=this.l};function Rt(p,b){if(p.h=b,b>p.j)throw Oe(p.j,b)}function Fn(p){var b=p.i,w=p.h,T=b[w++],R=T&127;if(T&128&&(T=b[w++],R|=(T&127)<<7,T&128&&(T=b[w++],R|=(T&127)<<14,T&128&&(T=b[w++],R|=(T&127)<<21,T&128&&(T=b[w++],R|=T<<28,T&128&&b[w++]&128&&b[w++]&128&&b[w++]&128&&b[w++]&128&&b[w++]&128)))))throw se();return Rt(p,w),R}function zs(p,b){if(0>b)throw Error("Tried to read a negative byte length: "+b);var w=p.h,T=w+b;if(T>p.j)throw Oe(b,p.j-w);return p.h=T,w}var Gs=[];function js(){this.h=[]}js.prototype.length=function(){return this.h.length},js.prototype.end=function(){var p=this.h;return this.h=[],p};function So(p,b,w){for(;0<w||127<b;)p.h.push(b&127|128),b=(b>>>7|w<<25)>>>0,w>>>=7;p.h.push(b)}function dn(p,b){for(;127<b;)p.h.push(b&127|128),b>>>=7;p.h.push(b)}function Hs(p,b){if(Gs.length){var w=Gs.pop();xn(w,p,b),p=w}else p=new jt(p,b);this.h=p,this.j=this.h.h,this.i=this.l=-1,this.setOptions(b)}Hs.prototype.setOptions=function(p){p=p===void 0?{}:p,this.ca=p.ca===void 0?!1:p.ca},Hs.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function wr(p){var b=p.h;if(b.h==b.j)return!1;p.j=p.h.h;var w=Fn(p.h)>>>0;if(b=w>>>3,w&=7,!(0<=w&&5>=w))throw ue(w,p.j);if(1>b)throw Error("Invalid field number: "+b+" (at position "+p.j+")");return p.l=b,p.i=w,!0}function vs(p){switch(p.i){case 0:if(p.i!=0)vs(p);else e:{p=p.h;for(var b=p.h,w=b+10,T=p.i;b<w;)if(!(T[b++]&128)){Rt(p,b);break e}throw se()}break;case 1:p=p.h,Rt(p,p.h+8);break;case 2:p.i!=2?vs(p):(b=Fn(p.h)>>>0,p=p.h,Rt(p,p.h+b));break;case 5:p=p.h,Rt(p,p.h+4);break;case 3:b=p.l;do{if(!wr(p))throw Error("Unmatched start-group tag: stream EOF");if(p.i==4){if(p.l!=b)throw Error("Unmatched end-group tag");break}vs(p)}while(!0);break;default:throw ue(p.i,p.j)}}var ws=[];function da(){this.j=[],this.i=0,this.h=new js}function Ht(p,b){b.length!==0&&(p.j.push(b),p.i+=b.length)}function pa(p,b){if(b=b.R){Ht(p,p.h.end());for(var w=0;w<b.length;w++)Ht(p,Br(b[w])||Se())}}var Nt=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Xn(p,b){return Nt?p[Nt]|=b:p.A!==void 0?p.A|=b:(Object.defineProperties(p,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}}),b)}function gi(p,b){Nt?p[Nt]&&(p[Nt]&=~b):p.A!==void 0&&(p.A&=~b)}function Et(p){var b;return Nt?b=p[Nt]:b=p.A,b??0}function bn(p,b){Nt?p[Nt]=b:p.A!==void 0?p.A=b:Object.defineProperties(p,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}})}function Co(p){return Xn(p,1),p}function ss(p,b){bn(b,(p|0)&-51)}function Ss(p,b){bn(b,(p|18)&-41)}var os={};function Ks(p){return p!==null&&typeof p=="object"&&!Array.isArray(p)&&p.constructor===Object}var Mr,yi=[];bn(yi,23),Mr=Object.freeze(yi);function ar(p){if(Et(p.o)&2)throw Error("Cannot mutate an immutable Message")}function $o(p){var b=p.length;(b=b?p[b-1]:void 0)&&Ks(b)?b.g=1:(b={},p.push((b.g=1,b)))}function xi(p){var b=p.i+p.G;return p.B||(p.B=p.o[b]={})}function vn(p,b){return b===-1?null:b>=p.i?p.B?p.B[b]:void 0:p.o[b+p.G]}function Yn(p,b,w,T){ar(p),Cs(p,b,w,T)}function Cs(p,b,w,T){p.j&&(p.j=void 0),b>=p.i||T?xi(p)[b]=w:(p.o[b+p.G]=w,(p=p.B)&&b in p&&delete p[b])}function To(p,b,w,T){var R=vn(p,b);Array.isArray(R)||(R=Mr);var P=Et(R);if(P&1||Co(R),T)P&2||Xn(R,2),w&1||Object.freeze(R);else{T=!(w&2);var O=P&2;w&1||!O?T&&P&16&&!O&&gi(R,16):(R=Co(Array.prototype.slice.call(R)),Cs(p,b,R))}return R}function $s(p,b){var w=vn(p,b),T=w==null?w:typeof w=="number"||w==="NaN"||w==="Infinity"||w==="-Infinity"?Number(w):void 0;return T!=null&&T!==w&&Cs(p,b,T),T}function bi(p,b,w,T,R){p.h||(p.h={});var P=p.h[w],O=To(p,w,3,R);if(!P){var M=O;P=[];var Y=!!(Et(p.o)&16);O=!!(Et(M)&2);var ie=M;!R&&O&&(M=Array.prototype.slice.call(M));for(var me=O,Be=0;Be<M.length;Be++){var De=M[Be],we=b,Me=!1;if(Me=Me===void 0?!1:Me,De=Array.isArray(De)?new we(De):Me?new we:void 0,De!==void 0){we=De.o;var Ke=Me=Et(we);O&&(Ke|=2),Y&&(Ke|=16),Ke!=Me&&bn(we,Ke),we=Ke,me=me||!!(2&we),P.push(De)}}return p.h[w]=P,Y=Et(M),b=Y|33,b=me?b&-9:b|8,Y!=b&&(me=M,Object.isFrozen(me)&&(me=Array.prototype.slice.call(me)),bn(me,b),M=me),ie!==M&&Cs(p,w,M),(R||T&&O)&&Xn(P,2),T&&Object.freeze(P),P}return R||(R=Object.isFrozen(P),T&&!R?Object.freeze(P):!T&&R&&(P=Array.prototype.slice.call(P),p.h[w]=P)),P}function Vr(p,b,w){var T=!!(Et(p.o)&2);if(b=bi(p,b,w,T,T),p=To(p,w,3,T),!(T||Et(p)&8)){for(T=0;T<b.length;T++){if(w=b[T],Et(w.o)&2){var R=E(w,!1);R.j=w}else R=w;w!==R&&(b[T]=R,p[T]=R.o)}Xn(p,8)}return b}function wn(p,b,w){if(w!=null&&typeof w!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof w+": "+w);Yn(p,b,w)}function No(p,b,w,T,R){ar(p);var P=bi(p,w,b,!1,!1);return w=T??new w,p=To(p,b,2,!1),R!=null?(P.splice(R,0,w),p.splice(R,0,w.o)):(P.push(w),p.push(w.o)),w.C()&&gi(p,8),w}function Ur(p,b){return p??b}function Ln(p,b,w){return w=w===void 0?0:w,Ur($s(p,b),w)}var nn;function Eo(p){switch(typeof p){case"number":return isFinite(p)?p:String(p);case"object":if(p)if(Array.isArray(p)){if(Et(p)&128)return p=Array.prototype.slice.call(p),$o(p),p}else{if(tn&&p!=null&&p instanceof Uint8Array)return Pn(p);if(p instanceof kt){var b=p.V;return b==null?"":typeof b=="string"?b:p.V=Pn(b)}}}return p}function vi(p,b,w,T){if(p!=null){if(Array.isArray(p))p=is(p,b,w,T!==void 0);else if(Ks(p)){var R={},P;for(P in p)R[P]=vi(p[P],b,w,T);p=R}else p=b(p,T);return p}}function is(p,b,w,T){var R=Et(p);T=T?!!(R&16):void 0,p=Array.prototype.slice.call(p);for(var P=0;P<p.length;P++)p[P]=vi(p[P],b,w,T);return w(R,p),p}function ma(p){return p.ja===os?p.toJSON():Eo(p)}function ga(p,b){p&128&&$o(b)}function Bn(p,b,w){if(w=w===void 0?Ss:w,p!=null){if(tn&&p instanceof Uint8Array)return p.length?new kt(new Uint8Array(p),je):qn();if(Array.isArray(p)){var T=Et(p);return T&2?p:b&&!(T&32)&&(T&16||T===0)?(bn(p,T|2),p):(p=is(p,Bn,T&4?Ss:w,!0),b=Et(p),b&4&&b&2&&Object.freeze(p),p)}return p.ja===os?wi(p):p}}function Sn(p,b,w,T,R,P,O){if(p=p.h&&p.h[w]){if(T=Et(p),T&2?T=p:(P=Ee(p,wi),Ss(T,P),Object.freeze(P),T=P),ar(b),O=T==null?Mr:Co([]),T!=null){for(P=!!T.length,p=0;p<T.length;p++){var M=T[p];P=P&&!(Et(M.o)&2),O[p]=M.o}P=(P?8:0)|1,p=Et(O),(p&P)!==P&&(Object.isFrozen(O)&&(O=Array.prototype.slice.call(O)),bn(O,p|P)),b.h||(b.h={}),b.h[w]=T}else b.h&&(b.h[w]=void 0);Cs(b,w,O,R)}else Yn(b,w,Bn(T,P,O),R)}function wi(p){return Et(p.o)&2||(p=E(p,!0),Xn(p.o,2)),p}function E(p,b){var w=p.o,T=[];Xn(T,16);var R=p.constructor.h;if(R&&T.push(R),R=p.B,R){T.length=w.length,T.fill(void 0,T.length,w.length);var P={};T[T.length-1]=P}Et(w)&128&&$o(T),b=b||p.C()?Ss:ss,P=p.constructor,nn=T,T=new P(T),nn=void 0,p.R&&(T.R=p.R.slice()),P=!!(Et(w)&16);for(var O=R?w.length-1:w.length,M=0;M<O;M++)Sn(p,T,M-p.G,w[M],!1,P,b);if(R)for(var Y in R)Sn(p,T,+Y,R[Y],!0,P,b);return T}function U(p,b,w){p==null&&(p=nn),nn=void 0;var T=this.constructor.i||0,R=0<T,P=this.constructor.h,O=!1;if(p==null){p=P?[P]:[];var M=48,Y=!0;R&&(T=0,M|=128),bn(p,M)}else{if(!Array.isArray(p)||P&&P!==p[0])throw Error();var ie=M=Xn(p,0);if((Y=(16&ie)!==0)&&((O=(32&ie)!==0)||(ie|=32)),R){if(128&ie)T=0;else if(0<p.length){var me=p[p.length-1];if(Ks(me)&&"g"in me){T=0,ie|=128,delete me.g;var Be=!0,De;for(De in me){Be=!1;break}Be&&p.pop()}}}else if(128&ie)throw Error();M!==ie&&bn(p,ie)}this.G=(P?0:-1)-T,this.h=void 0,this.o=p;e:{if(P=this.o.length,T=P-1,P&&(P=this.o[T],Ks(P))){this.B=P,this.i=T-this.G;break e}b!==void 0&&-1<b?(this.i=Math.max(b,T+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!R&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(w){b=Y&&!O&&!0,R=this.i;var we;for(Y=0;Y<w.length;Y++)O=w[Y],O<R?(O+=this.G,(T=p[O])?te(T,b):p[O]=Mr):(we||(we=xi(this)),(T=we[O])?te(T,b):we[O]=Mr)}}U.prototype.toJSON=function(){return is(this.o,ma,ga)},U.prototype.C=function(){return!!(Et(this.o)&2)};function te(p,b){if(Array.isArray(p)){var w=Et(p),T=1;!b||w&2||(T|=16),(w&T)!==T&&bn(p,w|T)}}U.prototype.ja=os,U.prototype.toString=function(){return this.o.toString()};function j(p,b,w){if(w){var T={},R;for(R in w){var P=w[R],O=P.qa;O||(T.J=P.wa||P.oa.W,P.ia?(T.aa=_t(P.ia),O=function(M){return function(Y,ie,me){return M.J(Y,ie,me,M.aa)}}(T)):P.ka?(T.Z=Kt(P.da.P,P.ka),O=function(M){return function(Y,ie,me){return M.J(Y,ie,me,M.Z)}}(T)):O=T.J,P.qa=O),O(b,p,P.da),T={J:T.J,aa:T.aa,Z:T.Z}}}pa(b,p)}var oe=Symbol();function Ae(p,b,w){return p[oe]||(p[oe]=function(T,R){return b(T,R,w)})}function Pe(p){var b=p[oe];if(!b){var w=qs(p);b=function(T,R){return ya(T,R,w)},p[oe]=b}return b}function He(p){var b=p.ia;if(b)return Pe(b);if(b=p.va)return Ae(p.da.P,b,p.ka)}function st(p){var b=He(p),w=p.da,T=p.oa.U;return b?function(R,P){return T(R,P,w,b)}:function(R,P){return T(R,P,w)}}function mt(p,b){var w=p[b];return typeof w=="function"&&w.length===0&&(w=w(),p[b]=w),Array.isArray(w)&&(Mn in w||Qn in w||0<w.length&&typeof w[0]=="function")?w:void 0}function ct(p,b,w,T,R,P){b.P=p[0];var O=1;if(p.length>O&&typeof p[O]!="number"){var M=p[O++];w(b,M)}for(;O<p.length;){w=p[O++];for(var Y=O+1;Y<p.length&&typeof p[Y]!="number";)Y++;switch(M=p[O++],Y-=O,Y){case 0:T(b,w,M);break;case 1:(Y=mt(p,O))?(O++,R(b,w,M,Y)):T(b,w,M,p[O++]);break;case 2:Y=O++,Y=mt(p,Y),R(b,w,M,Y,p[O++]);break;case 3:P(b,w,M,p[O++],p[O++],p[O++]);break;case 4:P(b,w,M,p[O++],p[O++],p[O++],p[O++]);break;default:throw Error("unexpected number of binary field arguments: "+Y)}}return b}var lt=Symbol();function _t(p){var b=p[lt];if(!b){var w=Zn(p);b=function(T,R){return Si(T,R,w)},p[lt]=b}return b}function Kt(p,b){var w=p[lt];return w||(w=function(T,R){return j(T,R,b)},p[lt]=w),w}var Qn=Symbol();function Sr(p,b){p.push(b)}function Cr(p,b,w){p.push(b,w.W)}function it(p,b,w,T){var R=_t(T),P=Zn(T).P,O=w.W;p.push(b,function(M,Y,ie){return O(M,Y,ie,P,R)})}function as(p,b,w,T,R,P){var O=Kt(T,P),M=w.W;p.push(b,function(Y,ie,me){return M(Y,ie,me,T,O)})}function Zn(p){var b=p[Qn];return b||(b=ct(p,p[Qn]=[],Sr,Cr,it,as),Mn in p&&Qn in p&&(p.length=0),b)}var Mn=Symbol();function Vt(p,b){p[0]=b}function Cn(p,b,w,T){var R=w.U;p[b]=T?function(P,O,M){return R(P,O,M,T)}:R}function Vn(p,b,w,T,R){var P=w.U,O=Pe(T),M=qs(T).P;p[b]=function(Y,ie,me){return P(Y,ie,me,M,O,R)}}function ur(p,b,w,T,R,P,O){var M=w.U,Y=Ae(T,R,P);p[b]=function(ie,me,Be){return M(ie,me,Be,T,Y,O)}}function qs(p){var b=p[Mn];return b||(b=ct(p,p[Mn]={},Vt,Cn,Vn,ur),Mn in p&&Qn in p&&(p.length=0),b)}function ya(p,b,w){for(;wr(b)&&b.i!=4;){var T=b.l,R=w[T];if(!R){var P=w[0];P&&(P=P[T])&&(R=w[T]=st(P))}if(!R||!R(b,p,T)){R=b,T=p,P=R.j,vs(R);var O=R;if(!O.ca){if(R=O.h.h-P,O.h.h=P,O=O.h,R==0)R=qn();else{if(P=zs(O,R),O.S&&O.m)R=O.i.subarray(P,P+R);else{O=O.i;var M=P;R=P+R,R=M===R?Se():rt?O.slice(M,R):new Uint8Array(O.subarray(M,R))}R=R.length==0?qn():new kt(R,je)}(P=T.R)?P.push(R):T.R=[R]}}}return p}function Si(p,b,w){for(var T=w.length,R=T%2==1,P=R?1:0;P<T;P+=2)(0,w[P+1])(b,p,w[P]);j(p,b,R?w[0]:void 0)}function Xs(p,b){return{U:p,W:b}}var Qt=Xs(function(p,b,w){if(p.i!==5)return!1;p=p.h;var T=p.i,R=p.h,P=T[R],O=T[R+1],M=T[R+2];return T=T[R+3],Rt(p,p.h+4),O=(P<<0|O<<8|M<<16|T<<24)>>>0,p=2*(O>>31)+1,P=O>>>23&255,O&=8388607,Yn(b,w,P==255?O?NaN:1/0*p:P==0?p*Math.pow(2,-149)*O:p*Math.pow(2,P-150)*(O+Math.pow(2,23))),!0},function(p,b,w){if(b=$s(b,w),b!=null){dn(p.h,8*w+5),p=p.h;var T=+b;T===0?0<1/T?k=D=0:(D=0,k=2147483648):isNaN(T)?(D=0,k=2147483647):(T=(w=0>T?-2147483648:0)?-T:T,34028234663852886e22<T?(D=0,k=(w|2139095040)>>>0):11754943508222875e-54>T?(T=Math.round(T/Math.pow(2,-149)),D=0,k=(w|T)>>>0):(b=Math.floor(Math.log(T)/Math.LN2),T*=Math.pow(2,-b),T=Math.round(8388608*T),16777216<=T&&++b,D=0,k=(w|b+127<<23|T&8388607)>>>0)),w=k,p.h.push(w>>>0&255),p.h.push(w>>>8&255),p.h.push(w>>>16&255),p.h.push(w>>>24&255)}}),_o=Xs(function(p,b,w){if(p.i!==0)return!1;var T=p.h,R=0,P=p=0,O=T.i,M=T.h;do{var Y=O[M++];R|=(Y&127)<<P,P+=7}while(32>P&&Y&128);for(32<P&&(p|=(Y&127)>>4),P=3;32>P&&Y&128;P+=7)Y=O[M++],p|=(Y&127)<<P;if(Rt(T,M),128>Y)T=R>>>0,Y=p>>>0,(p=Y&2147483648)&&(T=~T+1>>>0,Y=~Y>>>0,T==0&&(Y=Y+1>>>0)),T=4294967296*Y+(T>>>0);else throw se();return Yn(b,w,p?-T:T),!0},function(p,b,w){b=vn(b,w),b!=null&&(typeof b=="string"&&de(b),b!=null&&(dn(p.h,8*w),typeof b=="number"?(p=p.h,H(b),So(p,k,D)):(w=de(b),So(p.h,w.i,w.h))))}),ul=Xs(function(p,b,w){return p.i!==0?!1:(Yn(b,w,Fn(p.h)),!0)},function(p,b,w){if(b=vn(b,w),b!=null&&b!=null)if(dn(p.h,8*w),p=p.h,w=b,0<=w)dn(p,w);else{for(b=0;9>b;b++)p.h.push(w&127|128),w>>=7;p.h.push(1)}}),xa=Xs(function(p,b,w){if(p.i!==2)return!1;var T=Fn(p.h)>>>0;p=p.h;var R=zs(p,T);if(p=p.i,tt){var P=p,O;(O=Le)||(O=Le=new TextDecoder("utf-8",{fatal:!0})),p=R+T,P=R===0&&p===P.length?P:P.subarray(R,p);try{var M=O.decode(P)}catch(Be){if(Re===void 0){try{O.decode(new Uint8Array([128]))}catch{}try{O.decode(new Uint8Array([97])),Re=!0}catch{Re=!1}}throw!Re&&(Le=void 0),Be}}else{M=R,T=M+T,R=[];for(var Y=null,ie,me;M<T;)ie=p[M++],128>ie?R.push(ie):224>ie?M>=T?ce():(me=p[M++],194>ie||(me&192)!==128?(M--,ce()):R.push((ie&31)<<6|me&63)):240>ie?M>=T-1?ce():(me=p[M++],(me&192)!==128||ie===224&&160>me||ie===237&&160<=me||((P=p[M++])&192)!==128?(M--,ce()):R.push((ie&15)<<12|(me&63)<<6|P&63)):244>=ie?M>=T-2?ce():(me=p[M++],(me&192)!==128||(ie<<28)+(me-144)>>30||((P=p[M++])&192)!==128||((O=p[M++])&192)!==128?(M--,ce()):(ie=(ie&7)<<18|(me&63)<<12|(P&63)<<6|O&63,ie-=65536,R.push((ie>>10&1023)+55296,(ie&1023)+56320))):ce(),8192<=R.length&&(Y=Ce(Y,R),R.length=0);M=Ce(Y,R)}return Yn(b,w,M),!0},function(p,b,w){if(b=vn(b,w),b!=null){var T=!1;if(T=T===void 0?!1:T,Xt){if(T&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b))throw Error("Found an unpaired surrogate");b=(Ve||(Ve=new TextEncoder)).encode(b)}else{for(var R=0,P=new Uint8Array(3*b.length),O=0;O<b.length;O++){var M=b.charCodeAt(O);if(128>M)P[R++]=M;else{if(2048>M)P[R++]=M>>6|192;else{if(55296<=M&&57343>=M){if(56319>=M&&O<b.length){var Y=b.charCodeAt(++O);if(56320<=Y&&57343>=Y){M=1024*(M-55296)+Y-56320+65536,P[R++]=M>>18|240,P[R++]=M>>12&63|128,P[R++]=M>>6&63|128,P[R++]=M&63|128;continue}else O--}if(T)throw Error("Found an unpaired surrogate");M=65533}P[R++]=M>>12|224,P[R++]=M>>6&63|128}P[R++]=M&63|128}}b=R===P.length?P:P.subarray(0,R)}dn(p.h,8*w+2),dn(p.h,b.length),Ht(p,p.h.end()),Ht(p,b)}}),Nu=Xs(function(p,b,w,T,R){if(p.i!==2)return!1;b=No(b,w,T),w=p.h.j,T=Fn(p.h)>>>0;var P=p.h.h+T,O=P-w;if(0>=O&&(p.h.j=P,R(b,p,void 0,void 0,void 0),O=P-p.h.h),O)throw Error("Message parsing ended unexpectedly. Expected to read "+(T+" bytes, instead read "+(T-O)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return p.h.h=P,p.h.j=w,!0},function(p,b,w,T,R){if(b=Vr(b,T,w),b!=null)for(T=0;T<b.length;T++){var P=p;dn(P.h,8*w+2);var O=P.h.end();Ht(P,O),O.push(P.i),P=O,R(b[T],p),O=p;var M=P.pop();for(M=O.i+O.h.length()-M;127<M;)P.push(M&127|128),M>>>=7,O.i++;P.push(M),O.i++}});function Ci(p){return function(b,w){e:{if(ws.length){var T=ws.pop();T.setOptions(w),xn(T.h,b,w),b=T}else b=new Hs(b,w);try{var R=qs(p),P=ya(new R.P,b,R);break e}finally{R=b.h,R.i=null,R.m=!1,R.l=0,R.j=0,R.h=0,R.S=!1,b.l=-1,b.i=-1,100>ws.length&&ws.push(b)}P=void 0}return P}}function ba(p){return function(){var b=new da;Si(this,b,Zn(p)),Ht(b,b.h.end());for(var w=new Uint8Array(b.i),T=b.j,R=T.length,P=0,O=0;O<R;O++){var M=T[O];w.set(M,P),P+=M.length}return b.j=[w],w}}function Ys(p){U.call(this,p)}g(Ys,U);var va=[Ys,1,ul,2,Qt,3,xa,4,xa];Ys.prototype.l=ba(va);function wa(p){U.call(this,p,-1,A)}g(wa,U),wa.prototype.addClassification=function(p,b){return No(this,1,Ys,p,b),this};var A=[1],W=Ci([wa,1,Nu,va]);function X(p){U.call(this,p)}g(X,U);var _e=[X,1,Qt,2,Qt,3,Qt,4,Qt,5,Qt];X.prototype.l=ba(_e);function Ye(p){U.call(this,p,-1,ht)}g(Ye,U);var ht=[1],gt=Ci([Ye,1,Nu,_e]);function Qe(p){U.call(this,p)}g(Qe,U);var yt=[Qe,1,Qt,2,Qt,3,Qt,4,Qt,5,Qt,6,_o],cr=Ci(yt);Qe.prototype.l=ba(yt);function $n(p,b,w){if(w=p.createShader(w===0?p.VERTEX_SHADER:p.FRAGMENT_SHADER),p.shaderSource(w,b),p.compileShader(w),!p.getShaderParameter(w,p.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+p.getShaderInfoLog(w));return w}function Qs(p){return Vr(p,Ys,1).map(function(b){var w=vn(b,1);return{index:w??0,score:Ln(b,2),label:vn(b,3)!=null?Ur(vn(b,3),""):void 0,displayName:vn(b,4)!=null?Ur(vn(b,4),""):void 0}})}function $i(p){return{x:Ln(p,1),y:Ln(p,2),z:Ln(p,3),visibility:$s(p,4)!=null?Ln(p,4):void 0}}function Ti(p){return p.map(function(b){return Vr(gt(b),X,1).map($i)})}function Ni(p,b){this.i=p,this.h=b,this.m=0}function fd(p,b,w){return uw(p,b),typeof p.h.canvas.transferToImageBitmap=="function"?Promise.resolve(p.h.canvas.transferToImageBitmap()):w?Promise.resolve(p.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(p.h.canvas):(p.j===void 0&&(p.j=document.createElement("canvas")),new Promise(function(T){p.j.height=p.h.canvas.height,p.j.width=p.h.canvas.width,p.j.getContext("2d",{}).drawImage(p.h.canvas,0,0,p.h.canvas.width,p.h.canvas.height),T(p.j)}))}function uw(p,b){var w=p.h;if(p.s===void 0){var T=$n(w,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),R=$n(w,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),P=w.createProgram();if(w.attachShader(P,T),w.attachShader(P,R),w.linkProgram(P),!w.getProgramParameter(P,w.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+w.getProgramInfoLog(P));T=p.s=P,w.useProgram(T),R=w.getUniformLocation(T,"sampler0"),p.l={O:w.getAttribLocation(T,"aVertex"),N:w.getAttribLocation(T,"aTex"),xa:R},p.v=w.createBuffer(),w.bindBuffer(w.ARRAY_BUFFER,p.v),w.enableVertexAttribArray(p.l.O),w.vertexAttribPointer(p.l.O,2,w.FLOAT,!1,0,0),w.bufferData(w.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),w.STATIC_DRAW),w.bindBuffer(w.ARRAY_BUFFER,null),p.u=w.createBuffer(),w.bindBuffer(w.ARRAY_BUFFER,p.u),w.enableVertexAttribArray(p.l.N),w.vertexAttribPointer(p.l.N,2,w.FLOAT,!1,0,0),w.bufferData(w.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),w.STATIC_DRAW),w.bindBuffer(w.ARRAY_BUFFER,null),w.uniform1i(R,0)}T=p.l,w.useProgram(p.s),w.canvas.width=b.width,w.canvas.height=b.height,w.viewport(0,0,b.width,b.height),w.activeTexture(w.TEXTURE0),p.i.bindTexture2d(b.glName),w.enableVertexAttribArray(T.O),w.bindBuffer(w.ARRAY_BUFFER,p.v),w.vertexAttribPointer(T.O,2,w.FLOAT,!1,0,0),w.enableVertexAttribArray(T.N),w.bindBuffer(w.ARRAY_BUFFER,p.u),w.vertexAttribPointer(T.N,2,w.FLOAT,!1,0,0),w.bindFramebuffer(w.DRAW_FRAMEBUFFER?w.DRAW_FRAMEBUFFER:w.FRAMEBUFFER,null),w.clearColor(0,0,0,0),w.clear(w.COLOR_BUFFER_BIT),w.colorMask(!0,!0,!0,!0),w.drawArrays(w.TRIANGLE_FAN,0,4),w.disableVertexAttribArray(T.O),w.disableVertexAttribArray(T.N),w.bindBuffer(w.ARRAY_BUFFER,null),p.i.bindTexture2d(0)}function cw(p){this.h=p}var lw=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function hw(p,b){return b+p}function dd(p,b){window[p]=b}function fw(p){var b=document.createElement("script");return b.setAttribute("src",p),b.setAttribute("crossorigin","anonymous"),new Promise(function(w){b.addEventListener("load",function(){w()},!1),b.addEventListener("error",function(){w()},!1),document.body.appendChild(b)})}function dw(){return Z(function(p){switch(p.h){case 1:return p.s=2,C(p,WebAssembly.instantiate(lw),4);case 4:p.h=3,p.s=0;break;case 2:return p.s=0,p.l=null,p.return(!1);case 3:return p.return(!0)}})}function cl(p){if(this.h=p,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=p&&p.locateFile||hw,typeof window=="object")var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=b,p.options){b=a(Object.keys(p.options));for(var w=b.next();!w.done;w=b.next()){w=w.value;var T=p.options[w].default;T!==void 0&&(this.l[w]=typeof T=="function"?T():T)}}}t=cl.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function pw(p){var b,w,T,R,P,O,M,Y,ie,me,Be;return Z(function(De){switch(De.h){case 1:return p.ga?(b=p.h.files===void 0?[]:typeof p.h.files=="function"?p.h.files(p.l):p.h.files,C(De,dw(),2)):De.return();case 2:if(w=De.i,typeof window=="object")return dd("createMediapipeSolutionsWasm",{locateFile:p.locateFile}),dd("createMediapipeSolutionsPackedAssets",{locateFile:p.locateFile}),O=b.filter(function(we){return we.data!==void 0}),M=b.filter(function(we){return we.data===void 0}),Y=Promise.all(O.map(function(we){var Me=Eu(p,we.url);if(we.path!==void 0){var Ke=we.path;Me=Me.then(function(It){return p.overrideFile(Ke,It),Promise.resolve(It)})}return Me})),ie=Promise.all(M.map(function(we){return we.simd===void 0||we.simd&&w||!we.simd&&!w?fw(p.locateFile(we.url,p.ha)):Promise.resolve()})).then(function(){var we,Me,Ke;return Z(function(It){if(It.h==1)return we=window.createMediapipeSolutionsWasm,Me=window.createMediapipeSolutionsPackedAssets,Ke=p,C(It,we(Me),2);Ke.i=It.i,It.h=0})}),me=function(){return Z(function(we){return p.h.graph&&p.h.graph.url?we=C(we,Eu(p,p.h.graph.url),0):(we.h=0,we=void 0),we})}(),C(De,Promise.all([ie,Y,me]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return T=b.filter(function(we){return we.simd===void 0||we.simd&&w||!we.simd&&!w}).map(function(we){return p.locateFile(we.url,p.ha)}),importScripts.apply(null,u(T)),R=p,C(De,createMediapipeSolutionsWasm(Module),6);case 6:R.i=De.i,p.m=new OffscreenCanvas(1,1),p.i.canvas=p.m,P=p.i.GL.createContext(p.m,{antialias:!1,alpha:!1,ua:typeof WebGL2RenderingContext<"u"?2:1}),p.i.GL.makeContextCurrent(P),De.h=4;break;case 7:if(p.m=document.createElement("canvas"),Be=p.m.getContext("webgl2",{}),!Be&&(Be=p.m.getContext("webgl",{}),!Be))return alert("Failed to create WebGL canvas context when passing video frame."),De.return();p.K=Be,p.i.canvas=p.m,p.i.createContext(p.m,!0,!0,{});case 4:p.j=new p.i.SolutionWasm,p.ga=!1,De.h=0}})}function mw(p){var b,w,T,R,P,O,M,Y;return Z(function(ie){if(ie.h==1){if(p.h.graph&&p.h.graph.url&&p.fa===p.h.graph.url)return ie.return();if(p.u=!0,!p.h.graph||!p.h.graph.url){ie.h=2;return}return p.fa=p.h.graph.url,C(ie,Eu(p,p.h.graph.url),3)}for(ie.h!=2&&(b=ie.i,p.j.loadGraph(b)),w=a(Object.keys(p.D)),T=w.next();!T.done;T=w.next())R=T.value,p.j.overrideFile(R,p.D[R]);if(p.D={},p.h.listeners)for(P=a(p.h.listeners),O=P.next();!O.done;O=P.next())M=O.value,bw(p,M);Y=p.l,p.l={},p.setOptions(Y),ie.h=0})}t.reset=function(){var p=this;return Z(function(b){p.j&&(p.j.reset(),p.s={},p.v={}),b.h=0})},t.setOptions=function(p,b){var w=this;if(b=b||this.h.options){for(var T=[],R=[],P={},O=a(Object.keys(p)),M=O.next();!M.done;P={X:P.X,Y:P.Y},M=O.next())if(M=M.value,!(M in this.l&&this.l[M]===p[M])){this.l[M]=p[M];var Y=b[M];Y!==void 0&&(Y.onChange&&(P.X=Y.onChange,P.Y=p[M],T.push(function(ie){return function(){var me;return Z(function(Be){if(Be.h==1)return C(Be,ie.X(ie.Y),2);me=Be.i,me===!0&&(w.u=!0),Be.h=0})}}(P))),Y.graphOptionXref&&(M=Object.assign({},{calculatorName:"",calculatorIndex:0},Y.graphOptionXref,{valueNumber:Y.type===1?p[M]:0,valueBoolean:Y.type===0?p[M]:!1,valueString:Y.type===2?p[M]:""}),R.push(M)))}(T.length!==0||R.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(R),this.F=(this.F===void 0?[]:this.F).concat(T))}};function gw(p){var b,w,T,R,P,O,M;return Z(function(Y){switch(Y.h){case 1:if(!p.u)return Y.return();if(!p.F){Y.h=2;break}b=a(p.F),w=b.next();case 3:if(w.done){Y.h=5;break}return T=w.value,C(Y,T(),4);case 4:w=b.next(),Y.h=3;break;case 5:p.F=void 0;case 2:if(p.H){for(R=new p.i.GraphOptionChangeRequestList,P=a(p.H),O=P.next();!O.done;O=P.next())M=O.value,R.push_back(M);p.j.changeOptions(R),R.delete(),p.H=void 0}p.u=!1,Y.h=0}})}t.initialize=function(){var p=this;return Z(function(b){return b.h==1?C(b,pw(p),2):b.h!=3?C(b,mw(p),3):C(b,gw(p),0)})};function Eu(p,b){var w,T;return Z(function(R){return b in p.L?R.return(p.L[b]):(w=p.locateFile(b,""),T=fetch(w).then(function(P){return P.arrayBuffer()}),p.L[b]=T,R.return(T))})}t.overrideFile=function(p,b){this.j?this.j.overrideFile(p,b):this.D[p]=b},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(p,b){var w=this,T,R,P,O,M,Y,ie,me,Be;return Z(function(De){switch(De.h){case 1:return w.h.inputs?(T=1e3*(b??performance.now()),C(De,w.I,2)):De.return();case 2:return C(De,w.initialize(),3);case 3:for(R=new w.i.PacketDataList,P=a(Object.keys(p)),O=P.next();!O.done;O=P.next())if(M=O.value,Y=w.h.inputs[M]){e:{var we=p[M];switch(Y.type){case"video":var Me=w.s[Y.stream];if(Me||(Me=new Ni(w.i,w.K),w.s[Y.stream]=Me),Me.m===0&&(Me.m=Me.i.createTexture()),typeof HTMLVideoElement<"u"&&we instanceof HTMLVideoElement)var Ke=we.videoWidth,It=we.videoHeight;else typeof HTMLImageElement<"u"&&we instanceof HTMLImageElement?(Ke=we.naturalWidth,It=we.naturalHeight):(Ke=we.width,It=we.height);It={glName:Me.m,width:Ke,height:It},Ke=Me.h,Ke.canvas.width=It.width,Ke.canvas.height=It.height,Ke.activeTexture(Ke.TEXTURE0),Me.i.bindTexture2d(Me.m),Ke.texImage2D(Ke.TEXTURE_2D,0,Ke.RGBA,Ke.RGBA,Ke.UNSIGNED_BYTE,we),Me.i.bindTexture2d(0),Me=It;break e;case"detections":for(Me=w.s[Y.stream],Me||(Me=new cw(w.i),w.s[Y.stream]=Me),Me.data||(Me.data=new Me.h.DetectionListData),Me.data.reset(we.length),It=0;It<we.length;++It){Ke=we[It];var wt=Me.data,pn=wt.setBoundingBox,$r=It,Jn=Ke.la,ot=new Qe;if(wn(ot,1,Jn.ra),wn(ot,2,Jn.sa),wn(ot,3,Jn.height),wn(ot,4,Jn.width),wn(ot,5,Jn.rotation),Yn(ot,6,Jn.pa),Jn=ot.l(),pn.call(wt,$r,Jn),Ke.ea)for(wt=0;wt<Ke.ea.length;++wt){ot=Ke.ea[wt],pn=Me.data,$r=pn.addNormalizedLandmark,Jn=It,ot=Object.assign({},ot,{visibility:ot.visibility?ot.visibility:0});var mn=new X;wn(mn,1,ot.x),wn(mn,2,ot.y),wn(mn,3,ot.z),ot.visibility&&wn(mn,4,ot.visibility),ot=mn.l(),$r.call(pn,Jn,ot)}if(Ke.ba)for(wt=0;wt<Ke.ba.length;++wt)pn=Me.data,$r=pn.addClassification,Jn=It,ot=Ke.ba[wt],mn=new Ys,wn(mn,2,ot.score),ot.index&&Yn(mn,1,ot.index),ot.label&&Yn(mn,3,ot.label),ot.displayName&&Yn(mn,4,ot.displayName),ot=mn.l(),$r.call(pn,Jn,ot)}Me=Me.data;break e;default:Me={}}}switch(ie=Me,me=Y.stream,Y.type){case"video":R.pushTexture2d(Object.assign({},ie,{stream:me,timestamp:T}));break;case"detections":Be=ie,Be.stream=me,Be.timestamp=T,R.pushDetectionList(Be);break;default:throw Error("Unknown input config type: '"+Y.type+"'")}}return w.j.send(R),C(De,w.I,4);case 4:R.delete(),De.h=0}})};function yw(p,b,w){var T,R,P,O,M,Y,ie,me,Be,De,we,Me,Ke,It;return Z(function(wt){switch(wt.h){case 1:if(!w)return wt.return(b);for(T={},R=0,P=a(Object.keys(w)),O=P.next();!O.done;O=P.next())M=O.value,Y=w[M],typeof Y!="string"&&Y.type==="texture"&&b[Y.stream]!==void 0&&++R;1<R&&(p.M=!1),ie=a(Object.keys(w)),O=ie.next();case 2:if(O.done){wt.h=4;break}if(me=O.value,Be=w[me],typeof Be=="string")return Ke=T,It=me,C(wt,xw(p,me,b[Be]),14);if(De=b[Be.stream],Be.type==="detection_list"){if(De){for(var pn=De.getRectList(),$r=De.getLandmarksList(),Jn=De.getClassificationsList(),ot=[],mn=0;mn<pn.size();++mn){var Zs=cr(pn.get(mn)),vw=Ln(Zs,1),ww=Ln(Zs,2),Sw=Ln(Zs,3),Cw=Ln(Zs,4),$w=Ln(Zs,5,0),_u=void 0;_u=_u===void 0?0:_u,Zs={la:{ra:vw,sa:ww,height:Sw,width:Cw,rotation:$w,pa:Ur(vn(Zs,6),_u)},ea:Vr(gt($r.get(mn)),X,1).map($i),ba:Qs(W(Jn.get(mn)))},ot.push(Zs)}pn=ot}else pn=[];T[me]=pn,wt.h=7;break}if(Be.type==="proto_list"){if(De){for(pn=Array(De.size()),$r=0;$r<De.size();$r++)pn[$r]=De.get($r);De.delete()}else pn=[];T[me]=pn,wt.h=7;break}if(De===void 0){wt.h=3;break}if(Be.type==="float_list"){T[me]=De,wt.h=7;break}if(Be.type==="proto"){T[me]=De,wt.h=7;break}if(Be.type!=="texture")throw Error("Unknown output config type: '"+Be.type+"'");return we=p.v[me],we||(we=new Ni(p.i,p.K),p.v[me]=we),C(wt,fd(we,De,p.M),13);case 13:Me=wt.i,T[me]=Me;case 7:Be.transform&&T[me]&&(T[me]=Be.transform(T[me])),wt.h=3;break;case 14:Ke[It]=wt.i;case 3:O=ie.next(),wt.h=2;break;case 4:return wt.return(T)}})}function xw(p,b,w){var T;return Z(function(R){return typeof w=="number"||w instanceof Uint8Array||w instanceof p.i.Uint8BlobList?R.return(w):w instanceof p.i.Texture2dDataOut?(T=p.v[b],T||(T=new Ni(p.i,p.K),p.v[b]=T),R.return(fd(T,w,p.M))):R.return(void 0)})}function bw(p,b){for(var w=b.name||"$",T=[].concat(u(b.wants)),R=new p.i.StringList,P=a(b.wants),O=P.next();!O.done;O=P.next())R.push_back(O.value);P=p.i.PacketListener.implement({onResults:function(M){for(var Y={},ie=0;ie<b.wants.length;++ie)Y[T[ie]]=M.get(ie);var me=p.listeners[w];me&&(p.I=yw(p,Y,b.outs).then(function(Be){Be=me(Be);for(var De=0;De<b.wants.length;++De){var we=Y[T[De]];typeof we=="object"&&we.hasOwnProperty&&we.hasOwnProperty("delete")&&we.delete()}Be&&(p.I=Be)}))}}),p.j.attachMultiListener(R,P),R.delete()}t.onResults=function(p,b){this.listeners[b||"$"]=p},Te("Solution",cl),Te("OptionType",{BOOL:0,NUMBER:1,ta:2,0:"BOOL",1:"NUMBER",2:"STRING"});function pd(p){return p===void 0&&(p=0),p===1?"hand_landmark_full.tflite":"hand_landmark_lite.tflite"}function md(p){var b=this;p=p||{},this.h=new cl({locateFile:p.locateFile,files:function(w){return[{url:"hands_solution_packed_assets_loader.js"},{simd:!1,url:"hands_solution_wasm_bin.js"},{simd:!0,url:"hands_solution_simd_wasm_bin.js"},{data:!0,url:pd(w.modelComplexity)}]},graph:{url:"hands.binarypb"},inputs:{image:{type:"video",stream:"input_frames_gpu"}},listeners:[{wants:["multi_hand_landmarks","multi_hand_world_landmarks","image_transformed","multi_handedness"],outs:{image:"image_transformed",multiHandLandmarks:{type:"proto_list",stream:"multi_hand_landmarks",transform:Ti},multiHandWorldLandmarks:{type:"proto_list",stream:"multi_hand_world_landmarks",transform:Ti},multiHandedness:{type:"proto_list",stream:"multi_handedness",transform:function(w){return w.map(function(T){return Qs(W(T))[0]})}}}}],options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumHands:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculator",fieldName:"int_value"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(w){var T,R,P;return Z(function(O){return O.h==1?(T=pd(w),R="third_party/mediapipe/modules/hand_landmark/"+T,C(O,Eu(b.h,T),2)):(P=O.i,b.h.overrideFile(R,P),O.return(!0))})}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"handlandmarktrackinggpu__palmdetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"handlandmarktrackinggpu__handlandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}}}})}t=md.prototype,t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(p){this.h.onResults(p)},t.initialize=function(){var p=this;return Z(function(b){return C(b,p.h.initialize(),0)})},t.reset=function(){this.h.reset()},t.send=function(p){var b=this;return Z(function(w){return C(w,b.h.send(p),0)})},t.setOptions=function(p){this.h.setOptions(p)},Te("Hands",md),Te("HAND_CONNECTIONS",[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]]),Te("VERSION","0.4.1675469240")}).call(Rr);al.VERSION=VERSION;al.HAND_CONNECTIONS=HAND_CONNECTIONS;var Aj=al.Hands=Hands;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oj=G();Oj.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var tr;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(tr||(tr={}));var am;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(am||(am={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dj={};function tw(t){return Dj[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v(t,e,n,r,s){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return on(e.inputNames[c],n,r,s);if(o.type==="tensors"){const f=e.inputs.slice(a,u);return e.inputNames.slice(a,u).filter((m,x)=>{var g;return((g=f[x])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(m=>on(m,n,r,s))}const l=on(e.inputNames[c],n,r,s),h=l.dataSync();return o.type==="number"?h[0]:ah(l.shape,h)}const i=e.attrParams[t];return i&&i.value}function on(t,e,n,r){const[s,o]=nr(t,n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=n.currentContextIds.find(a=>!!e[wc(s,a)]);return i!==void 0?e[wc(s,i)][o]:void 0}function um(t,e,n){return e[wc(t,n.currentContextId)]}function Is(t,e){const[n,r,s]=nr(t,e);return[wc(n,e&&e.currentContextId),r,s]}function wc(t,e){return e?`${t}-${e}`:t}function nr(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const o=e.parseNodeNameCache.get(t);if(o!=null)return o}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const o=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[o,a,i]}return n&&e.parseNodeNameCache.set(t,s),s}function Qu(t,e,n){let r=v("pad",t,e,n);if(r==="explicit"){r=v("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function ks(t){return t.kept?t:co(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pj=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Fj=Object.freeze(Object.defineProperty({__proto__:null,json:Pj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lj=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Bj=Object.freeze(Object.defineProperty({__proto__:null,json:Lj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mj=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Vj=Object.freeze(Object.defineProperty({__proto__:null,json:Mj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uj=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Wj=Object.freeze(Object.defineProperty({__proto__:null,json:Uj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zj=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Gj=Object.freeze(Object.defineProperty({__proto__:null,json:zj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jj=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Hj=Object.freeze(Object.defineProperty({__proto__:null,json:jj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kj=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],qj=Object.freeze(Object.defineProperty({__proto__:null,json:Kj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xj=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Yj=Object.freeze(Object.defineProperty({__proto__:null,json:Xj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qj=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Zj=Object.freeze(Object.defineProperty({__proto__:null,json:Qj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jj=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],eH=Object.freeze(Object.defineProperty({__proto__:null,json:Jj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tH=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],nH=Object.freeze(Object.defineProperty({__proto__:null,json:tH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rH=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],sH=Object.freeze(Object.defineProperty({__proto__:null,json:rH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oH=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],iH=Object.freeze(Object.defineProperty({__proto__:null,json:oH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],uH=Object.freeze(Object.defineProperty({__proto__:null,json:aH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cH=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],lH=Object.freeze(Object.defineProperty({__proto__:null,json:cH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hH=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],fH=Object.freeze(Object.defineProperty({__proto__:null,json:hH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dH=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],pH=Object.freeze(Object.defineProperty({__proto__:null,json:dH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mH=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],gH=Object.freeze(Object.defineProperty({__proto__:null,json:mH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yH=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],xH=Object.freeze(Object.defineProperty({__proto__:null,json:yH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cm{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Fj,Bj,Vj,Wj,Gj,Hj,qj,Yj,Zj,eH,nH,sH,iH,uH,lH,fH,pH,gH,xH],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((x,g)=>(x[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(x[g.name]):g.op==="Const"?o.push(x[g.name]):(g.input==null||g.input.length===0)&&i.push(x[g.name]),x),{});let u=[];const c=[];let l={},h={};n!=null&&(l=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const f=Object.keys(a);f.forEach(x=>{const g=a[x];g.inputNames.forEach((y,S)=>{const[$,,C]=Is(y),_=a[$];if(_.outputs!=null){const L=_.outputs.indexOf(C);if(L!==-1){const V=`${$}:${L}`;g.inputNames[S]=V}}g.inputs.push(_),_.children.push(g)})}),Object.keys(h).length===0?f.forEach(x=>{const g=a[x];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(x=>{const[g]=Is(x),y=a[g];y!=null&&(y.signatureKey=h[x],c.push(y))}),Object.keys(l).length>0?Object.keys(l).forEach(x=>{const[g]=Is(x),y=a[g];y&&(y.signatureKey=l[x],u.push(y))}):u=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((x,g)=>(x[g.signature.name]=this.mapFunction(g),x),{}));const m={nodes:a,inputs:u,outputs:c,weights:o,placeholders:s,signature:n,functions:d};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=tw(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=Lh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Lh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Gh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Gh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Mh(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Mh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=zh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=zh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=Bh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Bh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Hh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Hh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Wh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Wh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=jh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=jh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Vh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Vh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Uh(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Uh(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=lm(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=lm(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let o={};n!=null&&(o=n.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&s.push(h[f.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=Is(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:hd(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,i.push(d),o[f]=d}),Object.keys(o).forEach(h=>{const f=o[h];f.inputNames.forEach((d,m)=>{const[x,,g]=Is(d),y=o[x];if(y.outputs!=null){const S=y.outputs.indexOf(g);if(S!==-1){const $=`${x}:${S}`;f.inputNames[m]=$}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=Is(c[h.name]),m=o[f];m!=null&&(m.defaultOutput=d,a.push(m))});const l=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function bH(t){const e=G().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function nw(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):bH(t);return e?n:n.toLowerCase()}function Lh(t,e,n,r=!1){const s=t[e];return s!=null?nw(s.s,r):n}function Bh(t,e,n){const r=t[e];return r?r.b:n}function Mh(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function hd(t){switch(typeof t=="string"&&(t=tr[t]),t){case tr.DT_FLOAT:case tr.DT_HALF:return"float32";case tr.DT_INT32:case tr.DT_INT64:case tr.DT_INT8:case tr.DT_UINT8:return"int32";case tr.DT_BOOL:return"bool";case tr.DT_DOUBLE:return"float32";case tr.DT_STRING:return"string";case tr.DT_COMPLEX64:case tr.DT_COMPLEX128:return"complex64";default:return null}}function lm(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Vh(t,e,n){const r=t[e];return r&&r.type?hd(r.type):n}function Uh(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>hd(s)):n}function rw(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Wh(t,e,n){const r=t[e];return r&&r.shape?rw(r.shape):n}function zh(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function Gh(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(o=>nw(o,r)):n}function jh(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>rw(s)):n}function Hh(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vH{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return on(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return on(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Mh(this.node.rawAttrs,e,n);if(r.s!=null)return Lh(this.node.rawAttrs,e,n);if(r.b!=null)return Bh(this.node.rawAttrs,e,n);if(r.shape!=null)return Wh(this.node.rawAttrs,e,n);if(r.type!=null)return Vh(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return zh(this.node.rawAttrs,e,n);if(r.list.s!=null)return Gh(this.node.rawAttrs,e,n);if(r.list.shape!=null)return jh(this.node.rawAttrs,e,n);if(r.list.b!=null)return Hh(this.node.rawAttrs,e,n);if(r.list.type!=null)return Uh(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:t1,abs:fr,acos:Q2,acosh:J2,add:Fe,addN:tN,all:rN,any:oN,argMax:aN,argMin:cN,asin:hN,asinh:dN,atan:mN,atan2:yN,atanh:bN,avgPool:y1,avgPool3d:EN,basicLSTMCell:DN,batchNorm:zc,batchNorm2d:MN,batchNorm3d:UN,batchNorm4d:zN,batchToSpaceND:x1,bincount:b1,bitwiseAnd:HN,booleanMaskAsync:kR,broadcastArgs:qN,broadcastTo:Ga,buffer:Ft,cast:Dt,ceil:QN,clipByValue:v1,clone:co,complex:po,concat:un,concat1d:eE,concat2d:nE,concat3d:sE,concat4d:iE,conv1d:cE,conv2d:Gc,conv2dTranspose:fE,conv3d:pE,conv3dTranspose:xE,cos:vE,cosh:SE,cosineWindow:Hf,cumprod:$E,cumsum:NE,denseBincount:_E,depthToSpace:kE,depthwiseConv2d:If,diag:OE,dilation2d:PE,div:Xe,divNoNan:VE,dot:WE,dropout:zR,einsum:Oi,elu:$1,enclosingPowerOfTwo:J1,ensureShape:HE,equal:C1,erf:qE,euclideanNorm:r_,exp:Fs,expandDims:hs,expm1:a_,eye:E1,fft:zf,fill:bu,floor:_1,floorDiv:m1,fused:sA,gather:I1,gatherND:VR,greater:Hc,greaterEqual:k1,ifft:mc,imag:Kc,image:el,inTopKAsync:jR,irfft:H1,isFinite:g_,isInf:x_,isNaN:v_,leakyRelu:R1,less:Eh,lessEqual:Af,linalg:LO,linspace:$_,localResponseNormalization:N_,log:su,log1p:A1,logSigmoid:O_,logSoftmax:F_,logSumExp:D1,logicalAnd:fc,logicalNot:P1,logicalOr:F1,logicalXor:W_,losses:BO,lowerBound:G_,matMul:dt,max:Wi,maxPool:L1,maxPool3d:K_,maxPoolWithArgmax:X_,maximum:B1,mean:dc,meshgrid:Z_,min:Nh,minimum:pc,mirrorPad:tI,mod:rI,moments:oI,movingAverage:OR,mul:he,multiRNNCell:aI,multinomial:cI,neg:gs,norm:jc,notEqual:M1,oneHot:fI,ones:Uo,onesLike:pI,op:F,outerProduct:gI,pad:vu,pad1d:bI,pad2d:wI,pad3d:CI,pad4d:TI,pool:kI,pow:ru,prelu:U1,print:p1,prod:OI,raggedGather:PI,raggedRange:LI,raggedTensorToTensor:MI,rand:UI,randomGamma:ak,randomNormal:z1,randomStandardNormal:lk,randomUniform:Wf,randomUniformInt:dk,range:ou,real:iu,reciprocal:gk,relu:qc,relu6:G1,reshape:ee,reverse:ti,reverse1d:wk,reverse2d:Ck,reverse3d:Tk,reverse4d:Ek,rfft:Gf,round:j1,rsqrt:kk,scalar:Ze,scatterND:PR,searchSorted:Of,selu:Ak,separableConv2d:Dk,setdiff1dAsync:Fk,sigmoid:jo,sign:Bk,signal:FO,sin:Vk,sinh:Wk,slice:We,slice1d:Gk,slice2d:Hk,slice3d:qk,slice4d:Yk,softmax:Zk,softplus:O1,spaceToBatchND:V1,sparse:MO,sparseToDense:BR,spectral:PO,split:au,sqrt:Ps,square:Yr,squaredDifference:K1,squeeze:rn,stack:Bs,step:q1,stridedSlice:cR,string:VO,sub:ze,sum:Ct,tan:hR,tanh:Th,tensor:ms,tensor1d:gn,tensor2d:Ho,tensor3d:X1,tensor4d:fR,tensor5d:dR,tensor6d:pR,tensorScatterUpdate:gR,tile:ja,topk:xR,transpose:_h,truncatedNormal:vR,unique:SR,unsortedSegmentSum:$R,unstack:li,upperBound:NR,variable:ER,where:lo,whereAsync:Z1,zeros:ei,zerosLike:gr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wH=(t,e,n,r=fn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(v("a",t,e,n),v("b",t,e,n))];case"AddN":return[r.addN(v("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(v("a",t,e,n),v("b",t,e,n))];case"Mul":return[r.mul(v("a",t,e,n),v("b",t,e,n))];case"RealDiv":case"Div":return[r.div(v("a",t,e,n),v("b",t,e,n))];case"DivNoNan":return[r.divNoNan(v("a",t,e,n),v("b",t,e,n))];case"FloorDiv":return[r.floorDiv(v("a",t,e,n),v("b",t,e,n))];case"Sub":return[r.sub(v("a",t,e,n),v("b",t,e,n))];case"Minimum":return[r.minimum(v("a",t,e,n),v("b",t,e,n))];case"Maximum":return[r.maximum(v("a",t,e,n),v("b",t,e,n))];case"Pow":return[r.pow(v("a",t,e,n),v("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(v("a",t,e,n),v("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH=(t,e,n,r=fn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(v("x",t,e,n))];case"Acos":return[r.acos(v("x",t,e,n))];case"Acosh":return[r.acosh(v("x",t,e,n))];case"Asin":return[r.asin(v("x",t,e,n))];case"Asinh":return[r.asinh(v("x",t,e,n))];case"Atan":return[r.atan(v("x",t,e,n))];case"Atan2":return[r.atan2(v("x",t,e,n),v("y",t,e,n))];case"Atanh":return[r.atanh(v("x",t,e,n))];case"Ceil":return[r.ceil(v("x",t,e,n))];case"Complex":return[r.complex(v("real",t,e,n),v("imag",t,e,n))];case"Cos":return[r.cos(v("x",t,e,n))];case"Cosh":return[r.cosh(v("x",t,e,n))];case"Elu":return[r.elu(v("x",t,e,n))];case"Erf":return[r.erf(v("x",t,e,n))];case"Exp":return[r.exp(v("x",t,e,n))];case"Expm1":return[r.expm1(v("x",t,e,n))];case"Floor":return[r.floor(v("x",t,e,n))];case"Log":return[r.log(v("x",t,e,n))];case"Log1p":return[r.log1p(v("x",t,e,n))];case"Imag":return[r.imag(v("x",t,e,n))];case"Neg":return[r.neg(v("x",t,e,n))];case"Reciprocal":return[r.reciprocal(v("x",t,e,n))];case"Real":return[r.real(v("x",t,e,n))];case"Relu":return[r.relu(v("x",t,e,n))];case"Round":return[r.round(v("x",t,e,n))];case"Selu":return[r.selu(v("x",t,e,n))];case"Sigmoid":return[r.sigmoid(v("x",t,e,n))];case"Sin":return[r.sin(v("x",t,e,n))];case"Sign":return[r.sign(v("x",t,e,n))];case"Sinh":return[r.sinh(v("x",t,e,n))];case"Softplus":return[r.softplus(v("x",t,e,n))];case"Sqrt":return[r.sqrt(v("x",t,e,n))];case"Square":return[r.square(v("x",t,e,n))];case"Tanh":return[r.tanh(v("x",t,e,n))];case"Tan":return[r.tan(v("x",t,e,n))];case"ClipByValue":return[r.clipByValue(v("x",t,e,n),v("clipValueMin",t,e,n),v("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(v("x",t,e,n))];case"Rsqrt":return[r.rsqrt(on(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(v("x",t,e,n),v("alpha",t,e,n))];case"Prelu":return[r.prelu(v("x",t,e,n),v("alpha",t,e,n))];case"IsNan":return[r.isNaN(on(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(on(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(on(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){I(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=e[r];I(s<0||o<0||s===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function hm(t){return!(typeof t=="number"||t.some(e=>e<0))}function _a(t,e,n){let r=Kh(t,n);const s=!hm(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Kh(o.shape,r)}),!hm(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Kh(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:o}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CH{constructor(e,n,r,s,o,i,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Ze(0),fs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Nr(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,fs(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return ms([],[0].concat(this.elementShape));const r=this.readMany(e);return Nr(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Bs(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ms([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return Nr(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),un(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,li(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:n.size/r,i=[];qe(()=>{n=ee(n,[1,r,o]);for(let u=0;u<e.length;++u){const l=[0,u===0?0:s[u-1],0],h=[1,e[u],o];i[u]=ee(We(n,l,h),this.elementShape)}return i});const a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oi{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Nr(n,o.shape,"TensorList shape mismatch: "),fs(o)}),this.idTensor=Ze(0),this.maxNumElements=s,fs(this.idTensor)}copy(){return new oi([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Nr(e,this.elementShape,"TensorList shape mismatch: ");const s=_a(this.elementShape,this.tensors,e);return qe(()=>{const o=this.tensors.map(i=>ee(i,s));return Bs(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=_a(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,Nr(s.shape,e,"TensorList shape mismatch: "),ee(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Nr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");fs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new oi([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Nr(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=_a(this.elementShape,this.tensors,n);return ee(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Nr(this.elementShape,n.shape,"TensorList shape mismatch: "),fs(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Nr(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=_a(this.elementShape,this.tensors,r);return e.length===0?ms([],[0].concat(s)):qe(()=>{const o=e.map(i=>ee(this.tensors[i],s));return Bs(o,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Nr(this.elementShape,n,"TensorList shape mismatch: ");const r=_a(this.elementShape,this.tensors,n);return this.size()===0?ms([],[0].concat(r)):qe(()=>{const s=this.tensors.map(o=>ee(o,r));return un(s,0)})}}function $H(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);Nr(s,e,"TensorList shape mismatch: ");const o=li(t);return new oi(o,e,r)}function TH(t,e,n,r){return new oi([],t,e,r)}function NH(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new oi([],n,t.dtype,r),i=li(t,0);return e.forEach((a,u)=>{o.setItem(a,i[u])}),o}function EH(t,e,n){let r=0;const s=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),i=Kh(o,n),a=r===0?0:t.size/r,u=qe(()=>{const l=[];t=ee(t,[1,r,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:s[h-1],0],m=[1,e[h],a];l[h]=ee(We(t,d,m),i)}return t.dispose(),l}),c=new oi([],n,t.dtype,e.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _H=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=v("thenBranch",t,e,n),s=v("elseBranch",t,e,n),o=v("cond",t,e,n),i=v("args",t,e,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=v("body",t,e,n),s=v("cond",t,e,n),o=v("args",t,e,n),i=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(l=>l.id);let u=await i[0].data();i.forEach(l=>{!l.kept&&a.indexOf(l.id)===-1&&l.dispose()});let c=o;for(;u[0];){const l=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const h=c.map(d=>d.id);l.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=v("pred",t,e,n);return[ks(r)]}case"Switch":{const r=v("pred",t,e,n);let s=v("data",t,e,n);return s.kept||(s=ks(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>on(s,e,n)!==void 0);if(r){const s=on(r,e,n);return[ks(s)]}return}case"Enter":{const r=v("frameName",t,e,n),s=v("tensor",t,e,n);return n.enterFrame(r),[ks(s)]}case"Exit":{const r=v("tensor",t,e,n);return n.exitFrame(),[ks(r)]}case"NextIteration":{const r=v("tensor",t,e,n);return n.nextIteration(),[ks(r)]}case"TensorArrayV3":{const r=v("size",t,e,n),s=v("dtype",t,e,n),o=v("elementShape",t,e,n),i=v("dynamicSize",t,e,n),a=v("clearAfterRead",t,e,n),u=v("identicalElementShapes",t,e,n),c=v("name",t,e,n),l=new CH(c,s,r,o,u,i,a);return n.addTensorArray(l),[l.idTensor,Ze(1)]}case"TensorArrayWriteV3":{const r=v("tensorArrayId",t,e,n),s=v("index",t,e,n),o=v("tensor",t,e,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=v("tensorArrayId",t,e,n),s=v("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=v("tensorArrayId",t,e,n),s=v("indices",t,e,n),o=v("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=v("tensorArrayId",t,e,n),s=v("indices",t,e,n),o=v("tensor",t,e,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=v("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),o=v("dtype",t,e,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=v("tensorArrayId",t,e,n),s=v("tensor",t,e,n),o=v("lengths",t,e,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=v("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[Ze(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=v("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=v("tensorListId",t,e,n),s=v("index",t,e,n),o=v("tensor",t,e,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=v("tensorListId",t,e,n),s=v("index",t,e,n),o=v("elementShape",t,e,n),i=v("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=v("indices",t,e,n),s=v("tensor",t,e,n),o=v("elementShape",t,e,n),i=v("numElements",t,e,n),a=NH(s,r,o,i);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=v("elementShape",t,e,n),s=v("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=v(o,t,e,n),a=t.op==="TensorListReserve"?-1:i,u=TH(r,s,i,a);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=v("tensorListId",t,e,n),s=v("indices",t,e,n),o=v("elementShape",t,e,n),i=v("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=v("tensorListId",t,e,n),s=v("elementShape",t,e,n),o=v("elementDType",t,e,n),i=v("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=v("tensor",t,e,n),s=v("elementShape",t,e,n),o=v("elementDType",t,e,n),i=$H(r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=v("tensorListId",t,e,n),s=n.getTensorList(r.id),o=v("dtype",t,e,n),i=v("elementShape",t,e,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=v("tensorListId",t,e,n),s=v("tensor",t,e,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=v("tensorListId",t,e,n),s=v("elementShape",t,e,n),o=v("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=v("tensor",t,e,n),s=v("elementShape",t,e,n),o=v("lengths",t,e,n),i=EH(r,o,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=v("tensorListId",t,e,n),s=n.getTensorList(r.id);return[Ze(s.size(),"int32")]}case"TensorListResize":{const r=v("tensorListId",t,e,n),s=v("size",t,e,n),i=n.getTensorList(r.id).resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fm(t,e,n){const[r,s]=v("fusedOps",t,e,n),o=r==="biasadd",i=!o,a=s==="prelu",u=r==="fusedbatchnorm",c=v("numArgs",t,e,n);if(o){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=v("strides",t,e,n),h=Qu(t,e,n),f=v("dataFormat",t,e,n).toUpperCase(),d=v("dilations",t,e,n);let[m,x]=v("args",t,e,n);i&&(x=m,m=void 0);const g=v("leakyreluAlpha",t,e,n);return{stride:l,pad:h,dataFormat:f,dilations:d,biasArg:m,preluArg:x,activationFunc:s,leakyreluAlpha:g}}const IH=(t,e,n,r=fn)=>{switch(t.op){case"Conv1D":{const s=v("stride",t,e,n),o=v("pad",t,e,n),i=v("dataFormat",t,e,n).toUpperCase(),a=v("dilation",t,e,n);return[r.conv1d(v("x",t,e,n),v("filter",t,e,n),s,o,i,a)]}case"Conv2D":{const s=v("strides",t,e,n),o=Qu(t,e,n),i=v("dataFormat",t,e,n).toUpperCase(),a=v("dilations",t,e,n);return[r.conv2d(v("x",t,e,n),v("filter",t,e,n),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:h}=fm(t,e,n);return[r.fused.conv2d({x:v("x",t,e,n),filter:v("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:h}=fm(t,e,n);return[r.fused.depthwiseConv2d({x:v("x",t,e,n),filter:v("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=v("outputShape",t,e,n),o=v("strides",t,e,n),i=Qu(t,e,n);return[r.conv2dTranspose(v("x",t,e,n),v("filter",t,e,n),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=v("strides",t,e,n),o=Qu(t,e,n),i=v("dilations",t,e,n),a=v("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(v("input",t,e,n),v("filter",t,e,n),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("dataFormat",t,e,n).toUpperCase(),a=v("dilations",t,e,n);return[r.conv3d(v("x",t,e,n),v("filter",t,e,n),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("kernelSize",t,e,n);return[r.avgPool(v("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("kernelSize",t,e,n);return[r.maxPool(v("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("kernelSize",t,e,n),a=v("includeBatchInIndex",t,e,n),{result:u,indexes:c}=r.maxPoolWithArgmax(v("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o,a);return[u,c]}case"AvgPool3D":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("kernelSize",t,e,n);return[r.avgPool3d(v("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("kernelSize",t,e,n);return[r.maxPool3d(v("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=v("strides",t,e,n),o=v("pad",t,e,n),i=v("dilations",t,e,n),a=s[1],u=s[2],c=i[1],l=i[2];return[r.dilation2d(v("x",t,e,n),v("filter",t,e,n),[a,u],o,[c,l],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kH=(t,e,n,r=fn)=>{switch(t.op){case"Fill":{const s=v("shape",t,e,n),o=v("dtype",t,e,n),i=v("value",t,e,n);return[r.fill(s,i,o)]}case"LinSpace":{const s=v("start",t,e,n),o=v("stop",t,e,n),i=v("num",t,e,n);return[r.linspace(s,o,i)]}case"Multinomial":{const s=v("logits",t,e,n),o=v("numSamples",t,e,n),i=v("seed",t,e,n);return[r.multinomial(s,o,i)]}case"OneHot":{const s=v("indices",t,e,n),o=v("depth",t,e,n),i=v("onValue",t,e,n),a=v("offValue",t,e,n),u=v("dtype",t,e,n);return[r.oneHot(s,o,i,a,u)]}case"Ones":return[r.ones(v("shape",t,e,n),v("dtype",t,e,n))];case"OnesLike":return[r.onesLike(v("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(v("shape",t,e,n),v("dtype",t,e,n),v("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(v("shape",t,e,n),v("minval",t,e,n),v("maxval",t,e,n),v("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(v("shape",t,e,n),v("minval",t,e,n),v("maxval",t,e,n),v("seed",t,e,n))];case"Range":{const s=v("start",t,e,n),o=v("stop",t,e,n),i=v("step",t,e,n);return[r.range(s,o,i,v("dtype",t,e,n))]}case"TruncatedNormal":{const s=v("shape",t,e,n),o=v("mean",t,e,n),i=v("stdDev",t,e,n),a=v("seed",t,e,n);return[r.truncatedNormal(s,o,i,v("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(v("shape",t,e,n),v("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(v("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(t,e,n){const r=v("boxes",t,e,n),s=v("scores",t,e,n),o=v("maxOutputSize",t,e,n),i=v("iouThreshold",t,e,n),a=v("scoreThreshold",t,e,n),u=v("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}const RH=async(t,e,n,r,s=fn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=Fl(t,e,n),h=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,u,c,l);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:c}=Fl(t,e,n),l=v("padToMaxOutputSize",t,e,n),h=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,u,c,l);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:c}=Fl(t,e,n);return[await s.image.nonMaxSuppressionAsync(o,i,a,u,c)]}case"Where":{const o=s.cast(v("condition",t,e,n),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(v("x",t,e,n),v("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AH=(t,e,n,r=fn)=>{switch(t.op){case"LowerBound":{const s=v("sortedSequence",t,e,n),o=v("values",t,e,n);return[r.lowerBound(s,o)]}case"TopKV2":{const s=v("x",t,e,n),o=v("k",t,e,n),i=v("sorted",t,e,n),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=v("sortedSequence",t,e,n),o=v("values",t,e,n);return[r.upperBound(s,o)]}case"Unique":{const s=v("x",t,e,n),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=v("x",t,e,n),o=v("axis",t,e,n),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OH=(t,e,n,r=fn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=v("default",t,e,n);return[on(t.name,e,n)||s];case"Placeholder":return[on(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=v("x",t,e,n);return[ks(l)]}case"IdentityN":return v("x",t,e,n).map(l=>ks(l));case"Snapshot":const o=v("x",t,e,n);return[ks(o)];case"Shape":return[r.tensor1d(v("x",t,e,n).shape,"int32")];case"ShapeN":return v("x",t,e,n).map(l=>r.tensor1d(l.shape));case"Size":return[r.scalar(v("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(v("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=v("x",t,e,n),a=v("data",t,e,n),u=v("message",t,e,n),c=v("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<a.length;l++)console.log(Array.prototype.slice.call(a[l].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DH{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=Ze(0),this.tensorMap=new Map,fs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ze(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),qe(()=>{const s=li(n),o=r.length,i=s.length;I(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const u=r[a],c=s[a];fs(c),this.tensorMap.set(u,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return qe(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,n);s.push(a)}return Bs(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PH=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const o=v("keyDType",t,e,n),i=v("valueDType",t,e,n),a=new DH(o,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=v("tableHandle",t,e,n,r),o=v("keys",t,e,n),i=v("values",t,e,n);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=v("tableHandle",t,e,n,r),o=v("keys",t,e,n),i=v("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=v("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FH=(t,e,n,r=fn)=>{switch(t.op){case"ResizeBilinear":{const s=v("images",t,e,n),o=v("size",t,e,n),i=v("alignCorners",t,e,n),a=v("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=v("images",t,e,n),o=v("size",t,e,n),i=v("alignCorners",t,e,n),a=v("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=v("image",t,e,n),o=v("boxes",t,e,n),i=v("boxInd",t,e,n),a=v("cropSize",t,e,n),u=v("method",t,e,n),c=v("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,o,i,a,u,c)]}case"ImageProjectiveTransformV3":{const s=v("images",t,e,n),o=v("transforms",t,e,n),i=v("outputShape",t,e,n),a=v("fillValue",t,e,n),u=v("interpolation",t,e,n),c=v("fillMode",t,e,n);return[r.image.transform(s,o,u.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH=(t,e,n,r=fn)=>{switch(t.op){case"Equal":return[r.equal(v("a",t,e,n),v("b",t,e,n))];case"NotEqual":return[r.notEqual(v("a",t,e,n),v("b",t,e,n))];case"Greater":return[r.greater(v("a",t,e,n),v("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(v("a",t,e,n),v("b",t,e,n))];case"Less":return[r.less(v("a",t,e,n),v("b",t,e,n))];case"LessEqual":return[r.lessEqual(v("a",t,e,n),v("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(v("a",t,e,n),v("b",t,e,n))];case"LogicalNot":return[r.logicalNot(v("a",t,e,n))];case"LogicalOr":return[r.logicalOr(v("a",t,e,n),v("b",t,e,n))];case"Select":case"SelectV2":return[r.where(v("condition",t,e,n),v("a",t,e,n),v("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(v("a",t,e,n),v("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BH=(t,e,n,r=fn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(v("a",t,e,n),v("b",t,e,n),v("transposeA",t,e,n),v("transposeB",t,e,n))];case"Einsum":return[r.einsum(v("equation",t,e,n),...v("tensors",t,e,n))];case"Transpose":return[r.transpose(v("x",t,e,n),v("perm",t,e,n))];case"_FusedMatMul":const[s,o]=v("fusedOps",t,e,n),i=s==="biasadd",a=o==="prelu",u=v("numArgs",t,e,n),c=v("leakyreluAlpha",t,e,n);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,h]=v("args",t,e,n);return[r.fused.matMul({a:v("a",t,e,n),b:v("b",t,e,n),transposeA:v("transposeA",t,e,n),transposeB:v("transposeB",t,e,n),bias:l,activation:o,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(v("a",t,e,n),v("numLower",t,e,n),v("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH=(t,e,n,r=fn)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(v("x",t,e,n),v("axis",t,e,n),v("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(v("x",t,e,n),v("mean",t,e,n),v("variance",t,e,n),v("offset",t,e,n),v("scale",t,e,n),v("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(v("x",t,e,n),v("mean",t,e,n),v("variance",t,e,n),v("offset",t,e,n),v("scale",t,e,n),v("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(v("x",t,e,n),v("radius",t,e,n),v("bias",t,e,n),v("alpha",t,e,n),v("beta",t,e,n))];case"Softmax":return[r.softmax(v("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(v("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VH=(t,e,n,r=fn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(v("paramsNestedSplits",t,e,n),v("paramsDenseValues",t,e,n),v("indices",t,e,n),v("outputRaggedRank",t,e,n));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(v("starts",t,e,n),v("limits",t,e,n),v("splits",t,e,n));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(v("shape",t,e,n),v("values",t,e,n),v("defaultValue",t,e,n),v("rowPartitionTensors",t,e,n),v("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UH=(t,e,n,r=fn)=>{switch(t.op){case"Max":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.max(v("x",t,e,n),a,u)]}case"Mean":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.mean(v("x",t,e,n),a,u)]}case"Min":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.min(v("x",t,e,n),a,u)]}case"Sum":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.sum(v("x",t,e,n),a,u)]}case"All":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.all(v("x",t,e,n),a,u)]}case"Any":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.any(v("x",t,e,n),a,u)]}case"ArgMax":{const a=v("axis",t,e,n);return[r.argMax(v("x",t,e,n),a)]}case"ArgMin":{const a=v("axis",t,e,n);return[r.argMin(v("x",t,e,n),a)]}case"Prod":{const a=v("axis",t,e,n),u=v("keepDims",t,e,n);return[r.prod(v("x",t,e,n),a,u)]}case"Cumprod":{const a=v("axis",t,e,n),u=v("exclusive",t,e,n),c=v("reverse",t,e,n);return[r.cumprod(v("x",t,e,n),a,u,c)]}case"Cumsum":{const a=v("axis",t,e,n),u=v("exclusive",t,e,n),c=v("reverse",t,e,n);return[r.cumsum(v("x",t,e,n),a,u,c)]}case"Bincount":const s=v("x",t,e,n),o=v("weights",t,e,n),i=v("size",t,e,n);return[r.bincount(s,o,i)];case"DenseBincount":{const a=v("x",t,e,n),u=v("weights",t,e,n),c=v("size",t,e,n),l=v("binaryOutput",t,e,n);return[r.denseBincount(a,u,c,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH=(t,e,n,r=fn)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=v("n",t,e,n),o=v("axis",t,e,n);let i=v("tensors",t,e,n);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=v("x",t,e,n),o=v("indices",t,e,n);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=v("axis",t,e,n),o=v("batchDims",t,e,n),i=v("x",t,e,n),a=v("indices",t,e,n);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=v("dims",t,e,n),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=v("x",t,e,n);return[r.reverse(i,o)]}case"ReverseV2":{const s=v("axis",t,e,n),o=v("x",t,e,n);return[r.reverse(o,s)]}case"Slice":{const s=v("begin",t,e,n),o=v("size",t,e,n);return[r.slice(v("x",t,e,n),s,o)]}case"StridedSlice":{const s=v("begin",t,e,n),o=v("end",t,e,n),i=v("strides",t,e,n),a=v("beginMask",t,e,n),u=v("endMask",t,e,n),c=v("ellipsisMask",t,e,n),l=v("newAxisMask",t,e,n),h=v("shrinkAxisMask",t,e,n),f=v("x",t,e,n);return[r.stridedSlice(f,s,o,i,a,u,c,l,h)]}case"Pack":return qe(()=>{const s=v("axis",t,e,n),o=v("tensors",t,e,n),i=o[0].shape,a=r.squeeze(o[0]).shape,u=o.map(c=>{const l=Pt(c.shape,i);if(!l&&!Pt(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return l?c:r.reshape(c,i)});return[r.stack(u,s)]});case"Unpack":{const s=v("axis",t,e,n),o=v("tensor",t,e,n);return r.unstack(o,s)}case"Tile":{const s=v("reps",t,e,n);return[r.tile(v("x",t,e,n),s)]}case"Split":case"SplitV":{const s=v("axis",t,e,n),o=v("numOrSizeSplits",t,e,n),i=v("x",t,e,n);return r.split(i,o,s)}case"ScatterNd":{const s=v("indices",t,e,n),o=v("values",t,e,n),i=v("shape",t,e,n);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=v("x",t,e,n),o=v("indices",t,e,n);return[r.gatherND(s,o)]}case"SparseToDense":{const s=v("sparseIndices",t,e,n),o=v("outputShape",t,e,n),i=v("sparseValues",t,e,n),a=v("defaultValue",t,e,n);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=v("indices",t,e,n),o=v("values",t,e,n),i=v("tensor",t,e,n);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zH=(t,e,n,r=fn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(v("indices",t,e,n),v("values",t,e,n),v("denseShape",t,e,n),v("defaultValue",t,e,n));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(v("inputIndices",t,e,n),v("inputShape",t,e,n),v("newShape",t,e,n));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(v("data",t,e,n),v("indices",t,e,n),v("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(v("data",t,e,n),v("indices",t,e,n),v("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GH=(t,e,n,r=fn)=>{switch(t.op){case"FFT":return[r.fft(v("x",t,e,n))];case"IFFT":return[r.ifft(v("x",t,e,n))];case"RFFT":return[r.rfft(v("x",t,e,n))];case"IRFFT":return[r.irfft(v("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jH=(t,e,n,r=fn)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(v("input",t,e,n),v("pattern",t,e,n),v("rewrite",t,e,n),v("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(v("data",t,e,n),v("dataSplits",t,e,n),v("separator",t,e,n),v("nGramWidths",t,e,n),v("leftPad",t,e,n),v("rightPad",t,e,n),v("padWidth",t,e,n),v("preserveShortSequences",t,e,n));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(v("input",t,e,n),v("delimiter",t,e,n),v("skipEmpty",t,e,n));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(v("input",t,e,n),v("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HH=(t,e,n,r=fn)=>{switch(t.op){case"Cast":return[r.cast(v("x",t,e,n),v("dtype",t,e,n))];case"ExpandDims":{const s=v("axis",t,e,n);return[r.expandDims(v("x",t,e,n),s)]}case"Squeeze":{const s=v("axis",t,e,n);return[r.squeeze(v("x",t,e,n),s)]}case"Reshape":return[r.reshape(v("x",t,e,n),v("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(v("x",t,e,n),v("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(v("x",t,e,n),v("padding",t,e,n),v("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(v("x",t,e,n),v("padding",t,e,n),v("constantValue",t,e,n))];case"SpaceToBatchND":{const s=v("blockShape",t,e,n),o=v("paddings",t,e,n);return[r.spaceToBatchND(v("x",t,e,n),s,o)]}case"BatchToSpaceND":{const s=v("blockShape",t,e,n),o=v("crops",t,e,n);return[r.batchToSpaceND(v("x",t,e,n),s,o)]}case"DepthToSpace":{const s=v("blockSize",t,e,n),o=v("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(v("x",t,e,n),s,o)]}case"BroadcastTo":return[r.broadcastTo(v("x",t,e,n),v("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(v("s0",t,e,n),v("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dm(t,e,n,r,s=qe){const o=((i,a,u)=>{switch(i.category){case"arithmetic":return s(()=>wH(i,a,u));case"basic_math":return s(()=>SH(i,a,u));case"control":return _H(i,a,u);case"convolution":return s(()=>IH(i,a,u));case"creation":return s(()=>kH(i,a,u));case"dynamic":return RH(i,a,u);case"evaluation":return s(()=>AH(i,a,u));case"image":return s(()=>FH(i,a,u));case"graph":return s(()=>OH(i,a,u));case"logical":return s(()=>LH(i,a,u));case"matrices":return s(()=>BH(i,a,u));case"normalization":return s(()=>MH(i,a,u));case"ragged":return s(()=>VH(i,a,u));case"reduction":return s(()=>UH(i,a,u));case"slice_join":return s(()=>WH(i,a,u));case"sparse":return s(()=>zH(i,a,u));case"spectral":return s(()=>GH(i,a,u));case"string":return s(()=>jH(i,a,u));case"transformation":return s(()=>HH(i,a,u));case"hash_table":return PH(i,a,u,r);case"custom":const c=tw(i.op);if(c&&c.customExecutor)return c.customExecutor(new vH(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return qo(o)?o.then(i=>[].concat(i)):[].concat(o)}class pm{constructor(e={},n={},r={},s={},o){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mm(t,e,n,r){const s=new Set,o=[];let i=null,a=null;const u=new Set,c=new Set(Object.keys(t).map(f=>nr(f)[0]));r=r||[];const l=new Set(r.map(f=>nr(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if((Bo(f)||e6(f)||t6(f))&&i==null&&(i=f,a=i.children.map(d=>d.name).filter(d=>s.has(d))),s.add(f.name),n[f.name]==null&&!c.has(f.name)&&!l.has(f.name)){if(f.inputs.length===0){o.push(f.name);continue}f.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),h.push(d))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function KH(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(g=>nr(g)[0]).map(g=>t.nodes[g]),o=t.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const u=a([...s,...t.weights,...o]).filter(i),c=a([...u,...Object.values(t.nodes)]).filter(i),l=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)i(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const f=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),d=[...f];for(;f.length>0;){const g=f.pop(),y=l.get(g);for(const S of y.children.filter(i))--h[S.name]===0&&(d.push(S.name),f.push(S.name))}const m=d.map(g=>l.get(g)),x=qH(m,u);return XH(x,u),x}function qH(t,e){const n=new Map(t.map(i=>[i.name,i])),r=e.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=n.get(i);for(const u of a.children)!n.has(u.name)||s.has(u.name)||(s.add(u.name),r.push(u.name))}return t.filter(i=>s.has(i.name))}class Wu extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function XH(t,e){const n=new Map(t.map((a,u)=>[a.name,u])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),o=new Set(t.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of t){for(const u of a.children.filter(i)){if(!n.has(u.name))throw new Wu(`Child ${u.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(u.name))throw new Wu(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!s(a))for(const u of a.inputs){if(!n.has(u.name))throw new Wu(`Input ${u.name} of node ${a.name} is unreachable.`);if(n.get(u.name)>n.get(a.name))throw new Wu(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}function YH(t){const e=new Map(t.map((a,u)=>[a.name,u])),n=Number.MAX_SAFE_INTEGER,r=t.map((a,u)=>Bo(a)?n:u),s=a=>{const u=r[e.get(a.name)];return u??-1},o=t.map((a,u)=>a.children.map(s).reduce((c,l)=>Math.max(c,l),r[u])),i=new Map;for(let a=0;a<t.length;++a){const u=o[a];if(u===n)continue;const c=t[a],l=t[u];i.has(l.name)||i.set(l.name,[]),i.get(l.name).push(c)}return i}const QH=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),ZH=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),JH=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Bo(t){return QH.has(t.op)}function e6(t){return ZH.has(t.op)}function t6(t){return JH.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sc{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Sc(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(o=>o.name).sort(),s=n.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=mm(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const c=n.map(h=>h.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}const a=KH(this.graph,r),u=YH(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return fs(n),n}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(f=>this.graph.nodes[nr(f)[0]]),o=n.map(f=>nr(f)[0]),i=new Set(o);let a=o.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const u=this.getCompilationKey(s,a);let c=this.compiledMap.get(u);c==null&&(c=this.compile(e,a),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const l={},h={};return qe(()=>{const f=new pm(this.weightMap,l,h,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[S,$]=nr(y,f),C=[];C[$]=e[y],d[S]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[S]=this.cloneTensorList(C))});const m=this.getFrozenTensorIds(d),{orderedNodes:x,nodeLiveUntilMap:g}=c;for(const y of x){if(d[y.name])continue;const S=dm(y,d,f,this._resourceManager);if(qo(S))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(S)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,m,i,g.get(y.name))}return this.parent==null&&f.dispose(m),n.map(y=>on(y,d,f))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,o,i,a){if(!(Bo(n)||i.has(e))){for(const u of r[e])u!=null&&(a[u.id]=(a[u.id]||0)+n.children.length);for(const u of n.inputs){if(Bo(u))continue;const c=um(u.name,r,s);if(c!=null)for(const l of c){if(!l||l.kept||o.has(l.id))continue;const h=a[l.id];h===1?(l.dispose(),delete a[l.id]):h!=null&&a[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,o,i){function a(u){return Bo(u)||o.has(u.name)}if(!(Bo(e)||i==null))for(const u of i){if(a(u))continue;const c=um(u.name,n,r);for(const l of c)!l||l.kept||s.has(l.id)||l.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},o={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const i=new pm(this.weightMap,s,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,n,r),u=n.map(f=>on(f,a,i)),c=u.map(f=>f.id),l=Object.keys(e).map(f=>e[f].id),h=new Set([...c,...l,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&i.dispose(h),u}async executeFunctionAsync(e,n,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const o=Object.keys(e),i=o.map(C=>this.graph.nodes[nr(C)[0]]),a=r.map(C=>nr(C)[0]),u=new Set(a);let c=a.map(C=>this.graph.nodes[C]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:h,dynamicNode:f,syncInputs:d}=mm(e,c,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:n.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[_,L]=nr(C),V=[];V[L]=e[C],x[_]=V});const g={},y=this.getFrozenTensorIds(x),S={};for(;m.length>0;){const C=this.processStack(i,m,n,x,S,y,u,g,l);await Promise.all(C)}f==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=c.filter(C=>!Bo(C)&&!on(C.name,x,n)).map(C=>C.name);if($.length>0){let C="";throw f!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${C}`)}return x}processStack(e,n,r,s,o,i,a,u,c){const l=[];for(;n.length>0;){const h=n.pop();r.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&v("isConstant",h.node,s,r)&&([f]=Is(h.node.name,r)),s[h.node.name]==null){const d=dm(h.node,s,r,this._resourceManager);f||([f]=Is(h.node.name,r));const m=r.currentContext;qo(d)?l.push(d.then(x=>(s[f]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(x)),r.currentContext=m,this.checkTensorForDisposal(f,h.node,s,r,i,a,u),this.processChildNodes(h.node,n,r,s,o,c),x))):(s[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,s,r,i,a,u),this.processChildNodes(h.node,n,r,s,o,c))}else this.processChildNodes(h.node,n,r,s,o,c)}return l}processChildNodes(e,n,r,s,o,i){e.children.forEach(a=>{const[u]=Is(a.name,r);o[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!on(c,s,r))&&(o[u]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!on(c,s,r))&&(o[u]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=nr(n),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((u,c)=>i[c]===-1||i[c]===u);I(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&I(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const o in e){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[o];i!=null?s[i.name]=e[o]:s[o]=e[o]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=nr(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const o=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=nr(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class n6{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r6="?tfjs-format=file",s6="model.json";class o6{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=hb){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new n6}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return qo(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await s1(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Sc(cm.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=cm.Instance.transformGraph(e.modelInitializer);this.initializer=new Sc(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof Yt?[e]:e,r={};return n.forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof Yt)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,u,c;const l=(c=(u=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||u===void 0?void 0:u[i])===null||c===void 0?void 0:c.resourceId;return l!=null?o[i]=this.resourceIdToCapturedInput[l]:o[i]=e[s++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const o=r[s],i=n[o];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ot(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function gm(t,e={},n=hb){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=i6(t));const r=new o6(t,e,n);return await r.load(),r}function i6(t){return t.endsWith("/")||(t=t+"/"),`${t}${s6}${r6}`}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var _n=function(){return _n=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},_n.apply(this,arguments)};function Qr(t,e,n,r){return new(n||(n=Promise))(function(s,o){function i(c){try{u(r.next(c))}catch(l){o(l)}}function a(c){try{u(r.throw(c))}catch(l){o(l)}}function u(c){var l;c.done?s(c.value):(l=c.value,l instanceof n?l:new n(function(h){h(l)})).then(i,a)}u((r=r.apply(t,[])).next())})}function Zr(t,e){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(c){return function(l){if(n)throw new TypeError("Generator is already executing.");for(;o&&(o=0,l[0]&&(i=0)),i;)try{if(n=1,r&&(s=2&l[0]?r.return:l[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,l[1])).done)return s;switch(r=0,s&&(l=[2&l[0],s.value]),l[0]){case 0:case 1:s=l;break;case 4:return i.label++,{value:l[1],done:!1};case 5:i.label++,r=l[1],l=[0];continue;case 7:l=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||l[0]!==6&&l[0]!==2)){i=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){i.label=l[1];break}if(l[0]===6&&i.label<s[1]){i.label=s[1],s=l;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(l);break}s[2]&&i.ops.pop(),i.trys.pop();continue}l=e.call(t,i)}catch(h){l=[6,h],r=0}finally{n=s=0}if(5&l[0])throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}([u,c])}}}var Cc=["wrist","thumb_cmc","thumb_mcp","thumb_ip","thumb_tip","index_finger_mcp","index_finger_pip","index_finger_dip","index_finger_tip","middle_finger_mcp","middle_finger_pip","middle_finger_dip","middle_finger_tip","ring_finger_mcp","ring_finger_pip","ring_finger_dip","ring_finger_tip","pinky_finger_mcp","pinky_finger_pip","pinky_finger_dip","pinky_finger_tip"],Ll={runtime:"mediapipe",maxHands:2,modelType:"full"},a6=function(){function t(e){var n,r=this;this.width=0,this.height=0,this.selfieMode=!1,this.handsSolution=new Aj({locateFile:function(s,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:o+"/"+s}}),e.modelType==="lite"?n=0:n=1,this.handsSolution.setOptions({modelComplexity:n,selfieMode:this.selfieMode,maxNumHands:e.maxHands}),this.handsSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,r.hands=[],s.multiHandLandmarks!==null)for(var o=s.multiHandedness,i=s.multiHandLandmarks,a=s.multiHandWorldLandmarks,u=0;u<o.length;u++)r.hands.push(_n(_n({},r.translateOutput(i[u],a[u])),{score:o[u].score,handedness:o[u].label}))})}return t.prototype.translateOutput=function(e,n){var r=this;return{keypoints:e.map(function(s,o){return{x:s.x*r.width,y:s.y*r.height,score:s.visibility,name:Cc[o]}}),keypoints3D:n.map(function(s,o){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:Cc[o]}})}},t.prototype.estimateHands=function(e,n){return Qr(this,void 0,void 0,function(){var r,s;return Zr(this,function(o){switch(o.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.handsSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Yt?(s=ImageData.bind,[4,xD(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,o.label=3;case 3:return e=r,[4,this.handsSolution.send({image:e})];case 4:return o.sent(),[2,this.hands]}})})},t.prototype.dispose=function(){this.handsSolution.close()},t.prototype.reset=function(){this.handsSolution.reset(),this.width=0,this.height=0,this.hands=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.handsSolution.initialize()},t}();function u6(t){return Qr(this,void 0,void 0,function(){var e,n;return Zr(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return _n({},Ll);var o=_n({},s);return o.runtime="mediapipe",o.maxHands==null&&(o.maxHands=Ll.maxHands),o.modelType==null&&(o.modelType=Ll.modelType),o}(t),[4,(n=new a6(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function Bl(t){return t.width*t.height}function ym(t){var e=t.xCenter-t.width/2,n=e+t.width,r=t.yCenter-t.height/2;return{xMin:e,xMax:n,yMin:r,yMax:r+t.height,width:t.width,height:t.height}}function c6(t,e){var n=ym(t),r=ym(e);if(!function(i,a){return!(i.xMax<a.xMin||a.xMax<i.xMin||i.yMax<a.yMin||a.yMax<i.yMin)}(n,r))return 0;var s=Bl(function(i,a){var u=Math.max(i.xMin,a.xMin),c=Math.min(i.xMax,a.xMax),l=Math.max(i.yMin,a.yMin),h=Math.min(i.yMax,a.yMax);return{xMin:u,xMax:c,yMin:l,yMax:h,width:Math.max(c-u,0),height:Math.max(h-l,0)}}(n,r)),o=Bl(n)+Bl(r)-s;return o>0?s/o:0}function l6(t,e,n,r){var s=t.width,o=t.height,i=1,a=Math.cos(t.rotation),u=Math.sin(t.rotation),c=t.xCenter,l=t.yCenter,h=1/e,f=1/n,d=new Array(16);return d[0]=s*a*i*h,d[1]=-o*u*h,d[2]=0,d[3]=(-.5*s*a*i+.5*o*u+c)*h,d[4]=s*u*i*f,d[5]=o*a*f,d[6]=0,d[7]=(-.5*o*a-.5*s*u*i+l)*f,d[8]=0,d[9]=0,d[10]=s*h,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,function(m){if(m.length!==16)throw new Error("Array length must be 16 but got "+m.length);return[[m[0],m[1],m[2],m[3]],[m[4],m[5],m[6],m[7]],[m[8],m[9],m[10],m[11]],[m[12],m[13],m[14],m[15]]]}(d)}function sw(t){return t instanceof Yt?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function $c(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function ow(t){return t instanceof Yt?t:bD(t)}function Ml(t,e){I(t.width!==0,function(){return e+" width cannot be 0."}),I(t.height!==0,function(){return e+" height cannot be 0."})}function h6(t,e){var n=function(r,s,o,i){var a=s-r,u=i-o,c=u/a;return{scale:c,offset:o-r*c}}(0,255,e[0],e[1]);return qe(function(){return Fe(he(t,n.scale),n.offset)})}function xm(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,o=e.borderMode,i=e.outputTensorFloatRange,a=sw(t),u=function(f,d){return d?{xCenter:d.xCenter*f.width,yCenter:d.yCenter*f.height,width:d.width*f.width,height:d.height*f.height,rotation:d.rotation}:{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}}(a,n),c=function(f,d,m){if(m===void 0&&(m=!1),!m)return{top:0,left:0,right:0,bottom:0};var x=d.height,g=d.width;Ml(d,"targetSize"),Ml(f,"roi");var y,S,$=x/g,C=f.height/f.width,_=0,L=0;return $>C?(y=f.width,S=f.width*$,L=(1-C/$)/2):(y=f.height/$,S=f.height,_=(1-$/C)/2),f.width=y,f.height=S,{top:L,left:_,right:_,bottom:L}}(u,r,s),l=l6(u,a.width,a.height),h=qe(function(){var f=ow(t),d=Ho(function(g,y,S){return Ml(S,"inputResolution"),[1/S.width*g[0][0]*y.width,1/S.height*g[0][1]*y.width,g[0][3]*y.width,1/S.width*g[1][0]*y.height,1/S.height*g[1][1]*y.height,g[1][3]*y.height,0,0]}(l,a,r),[1,8]),m=o==="zero"?"constant":"nearest",x=el.transform(hs(Dt(f,"float32")),d,"bilinear",m,0,[r.height,r.width]);return i!=null?h6(x,i):x});return{imageTensor:h,padding:c,transformationMatrix:l}}function bm(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function vm(t){return{xCenter:t.xMin+t.width/2,yCenter:t.yMin+t.height/2,width:t.width,height:t.height}}function f6(t){var e=t.relativeKeypoints;if(e.length<=1)throw new Error("2 or more keypoints required to calculate a rect.");var n=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MIN_VALUE,o=Number.MIN_VALUE;return e.forEach(function(i){n=Math.min(n,i.x),s=Math.max(s,i.x),r=Math.min(r,i.y),o=Math.max(o,i.y)}),{xCenter:(n+s)/2,yCenter:(r+o)/2,width:s-n,height:o-r}}function d6(t,e,n,r,s){var o=n==="rect"?function(i,a,u){var c,l=i.locationData;return c=vm(l.boundingBox),c}(t):function(i,a){var u=i.locationData;return a==="boundingbox"?vm(u.relativeBoundingBox):f6(u)}(t,e);return s&&(o.rotation=function(i,a,u){var c,l=i.locationData,h=u.rotationVectorStartKeypointIndex,f=u.rotationVectorEndKeypointIndex;c=u.rotationVectorTargetAngle?u.rotationVectorTargetAngle:Math.PI*u.rotationVectorTargetAngleDegree/180;var d=l.relativeKeypoints[h].x*a.width,m=l.relativeKeypoints[h].y*a.height,x=l.relativeKeypoints[f].x*a.width,g=l.relativeKeypoints[f].y*a.height;return $c(c-Math.atan2(-(g-m),x-d))}(t,r,s)),o}function p6(t){return qe(function(){var e=function(s){return qe(function(){return[We(s,[0,0,0],[1,-1,1]),We(s,[0,0,1],[1,-1,-1])]})}(t),n=e[0],r=e[1];return{boxes:rn(r),logits:rn(n)}})}function m6(t,e,n,r){return Qr(this,void 0,void 0,function(){var s,o,i,a,u;return Zr(this,function(c){switch(c.label){case 0:return t.sort(function(l,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,l.score)}),s=Ho(t.map(function(l){return[l.locationData.relativeBoundingBox.yMin,l.locationData.relativeBoundingBox.xMin,l.locationData.relativeBoundingBox.yMax,l.locationData.relativeBoundingBox.xMax]})),o=gn(t.map(function(l){return l.score[0]})),[4,el.nonMaxSuppressionAsync(s,o,e,n)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),u=t.filter(function(l,h){return a.indexOf(h)>-1}),Ot([s,o,i]),[2,u]}})})}function g6(t,e){return t.map(function(n){var r=_n(_n({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r})}function y6(t,e,n){return Qr(this,void 0,void 0,function(){var r,s,o,i,a;return Zr(this,function(u){switch(u.label){case 0:return r=t[0],s=t[1],o=function(c,l,h){return qe(function(){var f,d,m,x;h.reverseOutputOrder?(d=rn(We(c,[0,h.boxCoordOffset+0],[-1,1])),f=rn(We(c,[0,h.boxCoordOffset+1],[-1,1])),x=rn(We(c,[0,h.boxCoordOffset+2],[-1,1])),m=rn(We(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=rn(We(c,[0,h.boxCoordOffset+0],[-1,1])),d=rn(We(c,[0,h.boxCoordOffset+1],[-1,1])),m=rn(We(c,[0,h.boxCoordOffset+2],[-1,1])),x=rn(We(c,[0,h.boxCoordOffset+3],[-1,1]))),d=Fe(he(Xe(d,h.xScale),l.w),l.x),f=Fe(he(Xe(f,h.yScale),l.h),l.y),h.applyExponentialOnBoxSize?(m=he(Fs(Xe(m,h.hScale)),l.h),x=he(Fs(Xe(x,h.wScale)),l.w)):(m=he(Xe(m,h.hScale),l.h),x=he(Xe(x,h.wScale),l.h));var g=ze(f,Xe(m,2)),y=ze(d,Xe(x,2)),S=Fe(f,Xe(m,2)),$=Fe(d,Xe(x,2)),C=un([ee(g,[h.numBoxes,1]),ee(y,[h.numBoxes,1]),ee(S,[h.numBoxes,1]),ee($,[h.numBoxes,1])],1);if(h.numKeypoints)for(var _=0;_<h.numKeypoints;++_){var L=h.keypointCoordOffset+_*h.numValuesPerKeypoint,V=void 0,z=void 0;h.reverseOutputOrder?(V=rn(We(c,[0,L],[-1,1])),z=rn(We(c,[0,L+1],[-1,1]))):(z=rn(We(c,[0,L],[-1,1])),V=rn(We(c,[0,L+1],[-1,1])));var K=Fe(he(Xe(V,h.xScale),l.w),l.x),q=Fe(he(Xe(z,h.yScale),l.h),l.y);C=un([C,ee(K,[h.numBoxes,1]),ee(q,[h.numBoxes,1])],1)}return C})}(s,e,n),i=qe(function(){var c=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(c=v1(r,-n.scoreClippingThresh,n.scoreClippingThresh)),c=jo(c)):c}),[4,x6(o,i,n)];case 1:return a=u.sent(),Ot([o,i]),[2,a]}})})}function x6(t,e,n){return Qr(this,void 0,void 0,function(){var r,s,o,i,a,u,c,l,h,f,d,m;return Zr(this,function(x){switch(x.label){case 0:return r=[],[4,t.data()];case 1:return s=x.sent(),[4,e.data()];case 2:for(o=x.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&o[i]<n.minScoreThresh||(a=i*n.numCoords,u=b6(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(c=u.locationData.relativeBoundingBox).width<0||c.height<0))){if(n.numKeypoints>0)for((l=u.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,f=0;f<h;f+=n.numValuesPerKeypoint)d=a+n.keypointCoordOffset+f,m={x:s[d+0],y:n.flipVertically?1-s[d+1]:s[d+1]},l.relativeKeypoints.push(m);r.push(u)}return[2,r]}})})}function b6(t,e,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-n:t,xMax:r,yMax:o?1-t:n,width:r-e,height:n-t}}}}function v6(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function wm(t,e,n,r){return Qr(this,void 0,void 0,function(){var s,o,i,a,u,c,l,h;return Zr(this,function(f){switch(f.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,o=s/e.numLandmarks,[4,t.data()];case 1:for(i=f.sent(),a=[],u=0;u<e.numLandmarks;++u)c=u*o,(h={x:0,y:0}).x=n?e.inputImageWidth-i[c]:i[c],o>1&&(h.y=r?e.inputImageHeight-i[c+1]:i[c+1]),o>2&&(h.z=i[c+2]),o>3&&(h.score=v6(e.visibilityActivation,i[c+3])),a.push(h);for(l=0;l<a.length;++l)(h=a[l]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Sm(t,e,n){var r=t.width,s=t.height,o=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(o=function(l,h){return h.rotation!=null?l+=h.rotation:h.rotationDegree!=null&&(l+=Math.PI*h.rotationDegree/180),$c(l)}(o,n)),o===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var i=(e.width*r*n.shiftX*Math.cos(o)-e.height*s*n.shiftY*Math.sin(o))/e.width,a=(e.width*r*n.shiftX*Math.sin(o)+e.height*s*n.shiftY*Math.cos(o))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}if(n.squareLong){var u=Math.max(r*e.width,s*e.height);r=u/e.width,s=u/e.height}else if(n.squareShort){var c=Math.min(r*e.width,s*e.height);r=c/e.width,s=c/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}function w6(t,e){for(var n=function(Z,fe){var xe=Z[0].x*fe.width,$e=Z[0].y*fe.height,Te=(Z[4].x+Z[8].x)/2,ke=(Z[4].y+Z[8].y)/2;return Te=(Te+Z[6].x)/2*fe.width,ke=(ke+Z[6].y)/2*fe.height,$c(Math.PI/2-Math.atan2(-(ke-$e),Te-xe))}(t,e),r=$c(-n),s=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,u=0,c=t;u<c.length;u++){var l=(g=c[u]).x,h=g.y;s=Math.min(s,l),o=Math.max(o,l),i=Math.min(i,h),a=Math.max(a,h)}var f=(o+s)/2,d=(a+i)/2;s=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(var m=0,x=t;m<x.length;m++){var g,y=((g=x[m]).x-f)*e.width,S=(g.y-d)*e.height,$=y*Math.cos(r)-S*Math.sin(r),C=y*Math.sin(r)+S*Math.cos(r);s=Math.min(s,$),o=Math.max(o,$),i=Math.min(i,C),a=Math.max(a,C)}var _=(o+s)/2,L=(a+i)/2,V=_*Math.cos(n)-L*Math.sin(n)+e.width*f,z=_*Math.sin(n)+L*Math.cos(n)+e.height*d,K=(o-s)/e.width,q=(a-i)/e.height;return{xCenter:V/e.width,yCenter:z/e.height,width:K,height:q,rotation:n}}var S6={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},Vl={runtime:"tfjs",modelType:"full",maxHands:2,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/full/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/full/1"},Ul={flipHorizontal:!1,staticImageMode:!1},C6={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2016,numCoords:18,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:7,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.5},$6=.3,T6={shiftX:0,shiftY:-.5,scaleX:2.6,scaleY:2.6,squareLong:!0},N6={shiftX:0,shiftY:-.1,scaleX:2,scaleY:2,squareLong:!0},E6={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},_6={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},I6={numLandmarks:21,inputImageWidth:224,inputImageHeight:224,normalizeZ:.4,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},k6={numLandmarks:21,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},Tc,R6=function(){function t(e,n,r){this.detectorModel=e,this.landmarkModel=n,this.maxHands=r,this.prevHandRectsFromLandmarks=null,this.anchors=function(u){u.reduceBoxesInLowestLayer==null&&(u.reduceBoxesInLowestLayer=!1),u.interpolatedScaleAspectRatio==null&&(u.interpolatedScaleAspectRatio=1),u.fixedAnchorSize==null&&(u.fixedAnchorSize=!1);for(var c=[],l=0;l<u.numLayers;){for(var h=[],f=[],d=[],m=[],x=l;x<u.strides.length&&u.strides[x]===u.strides[l];){var g=bm(u.minScale,u.maxScale,x,u.strides.length);if(x===0&&u.reduceBoxesInLowestLayer)d.push(1),d.push(2),d.push(.5),m.push(.1),m.push(g),m.push(g);else{for(var y=0;y<u.aspectRatios.length;++y)d.push(u.aspectRatios[y]),m.push(g);if(u.interpolatedScaleAspectRatio>0){var S=x===u.strides.length-1?1:bm(u.minScale,u.maxScale,x+1,u.strides.length);m.push(Math.sqrt(g*S)),d.push(u.interpolatedScaleAspectRatio)}}x++}for(var $=0;$<d.length;++$){var C=Math.sqrt(d[$]);h.push(m[$]/C),f.push(m[$]*C)}var _=0,L=0;if(u.featureMapHeight.length>0)_=u.featureMapHeight[l],L=u.featureMapWidth[l];else{var V=u.strides[l];_=Math.ceil(u.inputSizeHeight/V),L=Math.ceil(u.inputSizeWidth/V)}for(var z=0;z<_;++z)for(var K=0;K<L;++K)for(var q=0;q<h.length;++q){var Z={xCenter:(K+u.anchorOffsetX)/L,yCenter:(z+u.anchorOffsetY)/_,width:0,height:0};u.fixedAnchorSize?(Z.width=1,Z.height=1):(Z.width=f[q],Z.height=h[q]),c.push(Z)}l=x}return c}(S6);var s=gn(this.anchors.map(function(u){return u.width})),o=gn(this.anchors.map(function(u){return u.height})),i=gn(this.anchors.map(function(u){return u.xCenter})),a=gn(this.anchors.map(function(u){return u.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return t.prototype.estimateHands=function(e,n){return Qr(this,void 0,void 0,function(){var r,s,o,i,a,u,c,l,h,f,d,m,x,g,y,S,$,C,_=this;return Zr(this,function(L){switch(L.label){case 0:return r=function(K){if(K==null)return _n({},Ul);var q=_n({},K);return q.flipHorizontal==null&&(q.flipHorizontal=Ul.flipHorizontal),q.staticImageMode==null&&(q.staticImageMode=Ul.staticImageMode),q}(n),e==null?(this.reset(),[2,[]]):(s=sw(e),o=qe(function(){var K=Dt(ow(e),"float32");return r.flipHorizontal&&(K=rn(el.flipLeftRight(hs(K,0)),[0])),K}),i=this.prevHandRectsFromLandmarks,r.staticImageMode||i==null||i.length<this.maxHands?[4,this.detectPalm(o)]:[3,2]);case 1:return(u=L.sent()).length===0?(this.reset(),o.dispose(),[2,[]]):(c=u.map(function(K){return _.palmDetectionToRoi(K,s)}),a=c,[3,3]);case 2:a=i,L.label=3;case 3:return V=.5,z=[],[a].forEach(function(K){return K.forEach(function(q){(z=z.filter(function(Z){return c6(q,Z)<=V})).push(q)})}),a=z,[4,Promise.all(a.map(function(K){return _.handLandmarks(K,o)}))];case 4:for(l=L.sent(),h=[],this.prevHandRectsFromLandmarks=[],f=0,d=l;f<d.length;f++)(m=d[f])!=null&&(x=m.landmarks,g=m.worldLandmarks,y=m.handScore,S=m.handedness,this.prevHandRectsFromLandmarks.push(this.handLandmarksToRoi(x,s)),($=g6(x,s))!=null&&$.forEach(function(K,q){delete K.z,K.name=Cc[q]}),(C=g)!=null&&C.forEach(function(K,q){K.name=Cc[q]}),h.push({keypoints:$,keypoints3D:C,handedness:S,score:y}));return o.dispose(),[2,h]}var V,z})})},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Ot([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},t.prototype.reset=function(){this.prevHandRectsFromLandmarks=null},t.prototype.detectPalm=function(e){return Qr(this,void 0,void 0,function(){var n,r,s,o,i,a,u,c,l,h;return Zr(this,function(f){switch(f.label){case 0:return n=xm(e,E6),r=n.imageTensor,s=n.padding,o=this.detectorModel.predict(r),i=p6(o),a=i.boxes,[4,y6([u=i.logits,a],this.anchorTensor,C6)];case 1:return(c=f.sent()).length===0?(Ot([r,o,u,a]),[2,c]):[4,m6(c,this.maxHands,$6)];case 2:return l=f.sent(),h=function(d,m){d===void 0&&(d=[]);for(var x=m.left,g=m.top,y=m.left+m.right,S=m.top+m.bottom,$=0;$<d.length;$++){var C=d[$],_=C.locationData.relativeBoundingBox,L=(_.xMin-x)/(1-y),V=(_.yMin-g)/(1-S),z=_.width/(1-y),K=_.height/(1-S);_.xMin=L,_.yMin=V,_.width=z,_.height=K,_.xMax=L+z,_.yMax=V+K;var q=C.locationData.relativeKeypoints;q&&q.forEach(function(Z){var fe=(Z.x-x)/(1-y),xe=(Z.y-g)/(1-S);Z.x=fe,Z.y=xe})}return d}(l,s),Ot([r,o,u,a]),[2,h]}})})},t.prototype.palmDetectionToRoi=function(e,n){return Sm(d6(e,"boundingbox","normRect",n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:2,rotationVectorTargetAngleDegree:90}),n,T6)},t.prototype.handLandmarks=function(e,n){return Qr(this,void 0,void 0,function(){var r,s,o,i,a,u,c,l,h,f,d,m,x,g,y,S;return Zr(this,function($){switch($.label){case 0:return r=xm(n,_6,e),s=r.imageTensor,o=r.padding,i=this.landmarkModel.execute(s,["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"]),a=i[0],u=i[1],c=i[2],l=i[3],[4,u.data()];case 1:return(h=$.sent()[0])<.5?(Ot(i),Ot(s),[2,null]):[4,c.data()];case 2:return f=$.sent()[0],d=f>=.5?"Left":"Right",[4,wm(a,I6)];case 3:return m=$.sent(),[4,wm(l,k6)];case 4:return x=$.sent(),g=function(C,_){var L=_.left,V=_.top,z=_.left+_.right,K=_.top+_.bottom;return C.map(function(q){return _n(_n({},q),{x:(q.x-L)/(1-z),y:(q.y-V)/(1-K),z:q.z/(1-z)})})}(m,o),y=function(C,_,L){L===void 0&&(L={ignoreRotation:!1});for(var V=[],z=0,K=C;z<K.length;z++){var q=K[z],Z=q.x-.5,fe=q.y-.5,xe=L.ignoreRotation?0:_.rotation,$e=Math.cos(xe)*Z-Math.sin(xe)*fe,Te=Math.sin(xe)*Z+Math.cos(xe)*fe;$e=$e*_.width+_.xCenter,Te=Te*_.height+_.yCenter;var ke=q.z*_.width,Ee=_n({},q);Ee.x=$e,Ee.y=Te,Ee.z=ke,V.push(Ee)}return V}(g,e),S=function(C,_){for(var L=[],V=0,z=C;V<z.length;V++){var K=z[V],q=K.x,Z=K.y,fe=_.rotation,xe=Math.cos(fe)*q-Math.sin(fe)*Z,$e=Math.sin(fe)*q+Math.cos(fe)*Z,Te=_n({},K);Te.x=xe,Te.y=$e,L.push(Te)}return L}(x,e),Ot(i),Ot(s),[2,{landmarks:y,worldLandmarks:S,handScore:h,handedness:d}]}})})},t.prototype.handLandmarksToRoi=function(e,n){return Sm(w6([].concat(e.slice(0,4),e.slice(5,7),e.slice(9,11),e.slice(13,15),e.slice(17,19)),n),n,N6)},t}();function A6(t){return Qr(this,void 0,void 0,function(){var e,n,r,s,o,i;return Zr(this,function(a){switch(a.label){case 0:return e=function(u){if(u==null)return _n({},Vl);var c=_n({},u);if(c.runtime="tfjs",c.maxHands==null&&(c.maxHands=Vl.maxHands),c.modelType==null&&(c.modelType=Vl.modelType),c.modelType!=="lite"&&c.modelType!=="full")throw new Error("Model type must be one of lite or full, but got "+c.modelType);return c.detectorModelUrl==null&&(c.modelType==="lite"?c.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/lite/1":c.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/full/1"),c.landmarkModelUrl==null&&(c.modelType==="lite"?c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/lite/1":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/full/1"),c}(t),n=e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([gm(e.detectorModelUrl,{fromTFHub:n}),gm(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new R6(o,i,e.maxHands)]}})})}function O6(t,e){return Qr(this,void 0,void 0,function(){var n,r;return Zr(this,function(s){if(t===Tc.MediaPipeHands){if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,A6(n)];if(n.runtime==="mediapipe")return[2,u6(n)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(t+" is not a supported model name.")})})}(function(t){t.MediaPipeHands="MediaPipeHands"})(Tc||(Tc={}));function zu(t){throw new Error('Could not dynamically require "'+t+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var iw={exports:{}};(function(t,e){(function(n){t.exports=n()})(function(){return function(){function n(r,s,o){function i(c,l){if(!s[c]){if(!r[c]){var h=typeof zu=="function"&&zu;if(!l&&h)return h(c,!0);if(a)return a(c,!0);var f=new Error("Cannot find module '"+c+"'");throw f.code="MODULE_NOT_FOUND",f}var d=s[c]={exports:{}};r[c][0].call(d.exports,function(m){var x=r[c][1][m];return i(x||m)},d,d.exports,n,r,s,o)}return s[c].exports}for(var a=typeof zu=="function"&&zu,u=0;u<o.length;u++)i(o[u]);return i}return n}()({1:[function(n,r,s){(function(o){(function(){var i=200,a="__lodash_hash_undefined__",u=800,c=16,l=9007199254740991,h="[object Arguments]",f="[object Array]",d="[object AsyncFunction]",m="[object Boolean]",x="[object Date]",g="[object Error]",y="[object Function]",S="[object GeneratorFunction]",$="[object Map]",C="[object Number]",_="[object Null]",L="[object Object]",V="[object Proxy]",z="[object RegExp]",K="[object Set]",q="[object String]",Z="[object Undefined]",fe="[object WeakMap]",xe="[object ArrayBuffer]",$e="[object DataView]",Te="[object Float32Array]",ke="[object Float64Array]",Ee="[object Int8Array]",Ie="[object Int16Array]",Je="[object Int32Array]",Lt="[object Uint8Array]",Bt="[object Uint8ClampedArray]",vt="[object Uint16Array]",tn="[object Uint32Array]",Dn=/[\\^$.*+?()[\]{}|]/g,Pn=/^\[object .+?Constructor\]$/,Wt=/^(?:0|[1-9]\d*)$/,Q={};Q[Te]=Q[ke]=Q[Ee]=Q[Ie]=Q[Je]=Q[Lt]=Q[Bt]=Q[vt]=Q[tn]=!0,Q[h]=Q[f]=Q[xe]=Q[m]=Q[$e]=Q[x]=Q[g]=Q[y]=Q[$]=Q[C]=Q[L]=Q[z]=Q[K]=Q[q]=Q[fe]=!1;var be=typeof o=="object"&&o&&o.Object===Object&&o,ye=typeof self=="object"&&self&&self.Object===Object&&self,Se=be||ye||Function("return this")(),je=typeof s=="object"&&s&&!s.nodeType&&s,rt=je&&typeof r=="object"&&r&&!r.nodeType&&r,k=rt&&rt.exports===je,D=k&&be.process,H=function(){try{var A=rt&&rt.require&&rt.require("util").types;return A||D&&D.binding&&D.binding("util")}catch{}}(),ne=H&&H.isTypedArray;function J(A,W,X){switch(X.length){case 0:return A.call(W);case 1:return A.call(W,X[0]);case 2:return A.call(W,X[0],X[1]);case 3:return A.call(W,X[0],X[1],X[2])}return A.apply(W,X)}function re(A,W){for(var X=-1,_e=Array(A);++X<A;)_e[X]=W(X);return _e}function de(A){return function(W){return A(W)}}function le(A,W){return A==null?void 0:A[W]}function ue(A,W){return function(X){return A(W(X))}}var se=Array.prototype,Oe=Function.prototype,ce=Object.prototype,Ce=Se["__core-js_shared__"],Re=Oe.toString,Le=ce.hasOwnProperty,tt=function(){var A=/[^.]+$/.exec(Ce&&Ce.keys&&Ce.keys.IE_PROTO||"");return A?"Symbol(src)_1."+A:""}(),Ve=ce.toString,Xt=Re.call(Object),Mt=RegExp("^"+Re.call(Le).replace(Dn,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),zt=k?Se.Buffer:void 0,kt=Se.Symbol,qn=Se.Uint8Array;zt&&zt.allocUnsafe;var Br=ue(Object.getPrototypeOf,Object),Gt=Object.create,jt=ce.propertyIsEnumerable,xn=se.splice,Rt=kt?kt.toStringTag:void 0,Fn=function(){try{var A=Pe(Object,"defineProperty");return A({},"",{}),A}catch{}}(),zs=zt?zt.isBuffer:void 0,Gs=Math.max,js=Date.now,So=Pe(Se,"Map"),dn=Pe(Object,"create"),Hs=function(){function A(){}return function(W){if(!Qt(W))return{};if(Gt)return Gt(W);A.prototype=W;var X=new A;return A.prototype=void 0,X}}();function wr(A){var W=-1,X=A==null?0:A.length;for(this.clear();++W<X;){var _e=A[W];this.set(_e[0],_e[1])}}function vs(){this.__data__=dn?dn(null):{},this.size=0}function ws(A){var W=this.has(A)&&delete this.__data__[A];return this.size-=W?1:0,W}function da(A){var W=this.__data__;if(dn){var X=W[A];return X===a?void 0:X}return Le.call(W,A)?W[A]:void 0}function Ht(A){var W=this.__data__;return dn?W[A]!==void 0:Le.call(W,A)}function pa(A,W){var X=this.__data__;return this.size+=this.has(A)?0:1,X[A]=dn&&W===void 0?a:W,this}wr.prototype.clear=vs,wr.prototype.delete=ws,wr.prototype.get=da,wr.prototype.has=Ht,wr.prototype.set=pa;function Nt(A){var W=-1,X=A==null?0:A.length;for(this.clear();++W<X;){var _e=A[W];this.set(_e[0],_e[1])}}function Xn(){this.__data__=[],this.size=0}function gi(A){var W=this.__data__,X=Vr(W,A);if(X<0)return!1;var _e=W.length-1;return X==_e?W.pop():xn.call(W,X,1),--this.size,!0}function Et(A){var W=this.__data__,X=Vr(W,A);return X<0?void 0:W[X][1]}function bn(A){return Vr(this.__data__,A)>-1}function Co(A,W){var X=this.__data__,_e=Vr(X,A);return _e<0?(++this.size,X.push([A,W])):X[_e][1]=W,this}Nt.prototype.clear=Xn,Nt.prototype.delete=gi,Nt.prototype.get=Et,Nt.prototype.has=bn,Nt.prototype.set=Co;function ss(A){var W=-1,X=A==null?0:A.length;for(this.clear();++W<X;){var _e=A[W];this.set(_e[0],_e[1])}}function Ss(){this.size=0,this.__data__={hash:new wr,map:new(So||Nt),string:new wr}}function os(A){var W=Ae(this,A).delete(A);return this.size-=W?1:0,W}function Ks(A){return Ae(this,A).get(A)}function Mr(A){return Ae(this,A).has(A)}function yi(A,W){var X=Ae(this,A),_e=X.size;return X.set(A,W),this.size+=X.size==_e?0:1,this}ss.prototype.clear=Ss,ss.prototype.delete=os,ss.prototype.get=Ks,ss.prototype.has=Mr,ss.prototype.set=yi;function ar(A){var W=this.__data__=new Nt(A);this.size=W.size}function $o(){this.__data__=new Nt,this.size=0}function xi(A){var W=this.__data__,X=W.delete(A);return this.size=W.size,X}function vn(A){return this.__data__.get(A)}function Yn(A){return this.__data__.has(A)}function Cs(A,W){var X=this.__data__;if(X instanceof Nt){var _e=X.__data__;if(!So||_e.length<i-1)return _e.push([A,W]),this.size=++X.size,this;X=this.__data__=new ss(_e)}return X.set(A,W),this.size=X.size,this}ar.prototype.clear=$o,ar.prototype.delete=xi,ar.prototype.get=vn,ar.prototype.has=Yn,ar.prototype.set=Cs;function To(A,W){var X=Vn(A),_e=!X&&Cn(A),Ye=!X&&!_e&&ya(A),ht=!X&&!_e&&!Ye&&xa(A),gt=X||_e||Ye||ht,Qe=gt?re(A.length,String):[],yt=Qe.length;for(var cr in A)gt&&(cr=="length"||Ye&&(cr=="offset"||cr=="parent")||ht&&(cr=="buffer"||cr=="byteLength"||cr=="byteOffset")||mt(cr,yt))||Qe.push(cr);return Qe}function $s(A,W,X){(X!==void 0&&!Vt(A[W],X)||X===void 0&&!(W in A))&&wn(A,W,X)}function bi(A,W,X){var _e=A[W];(!(Le.call(A,W)&&Vt(_e,X))||X===void 0&&!(W in A))&&wn(A,W,X)}function Vr(A,W){for(var X=A.length;X--;)if(Vt(A[X][0],W))return X;return-1}function wn(A,W,X){W=="__proto__"&&Fn?Fn(A,W,{configurable:!0,enumerable:!0,value:X,writable:!0}):A[W]=X}var No=oe();function Ur(A){return A==null?A===void 0?Z:_:Rt&&Rt in Object(A)?He(A):Sr(A)}function Ln(A){return _o(A)&&Ur(A)==h}function nn(A){if(!Qt(A)||_t(A))return!1;var W=Si(A)?Mt:Pn;return W.test(Mn(A))}function Eo(A){return _o(A)&&Xs(A.length)&&!!Q[Ur(A)]}function vi(A){if(!Qt(A))return Qn(A);var W=Kt(A),X=[];for(var _e in A)_e=="constructor"&&(W||!Le.call(A,_e))||X.push(_e);return X}function is(A,W,X,_e,Ye){A!==W&&No(W,function(ht,gt){if(Ye||(Ye=new ar),Qt(ht))ma(A,W,gt,X,is,_e,Ye);else{var Qe=_e?_e(it(A,gt),ht,gt+"",A,W,Ye):void 0;Qe===void 0&&(Qe=ht),$s(A,gt,Qe)}},Ci)}function ma(A,W,X,_e,Ye,ht,gt){var Qe=it(A,X),yt=it(W,X),cr=gt.get(yt);if(cr){$s(A,X,cr);return}var $n=ht?ht(Qe,yt,X+"",A,W,gt):void 0,Qs=$n===void 0;if(Qs){var $i=Vn(yt),Ti=!$i&&ya(yt),Ni=!$i&&!Ti&&xa(yt);$n=yt,$i||Ti||Ni?Vn(Qe)?$n=Qe:qs(Qe)?$n=U(Qe):Ti?(Qs=!1,$n=Sn(yt)):Ni?(Qs=!1,$n=E(yt)):$n=[]:ul(yt)||Cn(yt)?($n=Qe,Cn(Qe)?$n=Nu(Qe):(!Qt(Qe)||Si(Qe))&&($n=st(yt))):Qs=!1}Qs&&(gt.set(yt,$n),Ye($n,yt,_e,ht,gt),gt.delete(yt)),$s(A,X,$n)}function ga(A,W){return as(Cr(A,W,va),A+"")}var Bn=Fn?function(A,W){return Fn(A,"toString",{configurable:!0,enumerable:!1,value:Ys(W),writable:!0})}:va;function Sn(A,W){return A.slice()}function wi(A){var W=new A.constructor(A.byteLength);return new qn(W).set(new qn(A)),W}function E(A,W){var X=wi(A.buffer);return new A.constructor(X,A.byteOffset,A.length)}function U(A,W){var X=-1,_e=A.length;for(W||(W=Array(_e));++X<_e;)W[X]=A[X];return W}function te(A,W,X,_e){var Ye=!X;X||(X={});for(var ht=-1,gt=W.length;++ht<gt;){var Qe=W[ht],yt=void 0;yt===void 0&&(yt=A[Qe]),Ye?wn(X,Qe,yt):bi(X,Qe,yt)}return X}function j(A){return ga(function(W,X){var _e=-1,Ye=X.length,ht=Ye>1?X[Ye-1]:void 0,gt=Ye>2?X[2]:void 0;for(ht=A.length>3&&typeof ht=="function"?(Ye--,ht):void 0,gt&&ct(X[0],X[1],gt)&&(ht=Ye<3?void 0:ht,Ye=1),W=Object(W);++_e<Ye;){var Qe=X[_e];Qe&&A(W,Qe,_e,ht)}return W})}function oe(A){return function(W,X,_e){for(var Ye=-1,ht=Object(W),gt=_e(W),Qe=gt.length;Qe--;){var yt=gt[++Ye];if(X(ht[yt],yt,ht)===!1)break}return W}}function Ae(A,W){var X=A.__data__;return lt(W)?X[typeof W=="string"?"string":"hash"]:X.map}function Pe(A,W){var X=le(A,W);return nn(X)?X:void 0}function He(A){var W=Le.call(A,Rt),X=A[Rt];try{A[Rt]=void 0;var _e=!0}catch{}var Ye=Ve.call(A);return _e&&(W?A[Rt]=X:delete A[Rt]),Ye}function st(A){return typeof A.constructor=="function"&&!Kt(A)?Hs(Br(A)):{}}function mt(A,W){var X=typeof A;return W=W??l,!!W&&(X=="number"||X!="symbol"&&Wt.test(A))&&A>-1&&A%1==0&&A<W}function ct(A,W,X){if(!Qt(X))return!1;var _e=typeof W;return(_e=="number"?ur(X)&&mt(W,X.length):_e=="string"&&W in X)?Vt(X[W],A):!1}function lt(A){var W=typeof A;return W=="string"||W=="number"||W=="symbol"||W=="boolean"?A!=="__proto__":A===null}function _t(A){return!!tt&&tt in A}function Kt(A){var W=A&&A.constructor,X=typeof W=="function"&&W.prototype||ce;return A===X}function Qn(A){var W=[];if(A!=null)for(var X in Object(A))W.push(X);return W}function Sr(A){return Ve.call(A)}function Cr(A,W,X){return W=Gs(W===void 0?A.length-1:W,0),function(){for(var _e=arguments,Ye=-1,ht=Gs(_e.length-W,0),gt=Array(ht);++Ye<ht;)gt[Ye]=_e[W+Ye];Ye=-1;for(var Qe=Array(W+1);++Ye<W;)Qe[Ye]=_e[Ye];return Qe[W]=X(gt),J(A,this,Qe)}}function it(A,W){if(!(W==="constructor"&&typeof A[W]=="function")&&W!="__proto__")return A[W]}var as=Zn(Bn);function Zn(A){var W=0,X=0;return function(){var _e=js(),Ye=c-(_e-X);if(X=_e,Ye>0){if(++W>=u)return arguments[0]}else W=0;return A.apply(void 0,arguments)}}function Mn(A){if(A!=null){try{return Re.call(A)}catch{}try{return A+""}catch{}}return""}function Vt(A,W){return A===W||A!==A&&W!==W}var Cn=Ln(function(){return arguments}())?Ln:function(A){return _o(A)&&Le.call(A,"callee")&&!jt.call(A,"callee")},Vn=Array.isArray;function ur(A){return A!=null&&Xs(A.length)&&!Si(A)}function qs(A){return _o(A)&&ur(A)}var ya=zs||wa;function Si(A){if(!Qt(A))return!1;var W=Ur(A);return W==y||W==S||W==d||W==V}function Xs(A){return typeof A=="number"&&A>-1&&A%1==0&&A<=l}function Qt(A){var W=typeof A;return A!=null&&(W=="object"||W=="function")}function _o(A){return A!=null&&typeof A=="object"}function ul(A){if(!_o(A)||Ur(A)!=L)return!1;var W=Br(A);if(W===null)return!0;var X=Le.call(W,"constructor")&&W.constructor;return typeof X=="function"&&X instanceof X&&Re.call(X)==Xt}var xa=ne?de(ne):Eo;function Nu(A){return te(A,Ci(A))}function Ci(A){return ur(A)?To(A):vi(A)}var ba=j(function(A,W,X){is(A,W,X)});function Ys(A){return function(){return A}}function va(A){return A}function wa(){return!1}r.exports=ba}).call(this)}).call(this,typeof Rr<"u"?Rr:typeof self<"u"?self:typeof window<"u"?window:{})},{}],2:[function(n,r,s){/*! For license information please see shifty.js.LICENSE.txt */(function(o,i){typeof s=="object"&&typeof r=="object"?r.exports=i():typeof s=="object"?s.shifty=i():o.shifty=i()})(self,function(){return function(){var o={720:function(u,c,l){l.r(c),l.d(c,{Scene:function(){return wi},Tweenable:function(){return Ht},interpolate:function(){return vi},processTweens:function(){return js},setBezierFunction:function(){return H},shouldScheduleUpdate:function(){return Hs},tween:function(){return pa},unsetBezierFunction:function(){return ne}});var h={};l.r(h),l.d(h,{bounce:function(){return Q},bouncePast:function(){return be},easeFrom:function(){return Se},easeFromTo:function(){return ye},easeInBack:function(){return Lt},easeInCirc:function(){return ke},easeInCubic:function(){return y},easeInExpo:function(){return xe},easeInOutBack:function(){return vt},easeInOutCirc:function(){return Ie},easeInOutCubic:function(){return $},easeInOutExpo:function(){return Te},easeInOutQuad:function(){return g},easeInOutQuart:function(){return L},easeInOutQuint:function(){return K},easeInOutSine:function(){return fe},easeInQuad:function(){return m},easeInQuart:function(){return C},easeInQuint:function(){return V},easeInSine:function(){return q},easeOutBack:function(){return Bt},easeOutBounce:function(){return Je},easeOutCirc:function(){return Ee},easeOutCubic:function(){return S},easeOutExpo:function(){return $e},easeOutQuad:function(){return x},easeOutQuart:function(){return _},easeOutQuint:function(){return z},easeOutSine:function(){return Z},easeTo:function(){return je},elastic:function(){return tn},linear:function(){return d},swingFrom:function(){return Pn},swingFromTo:function(){return Dn},swingTo:function(){return Wt}});var f={};l.r(f),l.d(f,{afterTween:function(){return wn},beforeTween:function(){return Vr},doesApply:function(){return $s},tweenCreated:function(){return bi}});var d=function(E){return E},m=function(E){return Math.pow(E,2)},x=function(E){return-(Math.pow(E-1,2)-1)},g=function(E){return(E/=.5)<1?.5*Math.pow(E,2):-.5*((E-=2)*E-2)},y=function(E){return Math.pow(E,3)},S=function(E){return Math.pow(E-1,3)+1},$=function(E){return(E/=.5)<1?.5*Math.pow(E,3):.5*(Math.pow(E-2,3)+2)},C=function(E){return Math.pow(E,4)},_=function(E){return-(Math.pow(E-1,4)-1)},L=function(E){return(E/=.5)<1?.5*Math.pow(E,4):-.5*((E-=2)*Math.pow(E,3)-2)},V=function(E){return Math.pow(E,5)},z=function(E){return Math.pow(E-1,5)+1},K=function(E){return(E/=.5)<1?.5*Math.pow(E,5):.5*(Math.pow(E-2,5)+2)},q=function(E){return 1-Math.cos(E*(Math.PI/2))},Z=function(E){return Math.sin(E*(Math.PI/2))},fe=function(E){return-.5*(Math.cos(Math.PI*E)-1)},xe=function(E){return E===0?0:Math.pow(2,10*(E-1))},$e=function(E){return E===1?1:1-Math.pow(2,-10*E)},Te=function(E){return E===0?0:E===1?1:(E/=.5)<1?.5*Math.pow(2,10*(E-1)):.5*(2-Math.pow(2,-10*--E))},ke=function(E){return-(Math.sqrt(1-E*E)-1)},Ee=function(E){return Math.sqrt(1-Math.pow(E-1,2))},Ie=function(E){return(E/=.5)<1?-.5*(Math.sqrt(1-E*E)-1):.5*(Math.sqrt(1-(E-=2)*E)+1)},Je=function(E){return E<1/2.75?7.5625*E*E:E<2/2.75?7.5625*(E-=1.5/2.75)*E+.75:E<2.5/2.75?7.5625*(E-=2.25/2.75)*E+.9375:7.5625*(E-=2.625/2.75)*E+.984375},Lt=function(E){var U=1.70158;return E*E*((U+1)*E-U)},Bt=function(E){var U=1.70158;return(E-=1)*E*((U+1)*E+U)+1},vt=function(E){var U=1.70158;return(E/=.5)<1?E*E*((1+(U*=1.525))*E-U)*.5:.5*((E-=2)*E*((1+(U*=1.525))*E+U)+2)},tn=function(E){return-1*Math.pow(4,-8*E)*Math.sin((6*E-1)*(2*Math.PI)/2)+1},Dn=function(E){var U=1.70158;return(E/=.5)<1?E*E*((1+(U*=1.525))*E-U)*.5:.5*((E-=2)*E*((1+(U*=1.525))*E+U)+2)},Pn=function(E){var U=1.70158;return E*E*((U+1)*E-U)},Wt=function(E){var U=1.70158;return(E-=1)*E*((U+1)*E+U)+1},Q=function(E){return E<1/2.75?7.5625*E*E:E<2/2.75?7.5625*(E-=1.5/2.75)*E+.75:E<2.5/2.75?7.5625*(E-=2.25/2.75)*E+.9375:7.5625*(E-=2.625/2.75)*E+.984375},be=function(E){return E<1/2.75?7.5625*E*E:E<2/2.75?2-(7.5625*(E-=1.5/2.75)*E+.75):E<2.5/2.75?2-(7.5625*(E-=2.25/2.75)*E+.9375):2-(7.5625*(E-=2.625/2.75)*E+.984375)},ye=function(E){return(E/=.5)<1?.5*Math.pow(E,4):-.5*((E-=2)*Math.pow(E,3)-2)},Se=function(E){return Math.pow(E,4)},je=function(E){return Math.pow(E,.25)};function rt(E,U,te,j,oe,Ae){var Pe,He,st,mt,ct,lt=0,_t=0,Kt=0,Qn=function(it){return((lt*it+_t)*it+Kt)*it},Sr=function(it){return(3*lt*it+2*_t)*it+Kt},Cr=function(it){return it>=0?it:0-it};return lt=1-(Kt=3*U)-(_t=3*(j-U)-Kt),st=1-(ct=3*te)-(mt=3*(oe-te)-ct),Pe=E,He=function(it){return 1/(200*it)}(Ae),function(it){return((st*it+mt)*it+ct)*it}(function(it,as){var Zn,Mn,Vt,Cn,Vn,ur;for(Vt=it,ur=0;ur<8;ur++){if(Cn=Qn(Vt)-it,Cr(Cn)<as)return Vt;if(Vn=Sr(Vt),Cr(Vn)<1e-6)break;Vt-=Cn/Vn}if((Vt=it)<(Zn=0))return Zn;if(Vt>(Mn=1))return Mn;for(;Zn<Mn;){if(Cn=Qn(Vt),Cr(Cn-it)<as)return Vt;it>Cn?Zn=Vt:Mn=Vt,Vt=.5*(Mn-Zn)+Zn}return Vt}(Pe,He))}var k,D=function(){var E=arguments.length>0&&arguments[0]!==void 0?arguments[0]:.25,U=arguments.length>1&&arguments[1]!==void 0?arguments[1]:.25,te=arguments.length>2&&arguments[2]!==void 0?arguments[2]:.75,j=arguments.length>3&&arguments[3]!==void 0?arguments[3]:.75;return function(oe){return rt(oe,E,U,te,j,1)}},H=function(E,U,te,j,oe){var Ae=D(U,te,j,oe);return Ae.displayName=E,Ae.x1=U,Ae.y1=te,Ae.x2=j,Ae.y2=oe,Ht.formulas[E]=Ae},ne=function(E){return delete Ht.formulas[E]};function J(E,U){if(!(E instanceof U))throw new TypeError("Cannot call a class as a function")}function re(E,U){for(var te=0;te<U.length;te++){var j=U[te];j.enumerable=j.enumerable||!1,j.configurable=!0,"value"in j&&(j.writable=!0),Object.defineProperty(E,j.key,j)}}function de(E){return de=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(U){return typeof U}:function(U){return U&&typeof Symbol=="function"&&U.constructor===Symbol&&U!==Symbol.prototype?"symbol":typeof U},de(E)}function le(E){return function(U){if(Array.isArray(U))return ue(U)}(E)||function(U){if(typeof Symbol<"u"&&Symbol.iterator in Object(U))return Array.from(U)}(E)||function(U,te){if(U){if(typeof U=="string")return ue(U,te);var j=Object.prototype.toString.call(U).slice(8,-1);return j==="Object"&&U.constructor&&(j=U.constructor.name),j==="Map"||j==="Set"?Array.from(U):j==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(j)?ue(U,te):void 0}}(E)||function(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}()}function ue(E,U){(U==null||U>E.length)&&(U=E.length);for(var te=0,j=new Array(U);te<U;te++)j[te]=E[te];return j}function se(E,U){var te=Object.keys(E);if(Object.getOwnPropertySymbols){var j=Object.getOwnPropertySymbols(E);U&&(j=j.filter(function(oe){return Object.getOwnPropertyDescriptor(E,oe).enumerable})),te.push.apply(te,j)}return te}function Oe(E){for(var U=1;U<arguments.length;U++){var te=arguments[U]!=null?arguments[U]:{};U%2?se(Object(te),!0).forEach(function(j){ce(E,j,te[j])}):Object.getOwnPropertyDescriptors?Object.defineProperties(E,Object.getOwnPropertyDescriptors(te)):se(Object(te)).forEach(function(j){Object.defineProperty(E,j,Object.getOwnPropertyDescriptor(te,j))})}return E}function ce(E,U,te){return U in E?Object.defineProperty(E,U,{value:te,enumerable:!0,configurable:!0,writable:!0}):E[U]=te,E}var Ce,Re,Le,tt="linear",Ve=typeof window<"u"?window:l.g,Xt="afterTween",Mt="afterTweenEnd",zt="beforeTween",kt="tweenCreated",qn="function",Br="string",Gt=Ve.requestAnimationFrame||Ve.webkitRequestAnimationFrame||Ve.oRequestAnimationFrame||Ve.msRequestAnimationFrame||Ve.mozCancelRequestAnimationFrame&&Ve.mozRequestAnimationFrame||setTimeout,jt=function(){},xn=null,Rt=null,Fn=Oe({},h),zs=function(E,U,te,j,oe,Ae,Pe){var He,st,mt,ct=E<Ae?0:(E-Ae)/oe,lt=!1;for(var _t in Pe&&Pe.call&&(lt=!0,He=Pe(ct)),U)lt||(He=((st=Pe[_t]).call?st:Fn[st])(ct)),mt=te[_t],U[_t]=mt+(j[_t]-mt)*He;return U},Gs=function(E,U){var te=E._timestamp,j=E._currentState,oe=E._delay;if(!(U<te+oe)){var Ae=E._duration,Pe=E._targetState,He=te+oe+Ae,st=U>He?He:U;E._hasEnded=st>=He;var mt=Ae-(He-st),ct=E._filters.length>0;if(E._hasEnded)return E._render(Pe,E._data,mt),E.stop(!0);ct&&E._applyFilter(zt),st<te+oe?te=Ae=st=1:te+=oe,zs(st,j,E._originalState,Pe,Ae,te,E._easing),ct&&E._applyFilter(Xt),E._render(j,E._data,mt)}},js=function(){for(var E,U=Ht.now(),te=xn;te;)E=te._next,Gs(te,U),te=E},So=Date.now||function(){return+new Date},dn=!1,Hs=function(E){E&&dn||(dn=E,E&&wr())},wr=function E(){Ce=So(),dn&&Gt.call(Ve,E,16.666666666666668),js()},vs=function(E){var U=arguments.length>1&&arguments[1]!==void 0?arguments[1]:tt,te=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(Array.isArray(U)){var j=D.apply(void 0,le(U));return j}var oe=de(U);if(Fn[U])return Fn[U];if(oe===Br||oe===qn)for(var Ae in E)te[Ae]=U;else for(var Pe in E)te[Pe]=U[Pe]||tt;return te},ws=function(E){E===xn?(xn=E._next)?xn._previous=null:Rt=null:E===Rt?(Rt=E._previous)?Rt._next=null:xn=null:(Re=E._previous,Le=E._next,Re._next=Le,Le._previous=Re),E._previous=E._next=null},da=typeof Promise=="function"?Promise:null;k=Symbol.toStringTag;var Ht=function(){function E(){var j=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},oe=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0;J(this,E),ce(this,k,"Promise"),this._config={},this._data={},this._delay=0,this._filters=[],this._next=null,this._previous=null,this._timestamp=null,this._hasEnded=!1,this._resolve=null,this._reject=null,this._currentState=j||{},this._originalState={},this._targetState={},this._start=jt,this._render=jt,this._promiseCtor=da,oe&&this.setConfig(oe)}var U,te;return U=E,te=[{key:"_applyFilter",value:function(j){for(var oe=this._filters.length;oe>0;oe--){var Ae=this._filters[oe-oe][j];Ae&&Ae(this)}}},{key:"tween",value:function(){var j=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;return this._isPlaying&&this.stop(),!j&&this._config||this.setConfig(j),this._pausedAtTime=null,this._timestamp=E.now(),this._start(this.get(),this._data),this._delay&&this._render(this._currentState,this._data,0),this._resume(this._timestamp)}},{key:"setConfig",value:function(){var j=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},oe=this._config;for(var Ae in j)oe[Ae]=j[Ae];var Pe=oe.promise,He=Pe===void 0?this._promiseCtor:Pe,st=oe.start,mt=st===void 0?jt:st,ct=oe.finish,lt=oe.render,_t=lt===void 0?this._config.step||jt:lt,Kt=oe.step,Qn=Kt===void 0?jt:Kt;this._data=oe.data||oe.attachment||this._data,this._isPlaying=!1,this._pausedAtTime=null,this._scheduleId=null,this._delay=j.delay||0,this._start=mt,this._render=_t||Qn,this._duration=oe.duration||500,this._promiseCtor=He,ct&&(this._resolve=ct);var Sr=j.from,Cr=j.to,it=Cr===void 0?{}:Cr,as=this._currentState,Zn=this._originalState,Mn=this._targetState;for(var Vt in Sr)as[Vt]=Sr[Vt];var Cn=!1;for(var Vn in as){var ur=as[Vn];Cn||de(ur)!==Br||(Cn=!0),Zn[Vn]=ur,Mn[Vn]=it.hasOwnProperty(Vn)?it[Vn]:ur}if(this._easing=vs(this._currentState,oe.easing,this._easing),this._filters.length=0,Cn){for(var qs in E.filters)E.filters[qs].doesApply(this)&&this._filters.push(E.filters[qs]);this._applyFilter(kt)}return this}},{key:"then",value:function(j,oe){var Ae=this;return this._promise=new this._promiseCtor(function(Pe,He){Ae._resolve=Pe,Ae._reject=He}),this._promise.then(j,oe)}},{key:"catch",value:function(j){return this.then().catch(j)}},{key:"finally",value:function(j){return this.then().finally(j)}},{key:"get",value:function(){return Oe({},this._currentState)}},{key:"set",value:function(j){this._currentState=j}},{key:"pause",value:function(){if(this._isPlaying)return this._pausedAtTime=E.now(),this._isPlaying=!1,ws(this),this}},{key:"resume",value:function(){return this._resume()}},{key:"_resume",value:function(){var j=arguments.length>0&&arguments[0]!==void 0?arguments[0]:E.now();return this._timestamp===null?this.tween():this._isPlaying?this._promise:(this._pausedAtTime&&(this._timestamp+=j-this._pausedAtTime,this._pausedAtTime=null),this._isPlaying=!0,xn===null?(xn=this,Rt=this):(this._previous=Rt,Rt._next=this,Rt=this),this)}},{key:"seek",value:function(j){j=Math.max(j,0);var oe=E.now();return this._timestamp+j===0||(this._timestamp=oe-j,Gs(this,oe)),this}},{key:"stop",value:function(){var j=arguments.length>0&&arguments[0]!==void 0&&arguments[0];if(!this._isPlaying)return this;this._isPlaying=!1,ws(this);var oe=this._filters.length>0;return j&&(oe&&this._applyFilter(zt),zs(1,this._currentState,this._originalState,this._targetState,1,0,this._easing),oe&&(this._applyFilter(Xt),this._applyFilter(Mt))),this._resolve&&this._resolve({data:this._data,state:this._currentState,tweenable:this}),this._resolve=null,this._reject=null,this}},{key:"cancel",value:function(){var j=arguments.length>0&&arguments[0]!==void 0&&arguments[0],oe=this._currentState,Ae=this._data,Pe=this._isPlaying;return Pe?(this._reject&&this._reject({data:Ae,state:oe,tweenable:this}),this._resolve=null,this._reject=null,this.stop(j)):this}},{key:"isPlaying",value:function(){return this._isPlaying}},{key:"hasEnded",value:function(){return this._hasEnded}},{key:"setScheduleFunction",value:function(j){E.setScheduleFunction(j)}},{key:"data",value:function(){var j=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null;return j&&(this._data=Oe({},j)),this._data}},{key:"dispose",value:function(){for(var j in this)delete this[j]}}],te&&re(U.prototype,te),E}();function pa(){var E=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},U=new Ht;return U.tween(E),U.tweenable=U,U}ce(Ht,"now",function(){return Ce}),ce(Ht,"setScheduleFunction",function(E){return Gt=E}),ce(Ht,"filters",{}),ce(Ht,"formulas",Fn),Hs(!0);var Nt,Xn,gi=/(\d|-|\.)/,Et=/([^\-0-9.]+)/g,bn=/[0-9.-]+/g,Co=(Nt=bn.source,Xn=/,\s*/.source,new RegExp("rgba?\\(".concat(Nt).concat(Xn).concat(Nt).concat(Xn).concat(Nt,"(").concat(Xn).concat(Nt,")?\\)"),"g")),ss=/^.*\(/,Ss=/#([0-9]|[a-f]){3,6}/gi,os="VAL",Ks=function(E,U){return E.map(function(te,j){return"_".concat(U,"_").concat(j)})};function Mr(E){return parseInt(E,16)}var yi=function(E){return"rgb(".concat((U=E,(U=U.replace(/#/,"")).length===3&&(U=(U=U.split(""))[0]+U[0]+U[1]+U[1]+U[2]+U[2]),[Mr(U.substr(0,2)),Mr(U.substr(2,2)),Mr(U.substr(4,2))]).join(","),")");var U},ar=function(E,U,te){var j=U.match(E),oe=U.replace(E,os);return j&&j.forEach(function(Ae){return oe=oe.replace(os,te(Ae))}),oe},$o=function(E){for(var U in E){var te=E[U];typeof te=="string"&&te.match(Ss)&&(E[U]=ar(Ss,te,yi))}},xi=function(E){var U=E.match(bn),te=U.slice(0,3).map(Math.floor),j=E.match(ss)[0];if(U.length===3)return"".concat(j).concat(te.join(","),")");if(U.length===4)return"".concat(j).concat(te.join(","),",").concat(U[3],")");throw new Error("Invalid rgbChunk: ".concat(E))},vn=function(E){return E.match(bn)},Yn=function(E,U){var te={};return U.forEach(function(j){te[j]=E[j],delete E[j]}),te},Cs=function(E,U){return U.map(function(te){return E[te]})},To=function(E,U){return U.forEach(function(te){return E=E.replace(os,+te.toFixed(4))}),E},$s=function(E){for(var U in E._currentState)if(typeof E._currentState[U]=="string")return!0;return!1};function bi(E){var U=E._currentState;[U,E._originalState,E._targetState].forEach($o),E._tokenData=function(te){var j,oe,Ae={};for(var Pe in te){var He=te[Pe];typeof He=="string"&&(Ae[Pe]={formatString:(j=He,oe=void 0,oe=j.match(Et),oe?(oe.length===1||j.charAt(0).match(gi))&&oe.unshift(""):oe=["",""],oe.join(os)),chunkNames:Ks(vn(He),Pe)})}return Ae}(U)}function Vr(E){var U=E._currentState,te=E._originalState,j=E._targetState,oe=E._easing,Ae=E._tokenData;(function(Pe,He){var st=function(ct){var lt=He[ct].chunkNames,_t=Pe[ct];if(typeof _t=="string"){var Kt=_t.split(" "),Qn=Kt[Kt.length-1];lt.forEach(function(Sr,Cr){return Pe[Sr]=Kt[Cr]||Qn})}else lt.forEach(function(Sr){return Pe[Sr]=_t});delete Pe[ct]};for(var mt in He)st(mt)})(oe,Ae),[U,te,j].forEach(function(Pe){return function(He,st){var mt=function(lt){vn(He[lt]).forEach(function(_t,Kt){return He[st[lt].chunkNames[Kt]]=+_t}),delete He[lt]};for(var ct in st)mt(ct)}(Pe,Ae)})}function wn(E){var U=E._currentState,te=E._originalState,j=E._targetState,oe=E._easing,Ae=E._tokenData;[U,te,j].forEach(function(Pe){return function(He,st){for(var mt in st){var ct=st[mt],lt=ct.chunkNames,_t=ct.formatString,Kt=To(_t,Cs(Yn(He,lt),lt));He[mt]=ar(Co,Kt,xi)}}(Pe,Ae)}),function(Pe,He){for(var st in He){var mt=He[st].chunkNames,ct=Pe[mt[0]];Pe[st]=typeof ct=="string"?mt.map(function(lt){var _t=Pe[lt];return delete Pe[lt],_t}).join(" "):ct}}(oe,Ae)}function No(E,U){var te=Object.keys(E);if(Object.getOwnPropertySymbols){var j=Object.getOwnPropertySymbols(E);U&&(j=j.filter(function(oe){return Object.getOwnPropertyDescriptor(E,oe).enumerable})),te.push.apply(te,j)}return te}function Ur(E){for(var U=1;U<arguments.length;U++){var te=arguments[U]!=null?arguments[U]:{};U%2?No(Object(te),!0).forEach(function(j){Ln(E,j,te[j])}):Object.getOwnPropertyDescriptors?Object.defineProperties(E,Object.getOwnPropertyDescriptors(te)):No(Object(te)).forEach(function(j){Object.defineProperty(E,j,Object.getOwnPropertyDescriptor(te,j))})}return E}function Ln(E,U,te){return U in E?Object.defineProperty(E,U,{value:te,enumerable:!0,configurable:!0,writable:!0}):E[U]=te,E}var nn=new Ht,Eo=Ht.filters,vi=function(E,U,te,j){var oe=arguments.length>4&&arguments[4]!==void 0?arguments[4]:0,Ae=Ur({},E),Pe=vs(E,j);for(var He in nn._filters.length=0,nn.set({}),nn._currentState=Ae,nn._originalState=E,nn._targetState=U,nn._easing=Pe,Eo)Eo[He].doesApply(nn)&&nn._filters.push(Eo[He]);nn._applyFilter("tweenCreated"),nn._applyFilter("beforeTween");var st=zs(te,Ae,E,U,1,oe,Pe);return nn._applyFilter("afterTween"),st};function is(E,U){(U==null||U>E.length)&&(U=E.length);for(var te=0,j=new Array(U);te<U;te++)j[te]=E[te];return j}function ma(E,U){if(!(E instanceof U))throw new TypeError("Cannot call a class as a function")}function ga(E,U){for(var te=0;te<U.length;te++){var j=U[te];j.enumerable=j.enumerable||!1,j.configurable=!0,"value"in j&&(j.writable=!0),Object.defineProperty(E,j.key,j)}}function Bn(E,U){var te=U.get(E);if(!te)throw new TypeError("attempted to get private field on non-instance");return te.get?te.get.call(E):te.value}var Sn=new WeakMap,wi=function(){function E(){ma(this,E),Sn.set(this,{writable:!0,value:[]});for(var j=arguments.length,oe=new Array(j),Ae=0;Ae<j;Ae++)oe[Ae]=arguments[Ae];oe.forEach(this.add.bind(this))}var U,te;return U=E,(te=[{key:"add",value:function(j){return Bn(this,Sn).push(j),j}},{key:"remove",value:function(j){var oe=Bn(this,Sn).indexOf(j);return~oe&&Bn(this,Sn).splice(oe,1),j}},{key:"empty",value:function(){return this.tweenables.map(this.remove.bind(this))}},{key:"isPlaying",value:function(){return Bn(this,Sn).some(function(j){return j.isPlaying()})}},{key:"play",value:function(){return Bn(this,Sn).forEach(function(j){return j.tween()}),this}},{key:"pause",value:function(){return Bn(this,Sn).forEach(function(j){return j.pause()}),this}},{key:"resume",value:function(){return this.playingTweenables.forEach(function(j){return j.resume()}),this}},{key:"stop",value:function(j){return Bn(this,Sn).forEach(function(oe){return oe.stop(j)}),this}},{key:"tweenables",get:function(){return function(oe){if(Array.isArray(oe))return is(oe)}(j=Bn(this,Sn))||function(oe){if(typeof Symbol<"u"&&Symbol.iterator in Object(oe))return Array.from(oe)}(j)||function(oe,Ae){if(oe){if(typeof oe=="string")return is(oe,Ae);var Pe=Object.prototype.toString.call(oe).slice(8,-1);return Pe==="Object"&&oe.constructor&&(Pe=oe.constructor.name),Pe==="Map"||Pe==="Set"?Array.from(oe):Pe==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Pe)?is(oe,Ae):void 0}}(j)||function(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}();var j}},{key:"playingTweenables",get:function(){return Bn(this,Sn).filter(function(j){return!j.hasEnded()})}},{key:"promises",get:function(){return Bn(this,Sn).map(function(j){return j.then()})}}])&&ga(U.prototype,te),E}();Ht.filters.token=f}},i={};function a(u){if(i[u])return i[u].exports;var c=i[u]={exports:{}};return o[u](c,c.exports,a),c.exports}return a.d=function(u,c){for(var l in c)a.o(c,l)&&!a.o(u,l)&&Object.defineProperty(u,l,{enumerable:!0,get:c[l]})},a.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),a.o=function(u,c){return Object.prototype.hasOwnProperty.call(u,c)},a.r=function(u){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(u,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(u,"__esModule",{value:!0})},a(720)}()})},{}],3:[function(n,r,s){var o=n("./shape"),i=n("./utils"),a=function(c,l){this._pathTemplate="M 50,50 m 0,-{radius} a {radius},{radius} 0 1 1 0,{2radius} a {radius},{radius} 0 1 1 0,-{2radius}",this.containerAspectRatio=1,o.apply(this,arguments)};a.prototype=new o,a.prototype.constructor=a,a.prototype._pathString=function(c){var l=c.strokeWidth;c.trailWidth&&c.trailWidth>c.strokeWidth&&(l=c.trailWidth);var h=50-l/2;return i.render(this._pathTemplate,{radius:h,"2radius":h*2})},a.prototype._trailString=function(c){return this._pathString(c)},r.exports=a},{"./shape":8,"./utils":10}],4:[function(n,r,s){var o=n("./shape"),i=n("./utils"),a=function(c,l){this._pathTemplate=l.vertical?"M {center},100 L {center},0":"M 0,{center} L 100,{center}",o.apply(this,arguments)};a.prototype=new o,a.prototype.constructor=a,a.prototype._initializeSvg=function(c,l){var h=l.vertical?"0 0 "+l.strokeWidth+" 100":"0 0 100 "+l.strokeWidth;c.setAttribute("viewBox",h),c.setAttribute("preserveAspectRatio","none")},a.prototype._pathString=function(c){return i.render(this._pathTemplate,{center:c.strokeWidth/2})},a.prototype._trailString=function(c){return this._pathString(c)},r.exports=a},{"./shape":8,"./utils":10}],5:[function(n,r,s){r.exports={Line:n("./line"),Circle:n("./circle"),SemiCircle:n("./semicircle"),Square:n("./square"),Path:n("./path"),Shape:n("./shape"),utils:n("./utils")}},{"./circle":3,"./line":4,"./path":6,"./semicircle":7,"./shape":8,"./square":9,"./utils":10}],6:[function(n,r,s){var o=n("shifty"),i=n("./utils"),a=o.Tweenable,u={easeIn:"easeInCubic",easeOut:"easeOutCubic",easeInOut:"easeInOutCubic"},c=function l(h,f){if(!(this instanceof l))throw new Error("Constructor was called without new keyword");f=i.extend({delay:0,duration:800,easing:"linear",from:{},to:{},step:function(){}},f);var d;i.isString(h)?d=document.querySelector(h):d=h,this.path=d,this._opts=f,this._tweenable=null;var m=this.path.getTotalLength();this.path.style.strokeDasharray=m+" "+m,this.set(0)};c.prototype.value=function(){var h=this._getComputedDashOffset(),f=this.path.getTotalLength(),d=1-h/f;return parseFloat(d.toFixed(6),10)},c.prototype.set=function(h){this.stop(),this.path.style.strokeDashoffset=this._progressToOffset(h);var f=this._opts.step;if(i.isFunction(f)){var d=this._easing(this._opts.easing),m=this._calculateTo(h,d),x=this._opts.shape||this;f(m,x,this._opts.attachment)}},c.prototype.stop=function(){this._stopTween(),this.path.style.strokeDashoffset=this._getComputedDashOffset()},c.prototype.animate=function(h,f,d){f=f||{},i.isFunction(f)&&(d=f,f={});var m=i.extend({},f),x=i.extend({},this._opts);f=i.extend(x,f);var g=this._easing(f.easing),y=this._resolveFromAndTo(h,g,m);this.stop(),this.path.getBoundingClientRect();var S=this._getComputedDashOffset(),$=this._progressToOffset(h),C=this;this._tweenable=new a,this._tweenable.tween({from:i.extend({offset:S},y.from),to:i.extend({offset:$},y.to),duration:f.duration,delay:f.delay,easing:g,step:function(_){C.path.style.strokeDashoffset=_.offset;var L=f.shape||C;f.step(_,L,f.attachment)}}).then(function(_){i.isFunction(d)&&d()}).catch(function(_){throw console.error("Error in tweening:",_),_})},c.prototype._getComputedDashOffset=function(){var h=window.getComputedStyle(this.path,null);return parseFloat(h.getPropertyValue("stroke-dashoffset"),10)},c.prototype._progressToOffset=function(h){var f=this.path.getTotalLength();return f-h*f},c.prototype._resolveFromAndTo=function(h,f,d){return d.from&&d.to?{from:d.from,to:d.to}:{from:this._calculateFrom(f),to:this._calculateTo(h,f)}},c.prototype._calculateFrom=function(h){return o.interpolate(this._opts.from,this._opts.to,this.value(),h)},c.prototype._calculateTo=function(h,f){return o.interpolate(this._opts.from,this._opts.to,h,f)},c.prototype._stopTween=function(){this._tweenable!==null&&(this._tweenable.stop(!0),this._tweenable=null)},c.prototype._easing=function(h){return u.hasOwnProperty(h)?u[h]:h},r.exports=c},{"./utils":10,shifty:2}],7:[function(n,r,s){var o=n("./shape"),i=n("./circle"),a=n("./utils"),u=function(l,h){this._pathTemplate="M 50,50 m -{radius},0 a {radius},{radius} 0 1 1 {2radius},0",this.containerAspectRatio=2,o.apply(this,arguments)};u.prototype=new o,u.prototype.constructor=u,u.prototype._initializeSvg=function(l,h){l.setAttribute("viewBox","0 0 100 50")},u.prototype._initializeTextContainer=function(l,h,f){l.text.style&&(f.style.top="auto",f.style.bottom="0",l.text.alignToBottom?a.setStyle(f,"transform","translate(-50%, 0)"):a.setStyle(f,"transform","translate(-50%, 50%)"))},u.prototype._pathString=i.prototype._pathString,u.prototype._trailString=i.prototype._trailString,r.exports=u},{"./circle":3,"./shape":8,"./utils":10}],8:[function(n,r,s){var o=n("./path"),i=n("./utils"),a="Object is destroyed",u=function c(l,h){if(!(this instanceof c))throw new Error("Constructor was called without new keyword");if(arguments.length!==0){this._opts=i.extend({color:"#555",strokeWidth:1,trailColor:null,trailWidth:null,fill:null,text:{style:{color:null,position:"absolute",left:"50%",top:"50%",padding:0,margin:0,transform:{prefix:!0,value:"translate(-50%, -50%)"}},autoStyleContainer:!0,alignToBottom:!0,value:null,className:"progressbar-text"},svgStyle:{display:"block",width:"100%"},warnings:!1},h,!0),i.isObject(h)&&h.svgStyle!==void 0&&(this._opts.svgStyle=h.svgStyle),i.isObject(h)&&i.isObject(h.text)&&h.text.style!==void 0&&(this._opts.text.style=h.text.style);var f=this._createSvgView(this._opts),d;if(i.isString(l)?d=document.querySelector(l):d=l,!d)throw new Error("Container does not exist: "+l);this._container=d,this._container.appendChild(f.svg),this._opts.warnings&&this._warnContainerAspectRatio(this._container),this._opts.svgStyle&&i.setStyles(f.svg,this._opts.svgStyle),this.svg=f.svg,this.path=f.path,this.trail=f.trail,this.text=null;var m=i.extend({attachment:void 0,shape:this},this._opts);this._progressPath=new o(f.path,m),i.isObject(this._opts.text)&&this._opts.text.value!==null&&this.setText(this._opts.text.value)}};u.prototype.animate=function(l,h,f){if(this._progressPath===null)throw new Error(a);this._progressPath.animate(l,h,f)},u.prototype.stop=function(){if(this._progressPath===null)throw new Error(a);this._progressPath!==void 0&&this._progressPath.stop()},u.prototype.pause=function(){if(this._progressPath===null)throw new Error(a);this._progressPath!==void 0&&this._progressPath._tweenable&&this._progressPath._tweenable.pause()},u.prototype.resume=function(){if(this._progressPath===null)throw new Error(a);this._progressPath!==void 0&&this._progressPath._tweenable&&this._progressPath._tweenable.resume()},u.prototype.destroy=function(){if(this._progressPath===null)throw new Error(a);this.stop(),this.svg.parentNode.removeChild(this.svg),this.svg=null,this.path=null,this.trail=null,this._progressPath=null,this.text!==null&&(this.text.parentNode.removeChild(this.text),this.text=null)},u.prototype.set=function(l){if(this._progressPath===null)throw new Error(a);this._progressPath.set(l)},u.prototype.value=function(){if(this._progressPath===null)throw new Error(a);return this._progressPath===void 0?0:this._progressPath.value()},u.prototype.setText=function(l){if(this._progressPath===null)throw new Error(a);this.text===null&&(this.text=this._createTextContainer(this._opts,this._container),this._container.appendChild(this.text)),i.isObject(l)?(i.removeChildren(this.text),this.text.appendChild(l)):this.text.innerHTML=l},u.prototype._createSvgView=function(l){var h=document.createElementNS("http://www.w3.org/2000/svg","svg");this._initializeSvg(h,l);var f=null;(l.trailColor||l.trailWidth)&&(f=this._createTrail(l),h.appendChild(f));var d=this._createPath(l);return h.appendChild(d),{svg:h,path:d,trail:f}},u.prototype._initializeSvg=function(l,h){l.setAttribute("viewBox","0 0 100 100")},u.prototype._createPath=function(l){var h=this._pathString(l);return this._createPathElement(h,l)},u.prototype._createTrail=function(l){var h=this._trailString(l),f=i.extend({},l);return f.trailColor||(f.trailColor="#eee"),f.trailWidth||(f.trailWidth=f.strokeWidth),f.color=f.trailColor,f.strokeWidth=f.trailWidth,f.fill=null,this._createPathElement(h,f)},u.prototype._createPathElement=function(l,h){var f=document.createElementNS("http://www.w3.org/2000/svg","path");return f.setAttribute("d",l),f.setAttribute("stroke",h.color),f.setAttribute("stroke-width",h.strokeWidth),h.fill?f.setAttribute("fill",h.fill):f.setAttribute("fill-opacity","0"),f},u.prototype._createTextContainer=function(l,h){var f=document.createElement("div");f.className=l.text.className;var d=l.text.style;return d&&(l.text.autoStyleContainer&&(h.style.position="relative"),i.setStyles(f,d),d.color||(f.style.color=l.color)),this._initializeTextContainer(l,h,f),f},u.prototype._initializeTextContainer=function(c,l,h){},u.prototype._pathString=function(l){throw new Error("Override this function for each progress bar")},u.prototype._trailString=function(l){throw new Error("Override this function for each progress bar")},u.prototype._warnContainerAspectRatio=function(l){if(this.containerAspectRatio){var h=window.getComputedStyle(l,null),f=parseFloat(h.getPropertyValue("width"),10),d=parseFloat(h.getPropertyValue("height"),10);i.floatEquals(this.containerAspectRatio,f/d)||(console.warn("Incorrect aspect ratio of container","#"+l.id,"detected:",h.getPropertyValue("width")+"(width)","/",h.getPropertyValue("height")+"(height)","=",f/d),console.warn("Aspect ratio of should be",this.containerAspectRatio))}},r.exports=u},{"./path":6,"./utils":10}],9:[function(n,r,s){var o=n("./shape"),i=n("./utils"),a=function(c,l){this._pathTemplate="M 0,{halfOfStrokeWidth} L {width},{halfOfStrokeWidth} L {width},{width} L {halfOfStrokeWidth},{width} L {halfOfStrokeWidth},{strokeWidth}",this._trailTemplate="M {startMargin},{halfOfStrokeWidth} L {width},{halfOfStrokeWidth} L {width},{width} L {halfOfStrokeWidth},{width} L {halfOfStrokeWidth},{halfOfStrokeWidth}",o.apply(this,arguments)};a.prototype=new o,a.prototype.constructor=a,a.prototype._pathString=function(c){var l=100-c.strokeWidth/2;return i.render(this._pathTemplate,{width:l,strokeWidth:c.strokeWidth,halfOfStrokeWidth:c.strokeWidth/2})},a.prototype._trailString=function(c){var l=100-c.strokeWidth/2;return i.render(this._trailTemplate,{width:l,strokeWidth:c.strokeWidth,halfOfStrokeWidth:c.strokeWidth/2,startMargin:c.strokeWidth/2-c.trailWidth/2})},r.exports=a},{"./shape":8,"./utils":10}],10:[function(n,r,s){var o=n("lodash.merge"),i="Webkit Moz O ms".split(" "),a=.001;function u($,C){var _=$;for(var L in C)if(C.hasOwnProperty(L)){var V=C[L],z="\\{"+L+"\\}",K=new RegExp(z,"g");_=_.replace(K,V)}return _}function c($,C,_){for(var L=$.style,V=0;V<i.length;++V){var z=i[V];L[z+h(C)]=_}L[C]=_}function l($,C){g(C,function(_,L){_!=null&&(x(_)&&_.prefix===!0?c($,L,_.value):$.style[L]=_)})}function h($){return $.charAt(0).toUpperCase()+$.slice(1)}function f($){return typeof $=="string"||$ instanceof String}function d($){return typeof $=="function"}function m($){return Object.prototype.toString.call($)==="[object Array]"}function x($){if(m($))return!1;var C=typeof $;return C==="object"&&!!$}function g($,C){for(var _ in $)if($.hasOwnProperty(_)){var L=$[_];C(L,_)}}function y($,C){return Math.abs($-C)<a}function S($){for(;$.firstChild;)$.removeChild($.firstChild)}r.exports={extend:o,render:u,setStyle:c,setStyles:l,capitalize:h,isString:f,isFunction:d,isObject:x,forEachObject:g,floatEquals:y,removeChildren:S}},{"lodash.merge":1}]},{},[5])(5)})})(iw);var D6=iw.exports;const P6=Fx(D6),F6={class:"fixed inset-0 bg-black/90"},L6={__name:"CommandProgress",props:{progress:Number},setup(t){const e=t;let n;return Dc(()=>{n=new P6.Circle("#container",{strokeWidth:8,color:"#ffffff"}),n.animate(0)}),Bi(()=>e.progress,r=>{n.animate(r,{duration:100})}),(r,s)=>Ym((du(),Lc("div",F6,s[0]||(s[0]=[Kr("div",{class:"flex justify-center items-center h-full"},[Kr("div",{id:"container"})],-1)]),512)),[[Ng,t.progress>0]])}},B6=pf(L6,[["__scopeId","data-v-f314c12f"]]),M6="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20576%20512'%3e%3c!--!Font%20Awesome%20Free%206.6.0%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202024%20Fonticons,%20Inc.--%3e%3cpath%20fill='%23ffffff'%20d='M288%2032c-80.8%200-145.5%2036.8-192.6%2080.6C48.6%20156%2017.3%20208%202.5%20243.7c-3.3%207.9-3.3%2016.7%200%2024.6C17.3%20304%2048.6%20356%2095.4%20399.4C142.5%20443.2%20207.2%20480%20288%20480s145.5-36.8%20192.6-80.6c46.8-43.5%2078.1-95.4%2093-131.1c3.3-7.9%203.3-16.7%200-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5%2068.8%20368.8%2032%20288%2032zM144%20256a144%20144%200%201%201%20288%200%20144%20144%200%201%201%20-288%200zm144-64c0%2035.3-28.7%2064-64%2064c-7.1%200-13.9-1.2-20.3-3.3c-5.5-1.8-11.9%201.6-11.7%207.4c.3%206.9%201.3%2013.8%203.2%2020.7c13.7%2051.2%2066.4%2081.6%20117.6%2067.9s81.6-66.4%2067.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2%206.1-7.4%2011.7c2.1%206.4%203.3%2013.2%203.3%2020.3z'/%3e%3c/svg%3e",V6={class:"fixed inset-0 bg-black/90"},U6={class:"flex justify-center items-center h-full"},W6={class:"flex flex-col"},z6=["src"],G6={__name:"CommandModeIndicator",props:{active:{type:Boolean,default:!1}},setup(t){return(e,n)=>Ym((du(),Lc("div",V6,[Kr("div",U6,[Kr("div",W6,[Kr("img",{class:"h-40",src:zo(M6),alt:"eye"},null,8,z6),n[0]||(n[0]=Kr("p",{class:"text-white text-center uppercase text-4xl font-bold mt-5"},"Command Mode Active",-1))])])],512)),[[Ng,t.active]])}},j6=pf(G6,[["__scopeId","data-v-0cec5975"]]),H6={class:"fixed text-white inset-0",id:"main"},K6={__name:"Signaler",emits:["commandOne","commandTwo","commandThree"],setup(t,{emit:e}){console.log("alv2"),console.log(al);const n=e;navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user",frameRate:{ideal:16},width:640,height:480}}).then(y=>{const S=document.getElementById("video");S.srcObject=y,S.play()}).catch(y=>{console.error("Error al acceder a la cmara: ",y)});let r=null;async function s(){return O6(Tc.MediaPipeHands,{runtime:"mediapipe",modelType:"full",maxHands:1,solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/hands"})}class o{constructor(S,$,C){this.elapsed=0,this.timer=null,this.duration=S,this.callback=$,this.running=!1,this.onTick=C}start(){this.running||(this.running=!0,this.timer=setInterval(()=>{this.elapsed+=100,this.onTick&&this.onTick(Math.round(this.elapsed/this.duration*100)/100),this.elapsed>=this.duration&&(this.callback(),this.stop())},100))}stop(){this.running=!1,this.elapsed=0,clearInterval(this.timer)}}const i=Kl(!1);Bi(i,y=>{y||(g.value=0)});const a=new o(1e3,()=>{i.value=!0,g.value=0},y=>{g.value=y}),u=new o(1200,()=>{i.value=!1}),c=new o(500,()=>{i.value=!1,n("commandOne")}),l=new o(500,()=>{i.value=!1,n("commandTwo")}),h=new o(500,()=>{i.value=!1,n("commandThree")}),f=async()=>{let y=[];const S=document.getElementById("video");y=await r.estimateHands(S,{flipHorizontal:!1});let $=!1;if(y.length>0){const C=y[0].keypoints,_=x(C);$=_===4,i.value&&(_===0||_>4?(c.stop(),l.stop(),h.stop()):_===1?(c.start(),l.stop(),h.stop()):_===2?(l.start(),c.stop(),h.stop()):_===3&&(h.start(),c.stop(),l.stop()))}$&&(i.value||a.start()),$||(a.stop(),i.value?u.start():g.value=0),requestAnimationFrame(f)};Dc(async()=>{r=await s();const y=document.getElementById("video");await new Promise(S=>{y.onloadedmetadata=()=>{S()}}),await f()});function d(y,S,$){const C={x:S.x-y.x,y:S.y-y.y},_={x:$.x-S.x,y:$.y-S.y},L=C.x*_.x+C.y*_.y,V=Math.sqrt(C.x*C.x+C.y*C.y),z=Math.sqrt(_.x*_.x+_.y*_.y);if(V===0||z===0)return null;const K=L/(V*z);return Math.acos(K)*(180/Math.PI)}function m(y,S,$){return d(y,S,$)<20&&y.y>$.y}function x(y){const S=y[5],$=y[6],C=y[8],_=y[9],L=y[10],V=y[12],z=y[13],K=y[14],q=y[16],Z=y[17],fe=y[18],xe=y[20],$e=m(S,$,C),Te=m(_,L,V),ke=m(z,K,q),Ee=m(Z,fe,xe);return[$e,Te,ke,Ee].filter(Boolean).length}const g=Kl(0);return(y,S)=>(du(),Lc("div",H6,[S[0]||(S[0]=Kr("div",{class:"hidden"},[Kr("video",{id:"video",class:"border border-red-500 w-auto h-auto",playsinline:"",style:{"-webkit-transform":"scaleX(-1)",transform:"scaleX(-1)"}})],-1)),jn(B6,{progress:g.value},null,8,["progress"]),jn(j6,{active:i.value},null,8,["active"])]))}},q6={__name:"ScoreboardView",setup(t){const e=[[0,0,0],[255,255,255],[255,0,0],[255,255,0],[255,165,0],[0,255,0],[0,0,255]];let n,r;function s(){n=new tT,r=new nT}function o(){s(),n.setHomeService(),n.state.homeFirstService=!0,n.capturePoint(),c(r.gameToPixels(n))}function i(){n.addGuestScore(),c(r.gameToPixels(n))}function a(){n.addHomeScore(),c(r.gameToPixels(n))}function u(){n.undo(),c(r.gameToPixels(n))}async function c(f){const d=document.getElementById("boardCanvas"),m=d.getContext("2d");d.width=window.innerWidth,d.height=window.innerHeight;const x=Math.floor(d.width/f[0].length),g=Math.floor(d.height/f.length);for(let y=0;y<f.length;y++)for(let S=0;S<f[y].length;S++)m.fillStyle=l(e[f[y][S]]),m.fillRect(Math.floor(S*x),Math.floor(y*g),x,g)}function l(f){return`rgb(${f[0]} ${f[1]} ${f[2]})`}Dc(()=>{o(),window.onresize=h});function h(){c(r.gameToPixels(n))}return(f,d)=>(du(),Lc("main",null,[d[0]||(d[0]=Kr("canvas",{id:"boardCanvas"},null,-1)),jn(K6,{onCommandOne:a,onCommandTwo:i,onCommandThree:u})]))}},X6=J$({history:I$("/"),routes:[{path:"/",name:"scoreboard",component:q6}]}),aw=KC(ZC);aw.use(X6);aw.mount("#app");
